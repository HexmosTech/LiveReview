# LiveReview Onboarding and Evolution Experience Specification# LiveReview Onboarding and Evolution Experience Specification



## Problem Statement## Problem Statement



The current LiveReview setup has significant onboarding friction that prevents users from having a smooth first experience:The current LiveReview setup has significant onboarding friction that prevents users from having a smooth first experience:



1. **Domain Dependency**: The system expects a domain for webhook configuration, making localhost testing difficult1. **Domain Dependency**: The system expects a domain for webhook configuration, making localhost testing difficult

2. **Reverse Proxy Complexity**: Users need to understand and configure nginx/caddy reverse proxy setup immediately2. **Reverse Proxy Complexity**: Users need to understand and configure nginx/caddy reverse proxy setup immediately

3. **URL Configuration Hardcoding**: Git provider settings require specific URL configuration that's deployment-dependent3. **URL Configuration Hardcoding**: Git provider settings require specific URL configuration that's deployment-dependent

4. **Inflexible Architecture**: Moving between deployment phases (localhost â†’ server â†’ domain) requires significant reconfiguration4. **Inflexible Architecture**: Moving between deployment phases (localhost â†’ server â†’ domain) requires significant reconfiguration



## Simplified Solution: Two Modes Only## Simplified Solution: Two Modes Only



### Core Principle: Zero Configuration + URL-Based Auto-Detection### Core Principle: Zero Configuration + URL-Based Auto-Detection



The system automatically detects its deployment mode by examining the URL bar and configures everything accordingly.The system automatically detects its deployment mode by examining the URL bar and configures everything accordingly.



### Essential Configuration Variables Only### Essential Configuration Variables Only



```bash```bash

# .env - Minimal configuration (most values auto-detected from URL)# .env - Minimal configuration (most values auto-detected from URL)

# Generated by lrops.sh# Generated by lrops.sh



# Database & Security (always required)# Database & Security (always required)

DB_PASSWORD=auto_generated_secure_passwordDB_PASSWORD=auto_generated_secure_password

JWT_SECRET=auto_generated_jwt_secretJWT_SECRET=auto_generated_jwt_secret



# Port Configuration (override defaults if needed)# Port Configuration (override defaults if needed)

# LIVEREVIEW_BACKEND_PORT=8888           # Uncomment to override default# BACKEND_PORT=8888           # Uncomment to override default

# LIVEREVIEW_FRONTEND_PORT=8081          # Uncomment to override default# FRONTEND_PORT=8081          # Uncomment to override default



# Production Only (leave empty for local mode)# Production Only (leave empty for local mode)

# LIVEREVIEW_REVERSE_PROXY=true          # Uncomment for production with reverse proxy# REVERSE_PROXY=true          # Uncomment for production with reverse proxy

``````



### Two Deployment Modes (Auto-Detected from URL)### Two Deployment Modes (Auto-Detected from URL)



#### Mode 1: Demo Mode (Default)#### Mode 1: Demo Mode (Default)

- **Detection**: URL contains `localhost` or `127.0.0.1`- **Detection**: URL contains `localhost` or `127.0.0.1`

- **Pattern**: `localhost:8081` â†’ `localhost:8888`- **Pattern**: `localhost:8081` â†’ `localhost:8888`

- **Webhooks**: Disabled (manual triggers only)- **Webhooks**: Disabled (manual triggers only)

- **Network**: localhost binding only- **Network**: localhost binding only

- **Zero configuration required**- **Zero configuration required**

- **Purpose**: Quick customer demos and initial evaluation- **Purpose**: Quick customer demos and initial evaluation



#### Mode 2: Production (Reverse Proxy)#### Mode 2: Production (Reverse Proxy)

- **Detection**: URL does NOT contain `localhost`/`127.0.0.1`- **Detection**: URL does NOT contain `localhost`/`127.0.0.1`

- **Pattern**: `domain.com` or `ip-address` â†’ Proxy â†’ Backend- **Pattern**: `domain.com` or `ip-address` â†’ Proxy â†’ Backend

- **API Calls**: `{current-origin}/api/*` â†’ Backend- **API Calls**: `{current-origin}/api/*` â†’ Backend

- **Webhooks**: `{current-origin}/api/v1/gitlab-hook` â†’ Backend- **Webhooks**: `{current-origin}/api/v1/gitlab-hook` â†’ Backend

- **Network**: 127.0.0.1 binding (behind proxy)- **Network**: 127.0.0.1 binding (behind proxy)

- **Required**: Reverse proxy setup (nginx/caddy/apache)- **Required**: Reverse proxy setup (nginx/caddy/apache)

- **Purpose**: Full production deployment for real usage- **Purpose**: Full production deployment for real usage



### Ultra-Simple Auto-Detection Logic### Ultra-Simple Auto-Detection Logic



Everything is derived from the browser URL bar and environment variables:Everything is derived from the browser URL bar:



```go```go

// internal/config/deployment_config.go (new file)// internal/config/simple_config.go

type DeploymentConfig struct {type Config struct {

    // User-configurable essentials only (from environment)    // User-configurable essentials only

    BackendPort   int  `env:"LIVEREVIEW_BACKEND_PORT" default:"8888"`    BackendPort   int  `env:"BACKEND_PORT" default:"8888"`

    FrontendPort  int  `env:"LIVEREVIEW_FRONTEND_PORT" default:"8081"`    FrontendPort  int  `env:"FRONTEND_PORT" default:"8081"`

    ReverseProxy  bool `env:"LIVEREVIEW_REVERSE_PROXY" default:"false"`    ReverseProxy  bool `env:"REVERSE_PROXY" default:"false"`

        

    // Auto-derived at runtime (not configurable)    // Auto-derived at runtime (not configurable)

    Mode            string // "demo" or "production"    Mode          string // "demo" or "production"

    BackendBind     string // "localhost" or "127.0.0.1"      BackendBind   string // "localhost" or "127.0.0.1"  

    FrontendBind    string // "localhost" or "127.0.0.1"    FrontendBind  string // "localhost" or "127.0.0.1"

    WebhooksEnabled bool   // true only in production mode    WebhooksEnabled bool // true only in production mode

}}



func (c *DeploymentConfig) AutoConfigure() {func (c *Config) AutoConfigure() {

    if c.ReverseProxy {    if c.ReverseProxy {

        // Production mode: behind reverse proxy        // Production mode: behind reverse proxy

        c.Mode = "production"        c.Mode = "production"

        c.BackendBind = "127.0.0.1"    // Internal only        c.BackendBind = "127.0.0.1"    // Internal only

        c.FrontendBind = "127.0.0.1"   // Internal only          c.FrontendBind = "127.0.0.1"   // Internal only  

        c.WebhooksEnabled = true       // Enable webhooks        c.WebhooksEnabled = true       // Enable webhooks

    } else {    } else {

        // Demo mode: direct access for quick evaluation        // Demo mode: direct access for quick evaluation

        c.Mode = "demo"        c.Mode = "demo"

        c.BackendBind = "localhost"    // Local only        c.BackendBind = "localhost"    // Local only

        c.FrontendBind = "localhost"   // Local only        c.FrontendBind = "localhost"   // Local only

        c.WebhooksEnabled = false      // No webhooks        c.WebhooksEnabled = false      // No webhooks

    }    }

}}

``````



### Frontend Auto-Detection (URL-Based)### Frontend Auto-Detection (URL-Based)



**Frontend detects everything from the URL bar:****Frontend detects everything from the URL bar:**



```typescript```typescript

// ui/src/api/client.ts - URL-based detection// ui/src/api/client.ts - URL-based detection

const getAPIURL = (): string => {const getAPIURL = (): string => {

  const { hostname, port, protocol } = window.location;  const { hostname, port, protocol } = window.location;

    

  // Demo mode: localhost or 127.0.0.1  // Demo mode: localhost or 127.0.0.1

  if (hostname === 'localhost' || hostname === '127.0.0.1') {  if (hostname === 'localhost' || hostname === '127.0.0.1') {

    return `http://localhost:8888`;  // Direct to backend port    return `http://localhost:8888`;  // Direct to backend port

  }  }

    

  // Production mode: anything else (domain or IP)  // Production mode: anything else (domain or IP)

  // Assume reverse proxy handles /api/* routing  // Assume reverse proxy handles /api/* routing

  return `${protocol}//${hostname}${port ? ':' + port : ''}/api`;  return `${protocol}//${hostname}${port ? ':' + port : ''}/api`;

};};

``````



### lrops.sh Drastically Simplified### lrops.sh Drastically Simplified



```bash```bash

# lrops.sh - Two-mode setup# lrops.sh - Two-mode setup

setup_configuration() {setup_configuration() {

    echo "ðŸ”§ LiveReview Configuration"    echo "ðŸ”§ LiveReview Configuration"

    echo "=========================="    echo "=========================="

    echo    echo

    echo "Choose deployment mode:"    echo "Choose deployment mode:"

    echo "1. Demo Mode (localhost only) [DEFAULT]"    echo "1. Demo Mode (localhost only) [DEFAULT]"

    echo "2. Production (with reverse proxy)"    echo "2. Production (with reverse proxy)"

    echo    echo

        

    read -p "Choice [1]: " mode_choice    read -p "Choice [1]: " mode_choice

    mode_choice=${mode_choice:-1}    mode_choice=${mode_choice:-1}

        

    case $mode_choice in    case $mode_choice in

        1) setup_demo_mode ;;        1) setup_demo_mode ;;

        2) setup_production_mode ;;        2) setup_production_mode ;;

        *) setup_demo_mode ;;        *) setup_demo_mode ;;

    esac    esac

}}



setup_demo_mode() {setup_demo_mode() {

    cat > "$LIVEREVIEW_INSTALL_DIR/.env" << EOF    cat > "$LIVEREVIEW_INSTALL_DIR/.env" << EOF

# LiveReview Configuration - Demo Mode# LiveReview Configuration - Demo Mode

DB_PASSWORD=$(generate_password)DB_PASSWORD=$(generate_password)

JWT_SECRET=$(generate_jwt_secret)JWT_SECRET=$(generate_jwt_secret)



# Everything else auto-detected from URL bar!# Everything else auto-detected from URL bar!

# Access at: http://localhost:8081# Access at: http://localhost:8081

# API at: http://localhost:8888# API at: http://localhost:8888

# Webhooks: disabled (manual triggers only)# Webhooks: disabled (manual triggers only)

# Perfect for customer demos and initial evaluation# Perfect for customer demos and initial evaluation

EOFEOF

}}



setup_production_mode() {setup_production_mode() {

    cat > "$LIVEREVIEW_INSTALL_DIR/.env" << EOF    cat > "$LIVEREVIEW_INSTALL_DIR/.env" << EOF

# LiveReview Configuration - Production Mode  # LiveReview Configuration - Production Mode  

DB_PASSWORD=$(generate_password)DB_PASSWORD=$(generate_password)

JWT_SECRET=$(generate_jwt_secret)JWT_SECRET=$(generate_jwt_secret)



# Enable reverse proxy mode# Enable reverse proxy mode

LIVEREVIEW_REVERSE_PROXY=trueREVERSE_PROXY=true



# Setup your reverse proxy to route:# Setup your reverse proxy to route:

# / -> localhost:8081 (frontend)# / -> localhost:8081 (frontend)

# /api/* -> localhost:8888 (backend)# /api/* -> localhost:8888 (backend)

# # 

# Customers can upgrade from demo mode by:# Customers can upgrade from demo mode by:

# 1. Setting up reverse proxy configuration# 1. Setting up reverse proxy configuration

# 2. Updating this .env file: LIVEREVIEW_REVERSE_PROXY=true# 2. Updating this .env file: REVERSE_PROXY=true

# 3. Restarting LiveReview (required for binding and URL changes)# 3. Restarting LiveReview (required for binding and URL changes)

# # 

# Note: Restart is needed because:# Note: Restart is needed because:

# - Backend needs to change binding from localhost to 127.0.0.1# - Backend needs to change binding from localhost to 127.0.0.1

# - Frontend needs to change API URL injection# - Frontend needs to change API URL injection

# - No rebuild required - same binary works for both modes# - No rebuild required - same binary works for both modes

EOFEOF

}}

``````



### Benefits of This Ultra-Simple Approach### Benefits of This Ultra-Simple Approach



1. **Zero confusion**: Only two modes, auto-detected1. **Zero confusion**: Only two modes, auto-detected

2. **URL-driven**: Everything derived from where user accesses the app2. **URL-driven**: Everything derived from where user accesses the app

3. **No IP detection**: No need for complex IP auto-detection logic3. **No IP detection**: No need for complex IP auto-detection logic

4. **Reverse proxy agnostic**: Works with any proxy (nginx/caddy/apache)4. **Reverse proxy agnostic**: Works with any proxy (nginx/caddy/apache)

5. **Domain agnostic**: Works with domains, IPs, or any hostname5. **Domain agnostic**: Works with domains, IPs, or any hostname

6. **Minimal configuration**: Only essential settings exposed6. **Minimal configuration**: Only essential settings exposed

7. **Clear demo limitations**: Users understand demo mode constraints7. **Clear demo limitations**: Users understand demo mode constraints

8. **Transparent system info**: Admins see exact configuration and capabilities8. **Transparent system info**: Admins see exact configuration and capabilities

9. **Guided upgrade path**: Clear instructions for production deployment9. **Guided upgrade path**: Clear instructions for production deployment

10. **No TOML interference**: All deployment concerns handled via .env only

11. **Git provider auto-configuration**: Webhook URLs auto-derived, no manual URL setup required

12. **Demo mode git testing**: Can add git providers in demo mode for evaluation without webhook complications

## Technical Implementation Plan

## Technical Implementation Plan

### 1. Simplified Backend Configuration

### 1. Environment Variable Integration (No New Config Files Needed)

```go

The existing `internal/api/server.go` already reads from `.env` files. We just need to add new environment variables:// internal/config/config.go - Minimal configuration struct

type Config struct {

```go    // Essential user configuration

// Read new deployment configuration from environment    BackendPort  int    `env:"BACKEND_PORT" default:"8888"`

deploymentConfig := &DeploymentConfig{    FrontendPort int    `env:"FRONTEND_PORT" default:"8081"`

    BackendPort:  getEnvInt("LIVEREVIEW_BACKEND_PORT", 8888),    BackendBind  string `env:"BACKEND_BIND" default:"auto"`

    FrontendPort: getEnvInt("LIVEREVIEW_FRONTEND_PORT", 8081),    FrontendBind string `env:"FRONTEND_BIND" default:"auto"`

    ReverseProxy: getEnvBool("LIVEREVIEW_REVERSE_PROXY", false),    Domain       string `env:"DOMAIN" default:""`

}    ProxyEnabled bool   `env:"PROXY_ENABLED" default:"false"`

deploymentConfig.AutoConfigure()    

```    // Auto-derived at runtime (not configurable)

    DeploymentMode string `json:"deployment_mode"`

### 2. Frontend Runtime Detection (Update Existing)    BackendURL     string `json:"backend_url"`

    WebhookURL     string `json:"webhook_url"`

The existing `ui/src/api/apiClient.ts` already has detection logic - we just need to refine it:    PublicURL      string `json:"public_url"`

}

```typescript

// ui/src/api/apiClient.ts - Updated detectionfunc (c *Config) AutoConfigure() {

const getBaseUrl = (): string => {    // Auto-detect deployment mode and derive all URLs

  // Check for runtime injection (production)    c.detectMode()

  if (window.LIVEREVIEW_CONFIG?.apiUrl) {    c.deriveURLs()

    return window.LIVEREVIEW_CONFIG.apiUrl;    c.configureBiniding()

  }}

  

  // Auto-detect based on current locationfunc (c *Config) detectMode() {

  const { hostname, port, protocol } = window.location;    if c.Domain != "" && c.ProxyEnabled {

          c.DeploymentMode = "production"

  // Demo mode: localhost or 127.0.0.1    } else if c.BackendBind == "0.0.0.0" || c.FrontendBind == "0.0.0.0" {

  if (hostname === 'localhost' || hostname === '127.0.0.1') {        c.DeploymentMode = "server"

    return `http://localhost:8888`;  // Direct to backend port    } else {

  }        c.DeploymentMode = "localhost"

      }

  // Production mode: anything else - assume reverse proxy}

  return `${protocol}//${hostname}${port ? ':' + port : ''}/api`;```

};

```### 2. Frontend Runtime Detection



### 3. Frontend UI Enhancements```typescript

// ui/src/api/client.ts - Simple runtime detection

#### Demo Mode Banner Componentconst getAPIURL = (): string => {

```typescript  // Check for runtime injection (production)

// ui/src/components/DemoModeBanner.tsx  if (window.LIVEREVIEW_CONFIG?.apiUrl) {

import React from 'react';    return window.LIVEREVIEW_CONFIG.apiUrl;

import { AlertTriangle, Zap } from 'lucide-react';  }

  

export const DemoModeBanner: React.FC = () => {  // Auto-detect based on current location

  const isDemoMode = window.location.hostname === 'localhost' ||   const { hostname, port, protocol } = window.location;

                     window.location.hostname === '127.0.0.1';  

  // Production: domain without port means proxy handles /api/*

  if (!isDemoMode) return null;  if (!port || port === '80' || port === '443') {

    return `${protocol}//${hostname}/api`;

  return (  }

    <div className="bg-gradient-to-r from-orange-100 to-amber-100 border-l-4 border-orange-500 p-4 mb-6">  

      <div className="flex items-center">  // Development/Server: frontend on 8081, backend on 8888

        <AlertTriangle className="h-5 w-5 text-orange-500 mr-3" />  if (port === '8081') {

        <div className="flex-1">    return `${protocol}//${hostname}:8888`;

          <h3 className="text-sm font-medium text-orange-800">  }

            Demo Mode Active  

          </h3>  // Fallback

          <p className="text-sm text-orange-700 mt-1">  return `${protocol}//${hostname}:8888`;

            You're running in demo mode with limited functionality:};

          </p>```

          <ul className="text-sm text-orange-700 mt-2 list-disc list-inside">

            <li>Manual review triggers only (no webhooks)</li>### 3. Frontend UI Enhancements

            <li>Localhost access only</li>

            <li>Not suitable for production use</li>#### Demo Mode Banner Component

          </ul>```typescript

        </div>// ui/src/components/DemoModeBanner.tsx

        <div className="ml-4">import React from 'react';

          <button className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-md text-sm font-medium flex items-center">import { AlertTriangle, Zap } from 'lucide-react';

            <Zap className="h-4 w-4 mr-2" />

            Upgrade to Productionexport const DemoModeBanner: React.FC = () => {

          </button>  const isDemoMode = window.location.hostname === 'localhost' || 

        </div>                     window.location.hostname === '127.0.0.1';

      </div>

    </div>  if (!isDemoMode) return null;

  );

};  return (

```    <div className="bg-gradient-to-r from-orange-100 to-amber-100 border-l-4 border-orange-500 p-4 mb-6">

      <div className="flex items-center">

#### Instance Settings Page Enhancement (Add New Tab)        <AlertTriangle className="h-5 w-5 text-orange-500 mr-3" />

Add a new "Deployment" tab to the existing Settings page (`ui/src/pages/Settings/Settings.tsx`):        <div className="flex-1">

          <h3 className="text-sm font-medium text-orange-800">

```typescript            Demo Mode Active

// Addition to existing Settings.tsx          </h3>

const tabs = [          <p className="text-sm text-orange-700 mt-1">

    { id: 'ai', name: 'AI Providers', icon: <Icons.AI /> },            You're running in demo mode with limited functionality:

    { id: 'git', name: 'Git Providers', icon: <Icons.Git /> },          </p>

    ...(isSuperAdmin ? [          <ul className="text-sm text-orange-700 mt-2 list-disc list-inside">

        { id: 'instance', name: 'Instance', icon: <Icons.Settings /> },            <li>Manual review triggers only (no webhooks)</li>

        { id: 'deployment', name: 'Deployment', icon: <Icons.Server /> }  // NEW TAB            <li>Localhost access only</li>

    ] : []),            <li>Not suitable for production use</li>

];          </ul>

        </div>

// New deployment settings component        <div className="ml-4">

const DeploymentSettings: React.FC = () => {          <button className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-md text-sm font-medium flex items-center">

  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null);            <Zap className="h-4 w-4 mr-2" />

            Upgrade to Production

  useEffect(() => {          </button>

    fetch('/api/v1/system/info')        </div>

      .then(res => res.json())      </div>

      .then(setSystemInfo);    </div>

  }, []);  );

};

  // ... component implementation with system info display```

};

```#### Instance Settings Page Enhancement

```typescript

#### Backend System Info Endpoint (Add to Existing Server)// ui/src/pages/SuperAdmin/InstanceSettings.tsx

Add new endpoint to `internal/api/server.go`:import React, { useEffect, useState } from 'react';

import { Server, Globe, Webhook, AlertTriangle } from 'lucide-react';

```go

// Add to setupRoutes() in server.gointerface SystemInfo {

public.GET("/system/info", s.getSystemInfo)  deployment_mode: 'demo' | 'production';

  version: string;

// New handler function  api_url: string;

func (s *Server) getSystemInfo(c echo.Context) error {  webhook_url?: string;

    // Read deployment configuration from environment  capabilities: {

    deploymentConfig := &DeploymentConfig{    webhooks_enabled: boolean;

        BackendPort:  getEnvInt("LIVEREVIEW_BACKEND_PORT", 8888),    manual_triggers_only: boolean;

        FrontendPort: getEnvInt("LIVEREVIEW_FRONTEND_PORT", 8081),    external_access: boolean;

        ReverseProxy: getEnvBool("LIVEREVIEW_REVERSE_PROXY", false),  };

    }}

    deploymentConfig.AutoConfigure()

export const InstanceSettings: React.FC = () => {

    info := SystemInfo{  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null);

        DeploymentMode: deploymentConfig.Mode,

        Version:        s.versionInfo.Version,  useEffect(() => {

        APIUrl:         fmt.Sprintf("http://%s:%d", deploymentConfig.BackendBind, deploymentConfig.BackendPort),    // Fetch system info from backend

        Capabilities: SystemCapabilities{    fetch('/api/v1/system/info')

            WebhooksEnabled:    deploymentConfig.WebhooksEnabled,      .then(res => res.json())

            ManualTriggersOnly: !deploymentConfig.WebhooksEnabled,      .then(setSystemInfo);

            ExternalAccess:     deploymentConfig.Mode == "production",  }, []);

            ProxyMode:         deploymentConfig.ReverseProxy,

        },  const getModeColor = (mode: string) => {

    }    return mode === 'demo' 

          ? 'bg-orange-100 text-orange-800 border-orange-200'

    return c.JSON(http.StatusOK, info)      : 'bg-green-100 text-green-800 border-green-200';

}  };

```

  const getModeIcon = (mode: string) => {

### 4. Docker Configuration Updates    return mode === 'demo' ? AlertTriangle : Server;

  };

Update existing `docker-compose.yml` to use new environment variables:

  if (!systemInfo) return <div>Loading...</div>;

```yaml

# docker-compose.yml - Environment-driven ports  return (

services:    <div className="space-y-6">

  livereview-app:      <div className="bg-white shadow rounded-lg">

    ports:        <div className="px-6 py-4 border-b border-gray-200">

      - "${LIVEREVIEW_BACKEND_PORT:-8888}:${LIVEREVIEW_BACKEND_PORT:-8888}"          <h3 className="text-lg font-medium text-gray-900">

      - "${LIVEREVIEW_FRONTEND_PORT:-8081}:${LIVEREVIEW_FRONTEND_PORT:-8081}"            Instance Configuration

    env_file: .env          </h3>

```        </div>

        

Update existing `docker-entrypoint.sh`:        <div className="px-6 py-4 space-y-4">

          {/* Deployment Mode */}

```bash          <div className="flex items-center justify-between">

# docker-entrypoint.sh - Use new environment variables            <div className="flex items-center">

start_servers() {              <Server className="h-5 w-5 text-gray-400 mr-3" />

    local backend_port="${LIVEREVIEW_BACKEND_PORT:-8888}"              <span className="text-sm font-medium text-gray-900">

    local frontend_port="${LIVEREVIEW_FRONTEND_PORT:-8081}"                Deployment Mode

                  </span>

    echo "ðŸš€ Starting servers on ports ${frontend_port}/${backend_port}"            </div>

                <span className={`px-3 py-1 rounded-full text-sm font-medium border ${getModeColor(systemInfo.deployment_mode)}`}>

    ./livereview ui --port "$frontend_port" &              {systemInfo.deployment_mode === 'demo' ? 'Demo Mode' : 'Production Mode'}

    ./livereview api --port "$backend_port" &            </span>

              </div>

    wait

}          {/* API Endpoint */}

```          <div className="flex items-center justify-between">

            <div className="flex items-center">

## Migration Path              <Globe className="h-5 w-5 text-gray-400 mr-3" />

              <span className="text-sm font-medium text-gray-900">

### Upgrading from Demo to Production                API Endpoint

              </span>

**No rebuild required!** The same binary works for both modes.            </div>

            <span className="text-sm text-gray-600 font-mono">

**Steps for customers:**              {systemInfo.api_url}

            </span>

1. **Set up reverse proxy** (nginx/caddy/apache) to route:          </div>

   - `/` â†’ `localhost:8081` (frontend)

   - `/api/*` â†’ `localhost:8888` (backend)          {/* Webhook Status */}

          <div className="flex items-center justify-between">

2. **Update configuration:**            <div className="flex items-center">

   ```bash              <Webhook className="h-5 w-5 text-gray-400 mr-3" />

   # Edit .env file              <span className="text-sm font-medium text-gray-900">

   echo "LIVEREVIEW_REVERSE_PROXY=true" >> .env                Webhooks

   ```              </span>

            </div>

3. **Restart LiveReview:**            <div className="flex items-center">

   ```bash              <span className={`w-2 h-2 rounded-full mr-2 ${

   # Using lrops.sh                systemInfo.capabilities.webhooks_enabled ? 'bg-green-500' : 'bg-red-500'

   lrops.sh restart              }`} />

                 <span className="text-sm text-gray-600">

   # Or using docker-compose                {systemInfo.capabilities.webhooks_enabled 

   docker-compose restart                  ? `Enabled (${systemInfo.webhook_url})`

   ```                  : 'Disabled (Demo Mode)'

                }

**What happens during restart:**              </span>

- Backend changes binding from `localhost` to `127.0.0.1` (internal only)            </div>

- Frontend changes binding from `localhost` to `127.0.0.1` (behind proxy)          </div>

- Frontend stops injecting direct API URLs, relies on proxy routing

- Webhooks become available for git provider integration          {/* Capabilities Summary */}

          <div className="pt-4 border-t border-gray-200">

### Backward Compatibility            <h4 className="text-sm font-medium text-gray-900 mb-3">

- Existing demo installations continue working unchanged              Current Capabilities

- No configuration migration scripts needed              </h4>

- Same Docker images work for both modes            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">

- **TOML configuration remains completely untouched**              <div className="flex items-center">

                <div className={`w-2 h-2 rounded-full mr-2 ${

## Benefits                  systemInfo.capabilities.webhooks_enabled ? 'bg-green-500' : 'bg-red-500'

                }`} />

### User Experience                <span className="text-sm text-gray-600">

- **Zero-barrier entry**: Works immediately on localhost                  {systemInfo.capabilities.webhooks_enabled ? 'Automatic' : 'Manual'} Triggers

- **Progressive complexity**: Users only deal with complexity when they need it                </span>

- **Flexible deployment**: Easy to move between different deployment scenarios              </div>

- **Clear guidance**: UI indicates current mode and limitations              

              <div className="flex items-center">

### Technical Benefits                <div className={`w-2 h-2 rounded-full mr-2 ${

- **Reduced support burden**: Fewer configuration-related issues                  !systemInfo.capabilities.manual_triggers_only ? 'bg-green-500' : 'bg-orange-500'

- **Better adoption**: Lower barrier to trying LiveReview                }`} />

- **Flexible architecture**: Supports various deployment patterns                <span className="text-sm text-gray-600">

- **Future-proof**: Easy to add new deployment modes                  {systemInfo.capabilities.manual_triggers_only ? 'Limited' : 'Full'} Integration

- **Clean separation**: Infrastructure setup (env) vs application config (TOML)                </span>

              </div>

### Operational Benefits              

- **Faster onboarding**: Users can evaluate the product immediately              <div className="flex items-center">

- **Reduced documentation**: Less complex setup instructions needed                <div className={`w-2 h-2 rounded-full mr-2 ${

- **Better user satisfaction**: Smooth progression from trial to production                  systemInfo.deployment_mode === 'production' ? 'bg-green-500' : 'bg-orange-500'

                }`} />

## Implementation Timeline                <span className="text-sm text-gray-600">

                  {systemInfo.deployment_mode === 'production' ? 'Production' : 'Demo'} Ready

### Phase 1 (Week 1-2): Foundation                </span>

- Environment variable integration              </div>

- System info endpoint            </div>

- Basic frontend auto-configuration          </div>



### Phase 2 (Week 3-4): Enhanced Configuration          {/* Demo Mode Upgrade Instructions */}

- Frontend UI enhancements          {systemInfo.deployment_mode === 'demo' && (

- lrops.sh improvements            <div className="pt-4 border-t border-gray-200">

- Docker configuration updates              <div className="bg-blue-50 border border-blue-200 rounded-md p-4">

                <h4 className="text-sm font-medium text-blue-900 mb-2">

### Phase 3 (Week 5-6): Polish & Migration                  Upgrade to Production Mode

- Testing and validation                </h4>

- Enhanced UI indicators                <p className="text-sm text-blue-700 mb-3">

- Documentation updates                  To enable full functionality including webhooks and external access:

                </p>

This specification addresses the core onboarding friction while maintaining backward compatibility and providing a clear path for users to evolve their deployments as their needs grow.                <ol className="text-sm text-blue-700 list-decimal list-inside space-y-1">
                  <li>Set up reverse proxy (nginx/caddy/apache)</li>
                  <li>Configure proxy to route <code>/api/*</code> to backend</li>
                  <li>Add <code>REVERSE_PROXY=true</code> to .env file</li>
                  <li>Restart LiveReview instance</li>
                </ol>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

#### Backend System Info Endpoint
```go
// internal/api/system.go - Enhanced system info
type SystemInfo struct {
    DeploymentMode string              `json:"deployment_mode"`
    Version        string              `json:"version"`
    APIUrl         string              `json:"api_url"`
    WebhookUrl     string              `json:"webhook_url,omitempty"`
    Capabilities   SystemCapabilities  `json:"capabilities"`
}

type SystemCapabilities struct {
    WebhooksEnabled     bool `json:"webhooks_enabled"`
    ManualTriggersOnly  bool `json:"manual_triggers_only"`
    ExternalAccess      bool `json:"external_access"`
    ProxyMode          bool `json:"proxy_mode"`
}

func (s *Server) GetSystemInfo(c echo.Context) error {
    config := s.getConfig()
    
    info := SystemInfo{
        DeploymentMode: config.Mode,
        Version:        s.version,
        APIUrl:         config.getAPIURL(c.Request()),
        WebhookUrl:     config.getWebhookURL(),
        Capabilities: SystemCapabilities{
            WebhooksEnabled:    config.WebhooksEnabled,
            ManualTriggersOnly: !config.WebhooksEnabled,
            ExternalAccess:     config.Mode == "production",
            ProxyMode:         config.ReverseProxy,
        },
    }
    
    return c.JSON(http.StatusOK, info)
}
```

### 4. Docker Configuration

```yaml
# docker-compose.yml - Environment-driven ports
services:
  livereview-app:
    ports:
      - "${BACKEND_PORT:-8888}:${BACKEND_PORT:-8888}"
      - "${FRONTEND_PORT:-8081}:${FRONTEND_PORT:-8081}"
    env_file: .env
```

```bash
# docker-entrypoint.sh - Use detected configuration
start_servers() {
    local backend_port="${BACKEND_PORT:-8888}"
    local frontend_port="${FRONTEND_PORT:-8081}"
    
    echo "ðŸš€ Starting servers on ports ${frontend_port}/${backend_port}"
    
    ./livereview ui --port "$frontend_port" &
    ./livereview api --port "$backend_port" &
    
    wait
}
```

## Migration Path

### Upgrading from Demo to Production

**No rebuild required!** The same binary works for both modes.

**Steps for customers:**

1. **Set up reverse proxy** (nginx/caddy/apache) to route:
   - `/` â†’ `localhost:8081` (frontend)
   - `/api/*` â†’ `localhost:8888` (backend)

2. **Update configuration:**
   ```bash
   # Edit .env file
   echo "REVERSE_PROXY=true" >> .env
   ```

3. **Restart LiveReview:**
   ```bash
   # Using lrops.sh
   lrops.sh restart
   
   # Or using docker-compose
   docker-compose restart
   ```

**What happens during restart:**
- Backend changes binding from `localhost` to `127.0.0.1` (internal only)
- Frontend changes binding from `localhost` to `127.0.0.1` (behind proxy)
- Frontend stops injecting direct API URLs, relies on proxy routing
- Webhooks become available for git provider integration

**Zero downtime option:**
- Run production instance on different ports
- Switch proxy configuration
- Stop demo instance

### Backward Compatibility
- Existing demo installations continue working unchanged
- No configuration migration scripts needed  
- Same Docker images work for both modes

## Benefits

### User Experience
- **Zero-barrier entry**: Works immediately on localhost
- **Progressive complexity**: Users only deal with complexity when they need it
- **Flexible deployment**: Easy to move between different deployment scenarios
- **Clear guidance**: UI indicates current mode and limitations

### Technical Benefits
- **Reduced support burden**: Fewer configuration-related issues
- **Better adoption**: Lower barrier to trying LiveReview
- **Flexible architecture**: Supports various deployment patterns
- **Future-proof**: Easy to add new deployment modes

### Operational Benefits
- **Faster onboarding**: Users can evaluate the product immediately
- **Reduced documentation**: Less complex setup instructions needed
- **Better user satisfaction**: Smooth progression from trial to production

## Implementation Timeline

### Phase 1 (Week 1-2): Foundation
- Deployment mode detection
- System info endpoint
- Basic frontend auto-configuration

### Phase 2 (Week 3-4): Enhanced Configuration
- Dynamic webhook configuration
- Git provider URL flexibility
- lrops.sh improvements

### Phase 3 (Week 5-6): Polish & Migration
- Migration scripts for existing installations
- Enhanced UI indicators
- Documentation updates

This specification addresses the core onboarding friction while maintaining backward compatibility and providing a clear path for users to evolve their deployments as their needs grow.

#### Demo Mode Banner Component
```typescript
// ui/src/components/DemoModeBanner.tsx
import React from 'react';
import { AlertTriangle, Zap } from 'lucide-react';

export const DemoModeBanner: React.FC = () => {
  const isDemoMode = window.location.hostname === 'localhost' || 
                     window.location.hostname === '127.0.0.1';

  if (!isDemoMode) return null;

  return (
    <div className="bg-gradient-to-r from-orange-100 to-amber-100 border-l-4 border-orange-500 p-4 mb-6">
      <div className="flex items-center">
        <AlertTriangle className="h-5 w-5 text-orange-500 mr-3" />
        <div className="flex-1">
          <h3 className="text-sm font-medium text-orange-800">
            Demo Mode Active
          </h3>
          <p className="text-sm text-orange-700 mt-1">
            You're running in demo mode with limited functionality:
          </p>
          <ul className="text-sm text-orange-700 mt-2 list-disc list-inside">
            <li>Manual review triggers only (no webhooks)</li>
            <li>Localhost access only</li>
            <li>Not suitable for production use</li>
          </ul>
        </div>
        <div className="ml-4">
          <button className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-md text-sm font-medium flex items-center">
            <Zap className="h-4 w-4 mr-2" />
            Upgrade to Production
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### Instance Settings Page Enhancement
```typescript
// ui/src/pages/SuperAdmin/InstanceSettings.tsx
import React, { useEffect, useState } from 'react';
import { Server, Globe, Webhook } from 'lucide-react';

interface SystemInfo {
  deployment_mode: 'demo' | 'production';
  version: string;
  api_url: string;
  webhook_url?: string;
  capabilities: {
    webhooks_enabled: boolean;
    manual_triggers_only: boolean;
    external_access: boolean;
  };
}

export const InstanceSettings: React.FC = () => {
  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null);

  useEffect(() => {
    // Fetch system info from backend
    fetch('/api/v1/system/info')
      .then(res => res.json())
      .then(setSystemInfo);
  }, []);

  const getModeColor = (mode: string) => {
    return mode === 'demo' 
      ? 'bg-orange-100 text-orange-800 border-orange-200'
      : 'bg-green-100 text-green-800 border-green-200';
  };

  const getModeIcon = (mode: string) => {
    return mode === 'demo' ? AlertTriangle : Server;
  };

  if (!systemInfo) return <div>Loading...</div>;

  return (
    <div className="space-y-6">
      <div className="bg-white shadow rounded-lg">
        <div className="px-6 py-4 border-b border-gray-200">
          <h3 className="text-lg font-medium text-gray-900">
            Instance Configuration
          </h3>
        </div>
        
        <div className="px-6 py-4 space-y-4">
          {/* Deployment Mode */}
          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <Server className="h-5 w-5 text-gray-400 mr-3" />
              <span className="text-sm font-medium text-gray-900">
                Deployment Mode
              </span>
            </div>
            <span className={`px-3 py-1 rounded-full text-sm font-medium border ${getModeColor(systemInfo.deployment_mode)}`}>
              {systemInfo.deployment_mode === 'demo' ? 'Demo Mode' : 'Production Mode'}
            </span>
          </div>

          {/* API Endpoint */}
          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <Globe className="h-5 w-5 text-gray-400 mr-3" />
              <span className="text-sm font-medium text-gray-900">
                API Endpoint
              </span>
            </div>
            <span className="text-sm text-gray-600 font-mono">
              {systemInfo.api_url}
            </span>
          </div>

          {/* Webhook Status */}
          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <Webhook className="h-5 w-5 text-gray-400 mr-3" />
              <span className="text-sm font-medium text-gray-900">
                Webhooks
              </span>
            </div>
            <div className="flex items-center">
              <span className={`w-2 h-2 rounded-full mr-2 ${
                systemInfo.capabilities.webhooks_enabled ? 'bg-green-500' : 'bg-red-500'
              }`} />
              <span className="text-sm text-gray-600">
                {systemInfo.capabilities.webhooks_enabled 
                  ? `Enabled (${systemInfo.webhook_url})`
                  : 'Disabled (Demo Mode)'
                }
              </span>
            </div>
          </div>

          {/* Capabilities Summary */}
          <div className="pt-4 border-t border-gray-200">
            <h4 className="text-sm font-medium text-gray-900 mb-3">
              Current Capabilities
            </h4>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="flex items-center">
                <div className={`w-2 h-2 rounded-full mr-2 ${
                  systemInfo.capabilities.webhooks_enabled ? 'bg-green-500' : 'bg-red-500'
                }`} />
                <span className="text-sm text-gray-600">
                  {systemInfo.capabilities.webhooks_enabled ? 'Automatic' : 'Manual'} Triggers
                </span>
              </div>
              
              <div className="flex items-center">
                <div className={`w-2 h-2 rounded-full mr-2 ${
                  !systemInfo.capabilities.manual_triggers_only ? 'bg-green-500' : 'bg-orange-500'
                }`} />
                <span className="text-sm text-gray-600">
                  {systemInfo.capabilities.manual_triggers_only ? 'Limited' : 'Full'} Integration
                </span>
              </div>
              
              <div className="flex items-center">
                <div className={`w-2 h-2 rounded-full mr-2 ${
                  systemInfo.deployment_mode === 'production' ? 'bg-green-500' : 'bg-orange-500'
                }`} />
                <span className="text-sm text-gray-600">
                  {systemInfo.deployment_mode === 'production' ? 'Production' : 'Demo'} Ready
                </span>
              </div>
            </div>
          </div>

          {/* Demo Mode Upgrade Instructions */}
          {systemInfo.deployment_mode === 'demo' && (
            <div className="pt-4 border-t border-gray-200">
              <div className="bg-blue-50 border border-blue-200 rounded-md p-4">
                <h4 className="text-sm font-medium text-blue-900 mb-2">
                  Upgrade to Production Mode
                </h4>
                <p className="text-sm text-blue-700 mb-3">
                  To enable full functionality including webhooks and external access:
                </p>
                <ol className="text-sm text-blue-700 list-decimal list-inside space-y-1">
                  <li>Set up reverse proxy (nginx/caddy/apache)</li>
                  <li>Configure proxy to route <code>/api/*</code> to backend</li>
                  <li>Add <code>REVERSE_PROXY=true</code> to .env file</li>
                  <li>Restart LiveReview instance</li>
                </ol>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

#### Backend System Info Endpoint
```go
// internal/api/system.go - Enhanced system info
type SystemInfo struct {
    DeploymentMode string              `json:"deployment_mode"`
    Version        string              `json:"version"`
    APIUrl         string              `json:"api_url"`
    WebhookUrl     string              `json:"webhook_url,omitempty"`
    Capabilities   SystemCapabilities  `json:"capabilities"`
}

type SystemCapabilities struct {
    WebhooksEnabled     bool `json:"webhooks_enabled"`
    ManualTriggersOnly  bool `json:"manual_triggers_only"`
    ExternalAccess      bool `json:"external_access"`
    ProxyMode          bool `json:"proxy_mode"`
}

func (s *Server) GetSystemInfo(c echo.Context) error {
    config := s.getConfig()
    
    info := SystemInfo{
        DeploymentMode: config.Mode,
        Version:        s.version,
        APIUrl:         config.getAPIURL(c.Request()),
        WebhookUrl:     config.getWebhookURL(),
        Capabilities: SystemCapabilities{
            WebhooksEnabled:    config.WebhooksEnabled,
            ManualTriggersOnly: !config.WebhooksEnabled,
            ExternalAccess:     config.Mode == "production",
            ProxyMode:         config.ReverseProxy,
        },
    }
    
    return c.JSON(http.StatusOK, info)
}
```setup has significant onboarding friction that prevents users from having a smooth first experience:

1. **Domain Dependency**: The system expects a domain for webhook configuration, making localhost testing difficult
2. **Reverse Proxy Complexity**: Users need to understand and configure nginx/caddy reverse proxy setup immediately
3. **URL Configuration Hardcoding**: Git provider settings require specific URL configuration that's deployment-dependent
4. **Inflexible Architecture**: Moving between deployment phases (localhost â†’ server â†’ domain) requires significant reconfiguration

## Simplified Solution: Two Modes Only

### Core Principle: Zero Configuration + URL-Based Auto-Detection

The system automatically detects its deployment mode by examining the URL bar and configures everything accordingly.

### Essential Configuration Variables Only

```bash
# .env - Minimal configuration (most values auto-detected from URL)
# Generated by lrops.sh

# Database & Security (always required)
DB_PASSWORD=auto_generated_secure_password
JWT_SECRET=auto_generated_jwt_secret

# Port Configuration (override defaults if needed)
# BACKEND_PORT=8888           # Uncomment to override default
# FRONTEND_PORT=8081          # Uncomment to override default

# Production Only (leave empty for local mode)
# REVERSE_PROXY=true          # Uncomment for production with reverse proxy
```

### Two Deployment Modes (Auto-Detected from URL)

#### Mode 1: Demo Mode (Default)
- **Detection**: URL contains `localhost` or `127.0.0.1`
- **Pattern**: `localhost:8081` â†’ `localhost:8888`
- **Webhooks**: Disabled (manual triggers only)
- **Network**: localhost binding only
- **Zero configuration required**
- **Purpose**: Quick customer demos and initial evaluation

#### Mode 2: Production (Reverse Proxy)
- **Detection**: URL does NOT contain `localhost`/`127.0.0.1`
- **Pattern**: `domain.com` or `ip-address` â†’ Proxy â†’ Backend
- **API Calls**: `{current-origin}/api/*` â†’ Backend
- **Webhooks**: `{current-origin}/api/v1/gitlab-hook` â†’ Backend
- **Network**: 127.0.0.1 binding (behind proxy)
- **Required**: Reverse proxy setup (nginx/caddy/apache)
- **Purpose**: Full production deployment for real usage

### Ultra-Simple Auto-Detection Logic

Everything is derived from the browser URL bar:

```go
// internal/config/simple_config.go
type Config struct {
    // User-configurable essentials only
    BackendPort   int  `env:"BACKEND_PORT" default:"8888"`
    FrontendPort  int  `env:"FRONTEND_PORT" default:"8081"`
    ReverseProxy  bool `env:"REVERSE_PROXY" default:"false"`
    
    // Auto-derived at runtime (not configurable)
    Mode          string // "demo" or "production"
    BackendBind   string // "localhost" or "127.0.0.1"  
    FrontendBind  string // "localhost" or "127.0.0.1"
    WebhooksEnabled bool // true only in production mode
}

func (c *Config) AutoConfigure() {
    if c.ReverseProxy {
        // Production mode: behind reverse proxy
        c.Mode = "production"
        c.BackendBind = "127.0.0.1"    // Internal only
        c.FrontendBind = "127.0.0.1"   // Internal only  
        c.WebhooksEnabled = true       // Enable webhooks
    } else {
        // Demo mode: direct access for quick evaluation
        c.Mode = "demo"
        c.BackendBind = "localhost"    // Local only
        c.FrontendBind = "localhost"   // Local only
        c.WebhooksEnabled = false      // No webhooks
    }
}
```

### Frontend Auto-Detection (URL-Based)

**Frontend detects everything from the URL bar:**

```typescript
// ui/src/api/client.ts - URL-based detection
const getAPIURL = (): string => {
  const { hostname, port, protocol } = window.location;
  
  // Demo mode: localhost or 127.0.0.1
  if (hostname === 'localhost' || hostname === '127.0.0.1') {
    return `http://localhost:8888`;  // Direct to backend port
  }
  
  // Production mode: anything else (domain or IP)
  // Assume reverse proxy handles /api/* routing
  return `${protocol}//${hostname}${port ? ':' + port : ''}/api`;
};
```

### lrops.sh Drastically Simplified

```bash
# lrops.sh - Two-mode setup
setup_configuration() {
    echo "ðŸ”§ LiveReview Configuration"
    echo "=========================="
    echo
    echo "Choose deployment mode:"
    echo "1. Demo Mode (localhost only) [DEFAULT]"
    echo "2. Production (with reverse proxy)"
    echo
    
    read -p "Choice [1]: " mode_choice
    mode_choice=${mode_choice:-1}
    
    case $mode_choice in
        1) setup_demo_mode ;;
        2) setup_production_mode ;;
        *) setup_demo_mode ;;
    esac
}

setup_demo_mode() {
    cat > "$LIVEREVIEW_INSTALL_DIR/.env" << EOF
# LiveReview Configuration - Demo Mode
DB_PASSWORD=$(generate_password)
JWT_SECRET=$(generate_jwt_secret)

# Everything else auto-detected from URL bar!
# Access at: http://localhost:8081
# API at: http://localhost:8888
# Webhooks: disabled (manual triggers only)
# Perfect for customer demos and initial evaluation
EOF
}

setup_production_mode() {
    cat > "$LIVEREVIEW_INSTALL_DIR/.env" << EOF
# LiveReview Configuration - Production Mode  
DB_PASSWORD=$(generate_password)
JWT_SECRET=$(generate_jwt_secret)

# Enable reverse proxy mode
REVERSE_PROXY=true

# Setup your reverse proxy to route:
# / -> localhost:8081 (frontend)
# /api/* -> localhost:8888 (backend)
# 
# Customers can upgrade from demo mode by:
# 1. Setting up reverse proxy configuration
# 2. Updating this .env file: REVERSE_PROXY=true
# 3. Restarting LiveReview (required for binding and URL changes)
# 
# Note: Restart is needed because:
# - Backend needs to change binding from localhost to 127.0.0.1
# - Frontend needs to change API URL injection
# - No rebuild required - same binary works for both modes
EOF
}
```

### Benefits of This Ultra-Simple Approach

1. **Zero confusion**: Only two modes, auto-detected
2. **URL-driven**: Everything derived from where user accesses the app
3. **No IP detection**: No need for complex IP auto-detection logic
4. **Reverse proxy agnostic**: Works with any proxy (nginx/caddy/apache)
5. **Domain agnostic**: Works with domains, IPs, or any hostname
6. **Minimal configuration**: Only essential settings exposed
7. **Clear demo limitations**: Users understand demo mode constraints
8. **Transparent system info**: Admins see exact configuration and capabilities
9. **Guided upgrade path**: Clear instructions for production deployment

## Key Architectural Patterns

### Three Simple Deployment Patterns

#### Pattern 1: Localhost Development
```
Frontend (localhost:8081) â†’ Backend (localhost:8888)
- No proxy, no webhooks, no external access
- Zero configuration required
```

#### Pattern 2: Server Deployment  
```
Frontend (server-ip:8081) â†’ Backend (server-ip:8888)
Git Webhooks â†’ Backend (server-ip:8888/api/v1/gitlab-hook)
- No proxy, direct port access
- Minimal configuration: BACKEND_BIND=0.0.0.0
```

#### Pattern 3: Production with Proxy
```
Browser â†’ Proxy â†’ Frontend (127.0.0.1:8081)
API calls â†’ Proxy (/api/*) â†’ Backend (127.0.0.1:8888)  
Git Webhooks â†’ Proxy â†’ Backend (127.0.0.1:8888/api/v1/gitlab-hook)
- Reverse proxy handles routing
- Required: DOMAIN and PROXY_ENABLED=true
```

## Technical Implementation Plan

### 1. Simplified Backend Configuration

```go
// internal/config/config.go - Minimal configuration struct
type Config struct {
    // Essential user configuration
    BackendPort  int    `env:"BACKEND_PORT" default:"8888"`
    FrontendPort int    `env:"FRONTEND_PORT" default:"8081"`
    BackendBind  string `env:"BACKEND_BIND" default:"auto"`
    FrontendBind string `env:"FRONTEND_BIND" default:"auto"`
    Domain       string `env:"DOMAIN" default:""`
    ProxyEnabled bool   `env:"PROXY_ENABLED" default:"false"`
    
    // Auto-derived at runtime (not configurable)
    DeploymentMode string `json:"deployment_mode"`
    BackendURL     string `json:"backend_url"`
    WebhookURL     string `json:"webhook_url"`
    PublicURL      string `json:"public_url"`
}

func (c *Config) AutoConfigure() {
    // Auto-detect deployment mode and derive all URLs
    c.detectMode()
    c.deriveURLs()
    c.configureBiniding()
}

func (c *Config) detectMode() {
    if c.Domain != "" && c.ProxyEnabled {
        c.DeploymentMode = "production"
    } else if c.BackendBind == "0.0.0.0" || c.FrontendBind == "0.0.0.0" {
        c.DeploymentMode = "server"
    } else {
        c.DeploymentMode = "localhost"
    }
}
```

### 2. Frontend Runtime Detection

```typescript
// ui/src/api/client.ts - Simple runtime detection
const getAPIURL = (): string => {
  // Check for runtime injection (production)
  if (window.LIVEREVIEW_CONFIG?.apiUrl) {
    return window.LIVEREVIEW_CONFIG.apiUrl;
  }
  
  // Auto-detect based on current location
  const { hostname, port, protocol } = window.location;
  
  // Production: domain without port means proxy handles /api/*
  if (!port || port === '80' || port === '443') {
    return `${protocol}//${hostname}/api`;
  }
  
  // Development/Server: frontend on 8081, backend on 8888
  if (port === '8081') {
    return `${protocol}//${hostname}:8888`;
  }
  
  // Fallback
  return `${protocol}//${hostname}:8888`;
};
```

### 3. Docker Configuration

```yaml
# docker-compose.yml - Environment-driven ports
services:
  livereview-app:
    ports:
      - "${BACKEND_PORT:-8888}:${BACKEND_PORT:-8888}"
      - "${FRONTEND_PORT:-8081}:${FRONTEND_PORT:-8081}"
    env_file: .env
```

```bash
# docker-entrypoint.sh - Use detected configuration
start_servers() {
    local backend_port="${BACKEND_PORT:-8888}"
    local frontend_port="${FRONTEND_PORT:-8081}"
    
    echo "ðŸš€ Starting servers on ports ${frontend_port}/${backend_port}"
    
    ./livereview ui --port "$frontend_port" &
    ./livereview api --port "$backend_port" &
    
    wait
}
```

## End-to-End Configuration Flow

### Configuration Layers (Priority Order)

1. **lrops.sh Initial Setup** â†’ Creates `.env` file with basic configuration
2. **Docker Compose** â†’ Reads `.env` file and passes to containers
3. **docker-entrypoint.sh** â†’ Uses environment variables to start services
4. **Go Backend (cmd/api.go, cmd/ui.go)** â†’ Reads ports from CLI flags/env vars
5. **Frontend Runtime** â†’ Receives API URL via `window.LIVEREVIEW_CONFIG` injection

### Complete Implementation Flow

#### Step 1: lrops.sh Configuration Generation
```bash
# In lrops.sh configure_system() function
configure_system() {
    local mode="$1"
    local config_file="$LIVEREVIEW_INSTALL_DIR/.env"
    
    # Base configuration (always required)
    cat > "$config_file" << EOF
# Generated by lrops.sh on $(date)
# LiveReview Configuration

# Core settings
DB_PASSWORD=${db_password}
JWT_SECRET=${jwt_secret}
LIVEREVIEW_VERSION=${LIVEREVIEW_VERSION}

# Port configuration (user-configurable, defaults: 8888/8081)
API_PORT=${API_PORT:-8888}
UI_PORT=${UI_PORT:-8081}

EOF

    # Mode-specific configuration
    case "$mode" in
        "localhost")
            cat >> "$config_file" << EOF
# Localhost Testing Mode
DEPLOYMENT_MODE=localhost
DOMAIN=localhost
LIVEREVIEW_API_URL=auto
WEBHOOKS_ENABLED=false
PUBLIC_ENDPOINT=
EOF
            ;;
        "server")
            local public_ip="${PUBLIC_IP:-$(detect_public_ip)}"
            cat >> "$config_file" << EOF
# Server Deployment Mode
DEPLOYMENT_MODE=server
PUBLIC_IP=${public_ip}
DOMAIN=${DOMAIN:-${public_ip}}
LIVEREVIEW_API_URL=http://${public_ip}:\${API_PORT}
WEBHOOKS_ENABLED=auto
PUBLIC_ENDPOINT=http://${public_ip}:\${API_PORT}
FALLBACK_TO_MANUAL=true
EOF
            ;;
        "production")
            cat >> "$config_file" << EOF
# Production Mode
DEPLOYMENT_MODE=production
DOMAIN=${DOMAIN}
LIVEREVIEW_API_URL=https://${DOMAIN}/api
WEBHOOKS_ENABLED=true
PUBLIC_ENDPOINT=https://${DOMAIN}
SSL_REQUIRED=true
RATE_LIMITING=true
CORS_ORIGINS=https://${DOMAIN}
EOF
            ;;
    esac
}
```

#### Step 2: Docker Compose Environment Injection
```yaml
# docker-compose.yml - Updated with configurable ports
services:
  livereview-app:
    build: .
    container_name: livereview-app
    ports:
      - "${API_PORT:-8888}:${API_PORT:-8888}"  # Backend API (configurable)
      - "${UI_PORT:-8081}:${UI_PORT:-8081}"    # Frontend UI (configurable)
    env_file:
      - .env
    environment:
      # Pass through all .env variables
      - DATABASE_URL=postgres://livereview:${DB_PASSWORD}@livereview-db:5432/livereview?sslmode=disable
      - LIVEREVIEW_VERSION=${LIVEREVIEW_VERSION:-development}
      # API URL configuration for frontend injection
      - LIVEREVIEW_API_URL=${LIVEREVIEW_API_URL}
      - API_PORT=${API_PORT:-8888}
      - UI_PORT=${UI_PORT:-8081}
      - DEPLOYMENT_MODE=${DEPLOYMENT_MODE:-localhost}
```

#### Step 3: docker-entrypoint.sh Service Startup
```bash
# docker-entrypoint.sh - Updated startup script
start_servers() {
    echo "ðŸš€ Starting LiveReview servers..."
    
    # Get ports from environment (with defaults)
    local api_port="${API_PORT:-8888}"
    local ui_port="${UI_PORT:-8081}"
    local api_url="${LIVEREVIEW_API_URL}"
    
    # If LIVEREVIEW_API_URL is "auto", resolve it based on deployment mode
    if [[ "$api_url" == "auto" ]]; then
        case "${DEPLOYMENT_MODE:-localhost}" in
            "localhost")
                api_url="http://localhost:${api_port}"
                ;;
            "server")
                if [[ -n "$PUBLIC_IP" ]]; then
                    api_url="http://${PUBLIC_IP}:${api_port}"
                else
                    api_url="http://localhost:${api_port}"
                fi
                ;;
            "production")
                api_url="https://${DOMAIN}/api"
                ;;
        esac
    fi
    
    echo "  - UI server will start on port ${ui_port}"
    echo "  - API server will start on port ${api_port}"
    echo "  - UI will be configured to use API at: ${api_url}"
    
    # Start UI server with runtime API URL injection
    echo "ðŸŽ¨ Starting UI server..."
    ./livereview ui --port "${ui_port}" --api-url "${api_url}" &
    UI_PID=$!
    
    # Start API server
    echo "âš™ï¸  Starting API server..."
    ./livereview api --port "${api_port}" &
    API_PID=$!
    
    # Wait for services to be ready
    wait $UI_PID $API_PID
}
```

#### Step 4: Go Backend Port Configuration
```go
// cmd/api.go - Environment-aware port configuration
func APICommand() *cli.Command {
    return &cli.Command{
        Name:  "api",
        Usage: "Start the LiveReview API server",
        Flags: []cli.Flag{
            &cli.IntFlag{
                Name:    "port",
                Aliases: []string{"p"},
                Usage:   "Port for the API server",
                Value:   8888,  // Default, can be overridden by --port or API_PORT env var
                EnvVars: []string{"API_PORT"},  // Read from environment
            },
        },
        Action: func(c *cli.Context) error {
            port := c.Int("port")
            fmt.Printf("Starting LiveReview API server on port %d...\n", port)
            // ... rest of API startup logic
        },
    }
}

// cmd/ui.go - Environment-aware port configuration  
func UICommand(uiAssets embed.FS) *cli.Command {
    return &cli.Command{
        Name:  "ui",
        Usage: "Start the LiveReview UI server",
        Flags: []cli.Flag{
            &cli.IntFlag{
                Name:    "port",
                Aliases: []string{"p"},
                Usage:   "Port for the UI server",
                Value:   8081,  // Default, can be overridden by --port or UI_PORT env var
                EnvVars: []string{"UI_PORT"},  // Read from environment
            },
            &cli.StringFlag{
                Name:    "api-url",
                Aliases: []string{"a"},
                Usage:   "API URL for the frontend to connect to",
                Value:   "",
                EnvVars: []string{"LIVEREVIEW_API_URL"},  // Read from environment
            },
        },
        Action: func(c *cli.Context) error {
            port := c.Int("port")
            apiURL := c.String("api-url")
            
            // Auto-detection logic if not explicitly set
            if apiURL == "" || apiURL == "auto" {
                apiURL = autoDetectAPIURL(port)
            }
            
            fmt.Printf("Starting LiveReview UI server on port %d...\n", port)
            fmt.Printf("API URL configured as: %s\n", apiURL)
            // ... rest of UI startup logic with window.LIVEREVIEW_CONFIG injection
        },
    }
}
```

#### Step 5: Frontend Runtime Configuration
```typescript
// ui/src/api/apiClient.ts - Enhanced auto-detection
const getBaseUrl = (): string => {
  // 1. Check for runtime injected configuration (highest priority)
  if (window.LIVEREVIEW_CONFIG?.apiUrl) {
    return window.LIVEREVIEW_CONFIG.apiUrl;
  }
  
  // 2. Check for build-time environment variable (fallback)
  if (process.env.REACT_APP_API_URL) {
    return process.env.REACT_APP_API_URL;
  }
  
  // 3. Auto-detection based on current location and deployment patterns
  const currentOrigin = window.location.origin;
  const hostname = window.location.hostname;
  const port = window.location.port;
  
  // Localhost detection - only try localhost API if we're on localhost
  if (hostname === 'localhost' || hostname === '127.0.0.1') {
    // If UI is on custom port, try common API ports
    if (port && port !== '8081') {
      return `http://${hostname}:8888`;  // Default API port
    }
    
    // Standard localhost pattern: UI on 8081, API on 8888
    if (port === '8081') {
      return `http://${hostname}:8888`;
    }
    
    // Fallback to default API port
    return `http://${hostname}:8888`;
  }
  
  // Production/server detection - check for reverse proxy pattern
  // If we're on a domain or IP without port, assume reverse proxy (/api/* routing)
  if (!port || port === '80' || port === '443') {
    return `${currentOrigin}/api`;
  }
  
  // Server mode with custom ports - assume direct backend connection
  // Replace UI port with default API port (8888) or try same host with API port
  const apiPort = '8888';  // Default, should match backend configuration
  return `http://${hostname}:${apiPort}`;
};
```

### Configuration Variables Reference

| Variable | Default | Description | Set By | Used By |
|----------|---------|-------------|---------|---------|
| `API_PORT` | 8888 | Backend API server port | lrops.sh, user input | docker-compose, go backend |
| `UI_PORT` | 8081 | Frontend server port | lrops.sh, user input | docker-compose, go backend |
| `DEPLOYMENT_MODE` | localhost | Deployment mode detection | lrops.sh auto-detect | Backend, webhook config |
| `DOMAIN` | localhost | Domain name for production | lrops.sh, user input | Webhook URLs, CORS, SSL |
| `PUBLIC_IP` | auto | Public IP for server mode | lrops.sh auto-detect | Webhook URLs, API URLs |
| `LIVEREVIEW_API_URL` | auto | Frontendâ†’Backend API URL | lrops.sh, auto-resolved | docker-entrypoint.sh, UI injection |
| `WEBHOOKS_ENABLED` | false/auto | Enable webhook functionality | lrops.sh based on mode | Backend webhook system |
| `PUBLIC_ENDPOINT` | varies | Public URL for git webhooks | lrops.sh, auto-resolved | Backend webhook registration |

### 3. lrops.sh Enhancements

#### Smart Deployment Mode Detection
```bash
# lrops.sh improvements
detect_deployment_mode() {
    local mode="localhost"
    
    # Check if running on cloud/server
    if [[ -n "$PUBLIC_IP" ]] && [[ "$PUBLIC_IP" != "auto" ]] && [[ "$PUBLIC_IP" != "localhost" ]]; then
        mode="server"
    fi
    
    # Check if domain is configured
    if [[ -n "$DOMAIN" ]] && [[ "$DOMAIN" != "localhost" ]]; then
        mode="production"
    fi
    
    echo "$mode"
}

generate_deployment_config() {
    local mode="$1"
    local config_file="$LIVEREVIEW_INSTALL_DIR/.env"
    
    case "$mode" in
        "localhost")
            cat >> "$config_file" << EOF
# Localhost mode - Frontend connects directly to API backend
DEPLOYMENT_MODE=localhost
API_PORT=${API_PORT:-8888}
UI_PORT=${UI_PORT:-8081}
DOMAIN=localhost
LIVEREVIEW_API_URL=auto
WEBHOOKS_ENABLED=false
PUBLIC_ENDPOINT=
EOF
            ;;
        "server")
            local public_ip="${PUBLIC_IP:-$(detect_public_ip)}"
            cat >> "$config_file" << EOF
# Server mode - No reverse proxy, direct port access
DEPLOYMENT_MODE=server
API_PORT=${API_PORT:-8888}
UI_PORT=${UI_PORT:-8081}
PUBLIC_IP=${public_ip}
DOMAIN=${public_ip}
LIVEREVIEW_API_URL=http://${public_ip}:${API_PORT:-8888}
WEBHOOKS_ENABLED=auto
PUBLIC_ENDPOINT=http://${public_ip}:${API_PORT:-8888}
FALLBACK_TO_MANUAL=true
EOF
            ;;
        "production")
            cat >> "$config_file" << EOF
# Production mode - Reverse proxy routes /api/* to backend
DEPLOYMENT_MODE=production
API_PORT=${API_PORT:-8888}
UI_PORT=${UI_PORT:-8081}
DOMAIN=${DOMAIN}
LIVEREVIEW_API_URL=https://${DOMAIN}/api
WEBHOOKS_ENABLED=true
PUBLIC_ENDPOINT=https://${DOMAIN}
SSL_REQUIRED=true
RATE_LIMITING=true
CORS_ORIGINS=https://${DOMAIN}
EOF
            ;;
    esac
}
```

#### Progressive Configuration Prompts
```bash
gather_progressive_configuration() {
    echo "LiveReview can be configured in different modes:"
    echo "1. Localhost Testing (no domain needed, manual triggers only)"
    echo "2. Server Deployment (IP-based access, optional webhooks)"
    echo "3. Production Setup (domain required, full features)"
    echo
    
    local mode
    if [[ "$EXPRESS_MODE" == "true" ]]; then
        mode="localhost"
        log_info "Express mode: Using localhost configuration"
    else
        read -p "Choose deployment mode [1]: " choice
        case "${choice:-1}" in
            1) mode="localhost" ;;
            2) mode="server" ;;
            3) mode="production" ;;
            *) mode="localhost" ;;
        esac
    fi
    
    case "$mode" in
        "localhost")
            configure_localhost_mode
            ;;
        "server")
            configure_server_mode
            ;;
        "production")
            configure_production_mode
            ;;
    esac
}
```

### 4. Git Provider Integration Changes

#### Flexible URL Configuration
```go
// internal/providers/gitlab/config.go
type GitLabConnectorConfig struct {
    URL           string `json:"url"`
    Token         string `json:"token"`
    WebhookURL    string `json:"webhook_url,omitempty"`    // Optional, auto-resolved
    ManualMode    bool   `json:"manual_mode"`              // Fallback to manual triggers
    AutoDetectURL bool   `json:"auto_detect_url"`          // Use system detection
}

func (c *GitLabConnectorConfig) ResolveWebhookURL(systemConfig *config.Config, req *http.Request) string {
    if c.WebhookURL != "" {
        return c.WebhookURL
    }
    
    if !c.AutoDetectURL {
        return ""
    }
    
    // Get the API backend endpoint for webhooks (not the frontend URL)
    apiEndpoint := systemConfig.Webhook.ResolveEndpoint(&systemConfig.Deployment, req)
    if apiEndpoint == "" {
        return ""
    }
    
    // Webhook goes to API backend + specific hook path
    return apiEndpoint + "/gitlab-hook"
}
```

## Migration Path

### Upgrading from Demo to Production

**No rebuild required!** The same binary works for both modes.

**Steps for customers:**

1. **Set up reverse proxy** (nginx/caddy/apache) to route:
   - `/` â†’ `localhost:8081` (frontend)
   - `/api/*` â†’ `localhost:8888` (backend)

2. **Update configuration:**
   ```bash
   # Edit .env file
   echo "REVERSE_PROXY=true" >> .env
   ```

3. **Restart LiveReview:**
   ```bash
   # Using lrops.sh
   lrops.sh restart
   
   # Or using docker-compose
   docker-compose restart
   ```

**What happens during restart:**
- Backend changes binding from `localhost` to `127.0.0.1` (internal only)
- Frontend changes binding from `localhost` to `127.0.0.1` (behind proxy)
- Frontend stops injecting direct API URLs, relies on proxy routing
- Webhooks become available for git provider integration

**Zero downtime option:**
- Run production instance on different ports
- Switch proxy configuration
- Stop demo instance

### Backward Compatibility
- Existing demo installations continue working unchanged
- No configuration migration scripts needed  
- Same Docker images work for both modes

## Benefits

### User Experience
- **Zero-barrier entry**: Works immediately on localhost
- **Progressive complexity**: Users only deal with complexity when they need it
- **Flexible deployment**: Easy to move between different deployment scenarios
- **Clear guidance**: UI indicates current mode and limitations

### Technical Benefits
- **Reduced support burden**: Fewer configuration-related issues
- **Better adoption**: Lower barrier to trying LiveReview
- **Flexible architecture**: Supports various deployment patterns
- **Future-proof**: Easy to add new deployment modes

### Operational Benefits
- **Faster onboarding**: Users can evaluate the product immediately
- **Reduced documentation**: Less complex setup instructions needed
- **Better user satisfaction**: Smooth progression from trial to production

## Implementation Timeline

### Phase 1 (Week 1-2): Foundation
- Deployment mode detection
- System info endpoint
- Basic frontend auto-configuration

### Phase 2 (Week 3-4): Enhanced Configuration
- Dynamic webhook configuration
- Git provider URL flexibility
- lrops.sh improvements

### Phase 3 (Week 5-6): Polish & Migration
- Migration scripts for existing installations
- Enhanced UI indicators
- Documentation updates

This specification addresses the core onboarding friction while maintaining backward compatibility and providing a clear path for users to evolve their deployments as their needs grow.


---

## Git Provider Auto-Configuration Addendum

### Problem Addressed
The original onboarding specification mentioned "Git provider settings require specific URL configuration that's deployment-dependent" as a key friction point. This addendum details the solution.

### Solution: Auto-Derived Webhook URLs

#### Backend Implementation
```go
// Webhook URL auto-derivation in system info endpoint
func (s *Server) getSystemInfo(c echo.Context) error {
    deploymentConfig := getDeploymentConfig()
    
    var webhookURL string
    if deploymentConfig.ReverseProxy {
        // Production: derive from current request
        scheme := "https"
        if c.Scheme() == "http" { scheme = "http" }
        host := c.Request().Host
        webhookURL = fmt.Sprintf("%s://%s/api/v1/gitlab-hook", scheme, host)
    } else {
        // Demo: localhost for display only
        webhookURL = fmt.Sprintf("http://localhost:%d/api/v1/gitlab-hook", deploymentConfig.BackendPort)
    }
    
    return c.JSON(http.StatusOK, SystemInfo{
        WebhookURL: webhookURL,
        WebhooksEnabled: deploymentConfig.ReverseProxy,
    })
}
```

#### Frontend Implementation
```typescript
// Git provider forms auto-populate webhook URL
const GitProviderForm: React.FC = () => {
    const [systemInfo] = useSystemInfo();
    
    return (
        <form>
            <input name="webhookUrl" 
                   value={systemInfo.webhook_url} 
                   readOnly 
                   className="auto-configured" />
            
            {systemInfo.deployment_mode === 'demo' && (
                <Warning>Webhooks disabled in demo mode</Warning>
            )}
        </form>
    );
};
```

### Key Benefits
1. **Zero URL Configuration**: Git providers can be added without pre-configuring URLs
2. **Demo Mode Testing**: Users can add git providers for evaluation without webhook complications  
3. **Production Auto-Registration**: Webhooks automatically registered when in production mode
4. **Deployment Mode Awareness**: UI clearly indicates webhook capabilities based on deployment mode

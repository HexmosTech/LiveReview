{
  "files": [
    {
      "filename": "main.go",
      "status": "modified",
      "additions": 707,
      "deletions": 731,
      "changes": 1438,
      "patch": "@@ -18,6 +18,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n+\t\"sync/atomic\" // For thread-safe error counting\n \t\"time\"\n \n \t\"github.com/go-git/go-billy/v5/memfs\"\n@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to set up API clients\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tgitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n-\tif gitlabToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITLAB_TOKEN\")\n+\tprojects, err := loadProjects(cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to load projects\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tflag.BoolVar(\u0026loop, \"loop\", false, \"continue migrating until canceled\")\n-\tflag.BoolVar(\u0026report, \"report\", false, \"report on primitives to be migrated instead of beginning migration\")\n+\tif cfg.Report {\n+\t\tprintReport(ctx, projects)\n+\t} else {\n+\t\tif err := performMigration(ctx, cfg, projects); err != nil {\n+\t\t\tlogger.Error(\"migration failed\", \"err\", err)\n+\t\t\tos.Exit(1)\n+\t\t} else if errCount.Load() \u003e 0 {\n+\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount.Load()))\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}\n+}\n \n-\tflag.BoolVar(\u0026deleteExistingRepos, \"delete-existing-repos\", false, \"whether existing repositories should be deleted before migrating\")\n-\tflag.BoolVar(\u0026enablePullRequests, \"migrate-pull-requests\", false, \"whether pull requests should be migrated\")\n-\tflag.BoolVar(\u0026renameMasterToMain, \"rename-master-to-main\", false, \"rename master branch to main and update pull requests\")\n+// parseConfig parses command-line flags and environment variables into a Config struct.\n+func parseConfig() (*Config, error) {\n+\tcfg := \u0026Config{}\n \n-\tflag.StringVar(\u0026githubDomain, \"github-domain\", defaultGithubDomain, \"specifies the GitHub domain to use\")\n-\tflag.StringVar(\u0026githubRepo, \"github-repo\", \"\", \"the GitHub repository to migrate to\")\n-\tflag.StringVar(\u0026githubUser, \"github-user\", \"\", \"specifies the GitHub user to use, who will author any migrated PRs (required)\")\n-\tflag.StringVar(\u0026gitlabDomain, \"gitlab-domain\", defaultGitlabDomain, \"specifies the GitLab domain to use\")\n-\tflag.StringVar(\u0026gitlabProject, \"gitlab-project\", \"\", \"the GitLab project to migrate\")\n-\tflag.StringVar(\u0026projectsCsvPath, \"projects-csv\", \"\", \"specifies the path to a CSV file describing projects to migrate (incompatible with -gitlab-project and -github-repo)\")\n+\tflag.BoolVar(\u0026cfg.Loop, \"loop\", false, \"continue migrating until canceled\")\n+\tflag.BoolVar(\u0026cfg.Report, \"report\", false, \"report on primitives to be migrated instead of beginning migration\")\n \n-\tflag.IntVar(\u0026maxConcurrency, \"max-concurrency\", 4, \"how many projects to migrate in parallel\")\n+\tflag.BoolVar(\u0026cfg.DeleteExistingRepos, \"delete-existing-repos\", false, \"whether existing repositories should be deleted before migrating\")\n+\tflag.BoolVar(\u0026cfg.EnablePullRequests, \"migrate-pull-requests\", false, \"whether pull requests should be migrated\")\n+\tflag.BoolVar(\u0026cfg.RenameMasterToMain, \"rename-master-to-main\", false, \"rename master branch to main and update pull requests\")\n+\n+\tflag.StringVar(\u0026cfg.GithubDomain, \"github-domain\", defaultGithubDomain, \"specifies the GitHub domain to use\")\n+\tflag.StringVar(\u0026cfg.GithubRepo, \"github-repo\", \"\", \"the GitHub repository to migrate to\")\n+\tflag.StringVar(\u0026cfg.GithubUser, \"github-user\", \"\", \"specifies the GitHub user to use, who will author any migrated PRs (required)\")\n+\tflag.StringVar(\u0026cfg.GitlabDomain, \"gitlab-domain\", defaultGitlabDomain, \"specifies the GitLab domain to use\")\n+\tflag.StringVar(\u0026cfg.GitlabProject, \"gitlab-project\", \"\", \"the GitLab project to migrate\")\n+\tflag.StringVar(\u0026cfg.ProjectsCsvPath, \"projects-csv\", \"\", \"specifies the path to a CSV file describing projects to migrate (incompatible with -gitlab-project and -github-repo)\")\n+\n+\tflag.IntVar(\u0026cfg.MaxConcurrency, \"max-concurrency\", defaultConcurrency, \"how many projects to migrate in parallel\")\n \n \tflag.Parse()\n \n-\tif githubUser == \"\" {\n-\t\tgithubUser = os.Getenv(\"GITHUB_USER\")\n+\tcfg.GithubToken = os.Getenv(\"GITHUB_TOKEN\")\n+\tif cfg.GithubToken == \"\" {\n+\t\treturn nil, errors.New(\"missing environment variable GITHUB_TOKEN\")\n \t}\n \n-\tif githubUser == \"\" {\n-\t\tlogger.Error(\"must specify GitHub user\")\n-\t\tos.Exit(1)\n+\tcfg.GitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n+\tif cfg.GitlabToken == \"\" {\n+\t\treturn nil, errors.New(\"missing environment variable GITLAB_TOKEN\")\n \t}\n \n-\trepoSpecifiedInline := githubRepo != \"\" \u0026\u0026 gitlabProject != \"\"\n-\tif repoSpecifiedInline \u0026\u0026 projectsCsvPath != \"\" {\n-\t\tlogger.Error(\"cannot specify -projects-csv and either -github-repo or -gitlab-project at the same time\")\n-\t\tos.Exit(1)\n+\tif cfg.GithubUser == \"\" {\n+\t\tcfg.GithubUser = os.Getenv(\"GITHUB_USER\")\n \t}\n-\tif !repoSpecifiedInline \u0026\u0026 projectsCsvPath == \"\" {\n-\t\tlogger.Error(\"must specify either -projects-csv or both of -github-repo and -gitlab-project\")\n-\t\tos.Exit(1)\n+\n+\tif cfg.GithubUser == \"\" {\n+\t\treturn nil, errors.New(\"must specify GitHub user via -github-user or GITHUB_USER environment variable\")\n+\t}\n+\n+\trepoSpecifiedInline := cfg.GithubRepo != \"\" \u0026\u0026 cfg.GitlabProject != \"\"\n+\tif repoSpecifiedInline \u0026\u0026 cfg.ProjectsCsvPath != \"\" {\n+\t\treturn nil, errors.New(\"cannot specify -projects-csv and either -github-repo or -gitlab-project at the same time\")\n \t}\n+\tif !repoSpecifiedInline \u0026\u0026 cfg.ProjectsCsvPath == \"\" {\n+\t\treturn nil, errors.New(\"must specify either -projects-csv or both of -github-repo and -gitlab-project\")\n+\t}\n+\n+\treturn cfg, nil\n+}\n \n+// setupSignalHandler sets up a goroutine to listen for OS interrupt signals.\n+func setupSignalHandler(cancel context.CancelFunc) {\n+\tc := make(chan os.Signal, 1)\n+\tsignal.Notify(c, os.Interrupt)\n+\tgo func() {\n+\t\tselect {\n+\t\tcase \u003c-c:\n+\t\t\tlogger.Info(\"received interrupt signal, shutting down...\")\n+\t\t\tcancel()\n+\t\tcase \u003c-context.Background().Done(): // Fallback if main context finishes\n+\t\t\tsignal.Stop(c)\n+\t\t}\n+\t}()\n+}\n+\n+// setupRetryableHTTPClient configures and returns a retryable HTTP client.\n+func setupRetryableHTTPClient() *retryablehttp.Client {\n \tretryClient := \u0026retryablehttp.Client{\n \t\tHTTPClient:   cleanhttp.DefaultPooledClient(),\n-\t\tLogger:       nil,\n+\t\tLogger:       nil, // retryablehttp's logger is verbose, using hclog's Trace instead\n \t\tRetryMax:     2,\n \t\tRetryWaitMin: 30 * time.Second,\n \t\tRetryWaitMax: 300 * time.Second,\n \t}\n \n \tretryClient.Backoff = func(min, max time.Duration, attemptNum int, resp *http.Response) (sleep time.Duration) {\n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tdefer func() {\n-\t\t\tlogger.Trace(\"waiting before retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode, \"sleep\", sleep, \"attempt\", attemptNum, \"max_attempts\", retryClient.RetryMax)\n+\t\t\tlogger.Trace(\"waiting before retrying failed API request\",\n+\t\t\t\t\"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode,\n+\t\t\t\t\"sleep\", sleep, \"attempt\", attemptNum, \"max_attempts\", retryClient.RetryMax)\n \t\t}()\n \n \t\tif resp != nil {\n \t\t\t// Check the Retry-After header\n-\t\t\tif s, ok := resp.Header[\"Retry-After\"]; ok {\n+\t\t\tif s, ok := resp.Header[\"Retry-After\"]; ok \u0026\u0026 len(s) \u003e 0 {\n \t\t\t\tif retryAfter, err := strconv.ParseInt(s[0], 10, 64); err == nil {\n \t\t\t\t\tsleep = time.Second * time.Duration(retryAfter)\n \t\t\t\t\treturn\n@@ -180,20 +243,18 @@ func main() {\n \t\t\t// Reference:\n \t\t\t// - https://docs.github.com/en/rest/using-the-rest-api/rate-limits-for-the-rest-api?apiVersion=2022-11-28\n \t\t\t// - https://docs.github.com/en/rest/using-the-rest-api/best-practices-for-using-the-rest-api?apiVersion=2022-11-28\n-\t\t\tif v, ok := resp.Header[\"X-Ratelimit-Remaining\"]; ok {\n+\t\t\tif v, ok := resp.Header[\"X-Ratelimit-Remaining\"]; ok \u0026\u0026 len(v) \u003e 0 {\n \t\t\t\tif remaining, err := strconv.ParseInt(v[0], 10, 64); err == nil \u0026\u0026 remaining == 0 {\n-\n \t\t\t\t\t// If x-ratelimit-reset is present, this indicates the UTC timestamp when we can retry\n-\t\t\t\t\tif w, ok := resp.Header[\"X-Ratelimit-Reset\"]; ok {\n+\t\t\t\t\tif w, ok := resp.Header[\"X-Ratelimit-Reset\"]; ok \u0026\u0026 len(w) \u003e 0 {\n \t\t\t\t\t\tif recoveryEpoch, err := strconv.ParseInt(w[0], 10, 64); err == nil {\n-\t\t\t\t\t\t\t// Add 30 seconds to recovery timestamp for clock differences\n-\t\t\t\t\t\t\tsleep = roundDuration(time.Until(time.Unix(recoveryEpoch+30, 0)), time.Second)\n+\t\t\t\t\t\t\t// Add a buffer to recovery timestamp for clock differences\n+\t\t\t\t\t\t\tsleep = roundDuration(time.Until(time.Unix(recoveryEpoch, 0))+githubRateLimitResetBuffer, time.Second)\n \t\t\t\t\t\t\treturn\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\n-\t\t\t\t\t// Otherwise, wait for 60 seconds\n-\t\t\t\t\tsleep = 60 * time.Second\n+\t\t\t\t\t// Otherwise, wait for a fallback duration\n+\t\t\t\t\tsleep = githubRateLimitWaitFallback\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n@@ -205,7 +266,6 @@ func main() {\n \t\tif float64(wait) != mult || wait \u003e max {\n \t\t\twait = max\n \t\t}\n-\n \t\tsleep = wait\n \t\treturn\n \t}\n@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)\n \t}\n \n-\tlogger.Info(\"mirroring repository from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"github_org\", githubPath[0], \"github_repo\", githubPath[1])\n+\tlogger.Info(\"mirroring repository from GitLab to GitHub\",\n+\t\t\"gitlab_group\", gitlabGroupName, \"gitlab_project\", gitlabProjectName,\n+\t\t\"github_owner\", githubOwner, \"github_repo\", githubRepoName)\n \n-\tuser, err := getGithubUser(ctx, githubPath[0])\n+\tuser, err := getGithubUser(ctx, githubOwner)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving github user: %v\", err)\n+\t\treturn fmt.Errorf(\"retrieving GitHub user %q: %w\", githubOwner, err)\n \t}\n \n-\tvar org string\n-\tif strings.EqualFold(*user.Type, \"organization\") {\n-\t\torg = githubPath[0]\n-\t} else if !strings.EqualFold(*user.Type, \"user\") || !strings.EqualFold(*user.Login, githubPath[0]) {\n-\t\treturn fmt.Errorf(\"configured owner is neither an organization nor the current user: %s\", githubPath[0])\n+\tvar githubOrg string\n+\tif strings.EqualFold(*user.Type, \"Organization\") {\n+\t\tgithubOrg = githubOwner\n+\t} else if !strings.EqualFold(*user.Type, \"User\") || !strings.EqualFold(*user.Login, githubOwner) {\n+\t\treturn fmt.Errorf(\"configured GitHub owner %q is neither an organization nor the authenticated user\", githubOwner)\n \t}\n \n-\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t_, _, err = gh.Repositories.Get(ctx, githubPath[0], githubPath[1])\n+\t// Check for existing GitHub repository\n+\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t_, _, err = gh.Repositories.Get(ctx, githubOwner, githubRepoName)\n \n \tvar githubError *github.ErrorResponse\n-\tif err != nil \u0026\u0026 (!errors.As(err, \u0026githubError) || githubError == nil || githubError.Response == nil || githubError.Response.StatusCode != http.StatusNotFound) {\n-\t\treturn fmt.Errorf(\"retrieving github repo: %v\", err)\n-\t}\n-\n-\tvar createRepo, repoDeleted bool\n+\trepoExists := true\n \tif err != nil {\n-\t\tcreateRepo = true\n-\t} else if deleteExistingRepos {\n-\t\tlogger.Warn(\"existing repository was found on GitHub, proceeding to delete\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t\tif _, err = gh.Repositories.Delete(ctx, githubPath[0], githubPath[1]); err != nil {\n-\t\t\treturn fmt.Errorf(\"deleting existing github repo: %v\", err)\n+\t\tif errors.As(err, \u0026githubError) \u0026\u0026 githubError != nil \u0026\u0026 githubError.Response != nil \u0026\u0026 githubError.Response.StatusCode == http.StatusNotFound {\n+\t\t\trepoExists = false\n+\t\t} else {\n+\t\t\treturn fmt.Errorf(\"retrieving GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t\t}\n+\t}\n \n-\t\tcreateRepo = true\n+\tshouldCreateRepo := false\n+\trepoDeleted := false\n+\tif !repoExists {\n+\t\tshouldCreateRepo = true\n+\t} else if cfg.DeleteExistingRepos {\n+\t\tlogger.Warn(\"existing repository found on GitHub, proceeding to delete\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t\tif _, err = gh.Repositories.Delete(ctx, githubOwner, githubRepoName); err != nil {\n+\t\t\treturn fmt.Errorf(\"deleting existing GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n+\t\t}\n+\t\tshouldCreateRepo = true\n \t\trepoDeleted = true\n \t}\n \n \tdefaultBranch := \"main\"\n-\tif !renameMasterToMain \u0026\u0026 project.DefaultBranch != \"\" {\n+\tif !cfg.RenameMasterToMain \u0026\u0026 project.DefaultBranch != \"\" {\n \t\tdefaultBranch = project.DefaultBranch\n \t}\n \n-\thomepage := fmt.Sprintf(\"https://%s/%s/%s\", gitlabDomain, gitlabPath[0], gitlabPath[1])\n+\thomepage := fmt.Sprintf(\"https://%s/%s/%s\", cfg.GitlabDomain, gitlabGroupName, gitlabProjectName)\n \n-\tif createRepo {\n+\tif shouldCreateRepo {\n \t\tif repoDeleted {\n-\t\t\tlogger.Warn(\"recreating GitHub repository\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n+\t\t\tlogger.Warn(\"recreating GitHub repository\", \"owner\", githubOwner, \"repo\", githubRepoName)\n \t\t} else {\n-\t\t\tlogger.Debug(\"repository not found on GitHub, proceeding to create\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n+\t\t\tlogger.Debug(\"repository not found on GitHub, proceeding to create\", \"owner\", githubOwner, \"repo\", githubRepoName)\n \t\t}\n \t\tnewRepo := github.Repository{\n-\t\t\tName:          pointer(githubPath[1]),\n+\t\t\tName:          pointer(githubRepoName),\n \t\t\tDescription:   \u0026project.Description,\n \t\t\tHomepage:      \u0026homepage,\n \t\t\tDefaultBranch: \u0026defaultBranch,\n-\t\t\tPrivate:       pointer(true),\n+\t\t\tPrivate:       pointer(true), // Assuming private by default\n \t\t\tHasIssues:     pointer(true),\n \t\t\tHasProjects:   pointer(true),\n \t\t\tHasWiki:       pointer(true),\n \t\t}\n-\t\tif _, _, err = gh.Repositories.Create(ctx, org, \u0026newRepo); err != nil {\n-\t\t\treturn fmt.Errorf(\"creating github repo: %v\", err)\n+\t\tif _, _, err = gh.Repositories.Create(ctx, githubOrg, \u0026newRepo); err != nil {\n+\t\t\treturn fmt.Errorf(\"creating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t\t}\n \t}\n \n-\tlogger.Debug(\"updating repository settings\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n+\tlogger.Debug(\"updating repository settings\", \"owner\", githubOwner, \"repo\", githubRepoName)\n \tupdateRepo := github.Repository{\n-\t\tName:              pointer(githubPath[1]),\n+\t\tName:              pointer(githubRepoName),\n \t\tDescription:       \u0026project.Description,\n \t\tHomepage:          \u0026homepage,\n \t\tAllowAutoMerge:    pointer(true),\n@@ -562,585 +613,510 @@ func migrateProject(ctx context.Context, proj []string) error {\n \t\tAllowSquashMerge:  pointer(true),\n \t\tAllowUpdateBranch: pointer(true),\n \t}\n-\tif _, _, err = gh.Repositories.Edit(ctx, githubPath[0], githubPath[1], \u0026updateRepo); err != nil {\n-\t\treturn fmt.Errorf(\"updating github repo: %v\", err)\n+\tif _, _, err = gh.Repositories.Edit(ctx, githubOwner, githubRepoName, \u0026updateRepo); err != nil {\n+\t\treturn fmt.Errorf(\"updating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t}\n \n-\tcloneUrl.User = url.UserPassword(\"oauth2\", gitlabToken)\n-\tcloneUrlWithCredentials := cloneUrl.String()\n+\tcloneURL.User = url.UserPassword(\"oauth2\", cfg.GitlabToken)\n+\tcloneURLWithCredentials := cloneURL.String()\n \n \t// In-memory filesystem for worktree operations\n \tfs := memfs.New()\n \n-\tlogger.Debug(\"cloning repository\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", project.HTTPURLToRepo)\n+\tlogger.Debug(\"cloning repository\", \"gitlab_project\", proj.GitlabPath, \"url\", project.HTTPURLToRepo)\n \trepo, err := git.CloneContext(ctx, memory.NewStorage(), fs, \u0026git.CloneOptions{\n-\t\tURL:        cloneUrlWithCredentials,\n-\t\tAuth:       nil,\n+\t\tURL:        cloneURLWithCredentials,\n \t\tRemoteName: \"gitlab\",\n-\t\tMirror:     true,\n+\t\tMirror:     true, // Clone as a mirror to preserve all refs\n \t})\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"cloning gitlab repo: %v\", err)\n+\t\treturn fmt.Errorf(\"cloning GitLab repo %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tif renameMasterToMain {\n-\t\tif masterBranch, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n-\t\t\tlogger.Info(\"renaming master branch to main prior to push\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n+\tif cfg.RenameMasterToMain {\n+\t\tif masterBranchRef, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n+\t\t\tlogger.Info(\"renaming 'master' branch to 'main'\", \"project\", proj.GitlabPath, \"sha\", masterBranchRef.Hash())\n \n-\t\t\tlogger.Debug(\"creating main branch\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n-\t\t\tmainBranch := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranch.Hash())\n-\t\t\tif err = repo.Storer.SetReference(mainBranch); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"creating main branch: %v\", err)\n+\t\t\tmainBranchRef := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranchRef.Hash())\n+\t\t\tif err = repo.Storer.SetReference(mainBranchRef); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"creating 'main' branch: %w\", err)\n \t\t\t}\n-\n-\t\t\tlogger.Debug(\"deleting master branch\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n-\t\t\tif err = repo.Storer.RemoveReference(masterBranch.Name()); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"deleting master branch: %v\", err)\n+\t\t\tif err = repo.Storer.RemoveReference(masterBranchRef.Name()); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"deleting 'master' branch: %w\", err)\n \t\t\t}\n+\t\t} else if !errors.Is(err, plumbing.ErrReferenceNotFound) {\n+\t\t\treturn fmt.Errorf(\"checking for 'master' branch: %w\", err)\n \t\t}\n \t}\n \n-\tgithubUrl := fmt.Sprintf(\"https://%s/%s/%s\", githubDomain, githubPath[0], githubPath[1])\n-\tgithubUrlWithCredentials := fmt.Sprintf(\"https://%s:%s@%s/%s/%s\", githubUser, githubToken, githubDomain, githubPath[0], githubPath[1])\n+\tgithubTargetURL := fmt.Sprintf(\"https://%s/%s/%s\", cfg.GithubDomain, githubOwner, githubRepoName)\n+\t// Embed username and token directly in the URL for authentication\n+\tgithubTargetURLWithCredentials := fmt.Sprintf(\"https://%s:%s@%s/%s/%s\", cfg.GithubUser, cfg.GithubToken, cfg.GithubDomain, githubOwner, githubRepoName)\n \n-\tlogger.Debug(\"adding remote for GitHub repository\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", githubUrl)\n-\tif _, err = repo.CreateRemote(\u0026config.RemoteConfig{\n+\tlogger.Debug(\"adding remote for GitHub repository\", \"github_repo\", proj.GithubRepo, \"url\", githubTargetURL)\n+\t_, err = repo.CreateRemote(\u0026config.RemoteConfig{\n \t\tName:   \"github\",\n-\t\tURLs:   []string{githubUrlWithCredentials},\n-\t\tMirror: true,\n-\t}); err != nil {\n-\t\treturn fmt.Errorf(\"adding github remote: %v\", err)\n+\t\tURLs:   []string{githubTargetURLWithCredentials},\n+\t\tMirror: true, // Push as a mirror\n+\t})\n+\tif err != nil \u0026\u0026 !strings.Contains(err.Error(), \"remote already exists\") { // Handle case where remote might already exist from previous failed attempt\n+\t\treturn fmt.Errorf(\"adding GitHub remote %q: %w\", githubTargetURL, err)\n \t}\n \n-\tlogger.Debug(\"force-pushing to GitHub repository\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", githubUrl)\n+\tlogger.Debug(\"force-pushing to GitHub repository\", \"github_repo\", proj.GithubRepo, \"url\", githubTargetURL)\n \tif err = repo.PushContext(ctx, \u0026git.PushOptions{\n \t\tRemoteName: \"github\",\n \t\tForce:      true,\n-\t\t//Prune:      true, // causes error, attempts to delete main branch\n+\t\t// Prune: true, // Pruning can be dangerous if the target repo has additional branches\n \t}); err != nil {\n-\t\tupToDateError := errors.New(\"already up-to-date\")\n-\t\tif errors.As(err, \u0026upToDateError) {\n-\t\t\tlogger.Debug(\"repository already up-to-date on GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", githubUrl)\n+\t\tif strings.Contains(err.Error(), \"already up-to-date\") {\n+\t\t\tlogger.Debug(\"repository already up-to-date on GitHub\", \"github_repo\", proj.GithubRepo, \"url\", githubTargetURL)\n \t\t} else {\n-\t\t\treturn fmt.Errorf(\"pushing to github repo: %v\", err)\n+\t\t\treturn fmt.Errorf(\"pushing to GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t\t}\n \t}\n \n-\tlogger.Debug(\"setting default repository branch\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"branch_name\", defaultBranch)\n-\tupdateRepo = github.Repository{\n+\tlogger.Debug(\"setting default repository branch\", \"owner\", githubOwner, \"repo\", githubRepoName, \"branch_name\", defaultBranch)\n+\tfinalUpdateRepo := github.Repository{\n \t\tDefaultBranch: \u0026defaultBranch,\n \t}\n-\tif _, _, err = gh.Repositories.Edit(ctx, githubPath[0], githubPath[1], \u0026updateRepo); err != nil {\n-\t\treturn fmt.Errorf(\"setting default branch: %v\", err)\n+\tif _, _, err = gh.Repositories.Edit(ctx, githubOwner, githubRepoName, \u0026finalUpdateRepo); err != nil {\n+\t\treturn fmt.Errorf(\"setting default branch for %s/%s to %q: %w\", githubOwner, githubRepoName, defaultBranch, err)\n \t}\n \n-\tif enablePullRequests {\n-\t\tmigratePullRequests(ctx, githubPath, gitlabPath, project, repo)\n+\tif cfg.EnablePullRequests {\n+\t\tif err := migratePullRequests(ctx, cfg, githubOwner, githubRepoName, gitlabGroupName, gitlabProjectName, project, repo); err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to migrate pull requests for %s: %w\", proj.GitlabPath, err)\n+\t\t}\n \t}\n \n \treturn nil\n }\n \n-func migratePullRequests(ctx context.Context, githubPath, gitlabPath []string, project *gitlab.Project, repo *git.Repository) {\n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n-\t}\n-\n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\tsendErr(fmt.Errorf(\"retrieving gitlab merge requests: %v\", err))\n-\t\t\treturn\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+// migratePullRequests migrates merge requests from GitLab to GitHub.\n+func migratePullRequests(ctx context.Context, cfg *Config, githubOwner, githubRepoName, gitlabGroupName, gitlabProjectName string, project *gitlab.Project, repo *git.Repository) error {\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"retrieving GitLab merge requests for project %s: %w\", project.PathWithNamespace, err)\n \t}\n \n \tvar successCount, failureCount int\n \ttotalCount := len(mergeRequests)\n-\tlogger.Info(\"migrating merge requests from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"count\", totalCount)\n+\tlogger.Info(\"migrating merge requests from GitLab to GitHub\",\n+\t\t\"gitlab_project\", project.PathWithNamespace, \"count\", totalCount)\n+\n+\tprURLPattern := regexp.MustCompile(pullRequestLinkPattern) // Compile once\n+\n \tfor _, mergeRequest := range mergeRequests {\n \t\tif mergeRequest == nil {\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Check for context cancellation\n \t\tif err := ctx.Err(); err != nil {\n-\t\t\tsendErr(fmt.Errorf(\"preparing to list pull requests: %v\", err))\n+\t\t\tlogger.Error(\"context canceled during pull request migration\", \"err\", err)\n \t\t\tbreak\n \t\t}\n \n-\t\tvar cleanUpBranch bool\n-\t\tvar pullRequest *github.PullRequest\n+\t\tlogger.Debug(\"processing GitLab merge request\", \"mr_id\", mergeRequest.IID, \"source_branch\", mergeRequest.SourceBranch, \"target_branch\", mergeRequest.TargetBranch)\n \n-\t\tlogger.Debug(\"searching for any existing pull request\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"merge_request_id\", mergeRequest.IID)\n-\t\t//query := fmt.Sprintf(\"repo:%s/%s is:pr head:%s\", githubPath[0], githubPath[1], mergeRequest.SourceBranch)\n-\t\tquery := fmt.Sprintf(\"repo:%s/%s is:pr\", githubPath[0], githubPath[1])\n+\t\tvar pullRequest *github.PullRequest\n+\t\t// Search for existing GitHub pull requests\n+\t\tquery := fmt.Sprintf(\"repo:%s/%s is:pr\", githubOwner, githubRepoName)\n \t\tsearchResult, err := getGithubSearchResults(ctx, query)\n \t\tif err != nil {\n-\t\t\tsendErr(fmt.Errorf(\"listing pull requests: %v\", err))\n+\t\t\tsendErr(fmt.Errorf(\"listing pull requests on GitHub for %s/%s: %w\", githubOwner, githubRepoName, err))\n+\t\t\tfailureCount++\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Look for an existing GitHub pull request\n-\t\tskip := false\n+\t\t// Look for an existing GitHub pull request linked by MR ID in body\n \t\tfor _, issue := range searchResult.Issues {\n-\t\t\tif issue == nil {\n+\t\t\tif issue == nil || !issue.IsPullRequest() {\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\t// Check for context cancellation\n \t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tsendErr(fmt.Errorf(\"preparing to retrieve pull request: %v\", err))\n+\t\t\t\tsendErr(fmt.Errorf(\"context canceled while checking existing pull requests: %w\", err))\n \t\t\t\tbreak\n \t\t\t}\n \n-\t\t\tif issue.IsPullRequest() {\n-\t\t\t\t// Extract the PR number from the URL\n-\t\t\t\tprUrl, err := url.Parse(*issue.PullRequestLinks.URL)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"parsing pull request url: %v\", err))\n-\t\t\t\t\tskip = true\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif m := regexp.MustCompile(\".+/([0-9]+)$\").FindStringSubmatch(prUrl.Path); len(m) == 2 {\n+\t\t\tif issue.PullRequestLinks != nil \u0026\u0026 issue.PullRequestLinks.URL != nil {\n+\t\t\t\tif m := prURLPattern.FindStringSubmatch(*issue.PullRequestLinks.URL); len(m) == 2 {\n \t\t\t\t\tprNumber, _ := strconv.Atoi(m[1])\n-\t\t\t\t\tpr, err := getGithubPullRequest(ctx, githubPath[0], githubPath[1], prNumber)\n+\t\t\t\t\tpr, err := getGithubPullRequest(ctx, githubOwner, githubRepoName, prNumber)\n \t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tsendErr(fmt.Errorf(\"retrieving pull request: %v\", err))\n-\t\t\t\t\t\tskip = true\n-\t\t\t\t\t\tbreak\n+\t\t\t\t\t\tsendErr(fmt.Errorf(\"retrieving pull request #%d for %s/%s: %w\", prNumber, githubOwner, githubRepoName, err))\n+\t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \n \t\t\t\t\tif strings.Contains(pr.GetBody(), fmt.Sprintf(\"**GitLab MR Number** | %d\", mergeRequest.IID)) ||\n \t\t\t\t\t\tstrings.Contains(pr.GetBody(), fmt.Sprintf(\"**GitLab MR Number** | [%d]\", mergeRequest.IID)) {\n-\t\t\t\t\t\tlogger.Debug(\"found existing pull request\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pr.GetNumber())\n+\t\t\t\t\t\tlogger.Debug(\"found existing pull request for GitLab MR\", \"mr_id\", mergeRequest.IID, \"github_pr\", pr.GetNumber())\n \t\t\t\t\t\tpullRequest = pr\n+\t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif skip {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Proceed to create temporary branches when migrating a merged/closed merge request that doesn't yet have a counterpart PR in GitHub (can't create one without a branch)\n-\t\tif pullRequest == nil \u0026\u0026 !strings.EqualFold(mergeRequest.State, \"opened\") {\n-\t\t\tlogger.Trace(\"searching for existing branch for closed/merged merge request\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID, \"source_branch\", mergeRequest.SourceBranch)\n-\n-\t\t\t// Only create temporary branches if the source branch has been deleted\n-\t\t\tif _, err = repo.Reference(plumbing.ReferenceName(mergeRequest.SourceBranch), false); err != nil {\n-\t\t\t\t// Create a worktree\n-\t\t\t\tworktree, err := repo.Worktree()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"creating worktree: %v\", err))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\t// Generate temporary branch names\n-\t\t\t\tmergeRequest.SourceBranch = fmt.Sprintf(\"migration-source-%d/%s\", mergeRequest.IID, mergeRequest.SourceBranch)\n-\t\t\t\tmergeRequest.TargetBranch = fmt.Sprintf(\"migration-target-%d/%s\", mergeRequest.IID, mergeRequest.TargetBranch)\n \n-\t\t\t\tlogger.Trace(\"retrieving commits for merge request\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID)\n-\t\t\t\tmergeRequestCommits, _, err := gl.MergeRequests.GetMergeRequestCommits(project.ID, mergeRequest.IID, \u0026gitlab.GetMergeRequestCommitsOptions{OrderBy: \"created_at\", Sort: \"asc\"})\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"retrieving merge request commits: %v\", err))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\tif pullRequest != nil {\n+\t\t\tsuccessCount++\n+\t\t\tcontinue // Skip if PR already exists\n+\t\t}\n \n-\t\t\t\t// Some merge requests have no commits, disregard these\n-\t\t\t\tif len(mergeRequestCommits) == 0 {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t// Handle creating temporary branches for merged/closed MRs if their source branches no longer exist\n+\t\tsourceBranch := mergeRequest.SourceBranch\n+\t\ttargetBranch := mergeRequest.TargetBranch\n+\t\tcleanUpBranch := false\n+\n+\t\t// Check if the source branch actually exists in the cloned repository\n+\t\t_, err = repo.Reference(plumbing.NewBranchReferenceName(sourceBranch), false)\n+\t\tif err != nil \u0026\u0026 errors.Is(err, plumbing.ErrReferenceNotFound) {\n+\t\t\tlogger.Trace(\"source branch not found in cloned repo, attempting to create temporary branches for MR\",\n+\t\t\t\t\"mr_id\", mergeRequest.IID, \"original_source\", mergeRequest.SourceBranch, \"original_target\", mergeRequest.TargetBranch)\n+\n+\t\t\t// Generate temporary branch names to avoid conflicts and signify their purpose\n+\t\t\ttempSourceBranch := fmt.Sprintf(\"migration-source-%d-%s\", mergeRequest.IID, strings.ReplaceAll(mergeRequest.SourceBranch, \"/\", \"-\"))\n+\t\t\ttempTargetBranch := fmt.Sprintf(\"migration-target-%d-%s\", mergeRequest.IID, strings.ReplaceAll(mergeRequest.TargetBranch, \"/\", \"-\"))\n+\t\t\tsourceBranch = tempSourceBranch\n+\t\t\ttargetBranch = tempTargetBranch\n+\t\t\tcleanUpBranch = true // Mark for cleanup later\n+\n+\t\t\t// Create a worktree\n+\t\t\tworktree, err := repo.Worktree()\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"creating worktree for temporary branches: %w\", err))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\t// API is buggy, ordering is not respected, so we'll reorder by commit datestamp\n-\t\t\t\tsort.Slice(mergeRequestCommits, func(i, j int) bool {\n-\t\t\t\t\treturn mergeRequestCommits[i].CommittedDate.Before(*mergeRequestCommits[j].CommittedDate)\n-\t\t\t\t})\n+\t\t\t// Get MR commits to find the range\n+\t\t\tmrCommits, err := listGitlabMergeRequestCommits(ctx, gl, project.ID, mergeRequest.IID)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"retrieving commits for GitLab MR %d: %w\", mergeRequest.IID, err))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif len(mrCommits) == 0 {\n+\t\t\t\tlogger.Debug(\"no commits found for merge request, skipping\", \"mr_id\", mergeRequest.IID)\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\tif mergeRequestCommits[0] == nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"start commit for merge request %d is nil\", mergeRequest.IID))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tif mergeRequestCommits[len(mergeRequestCommits)-1] == nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"end commit for merge request %d is nil\", mergeRequest.IID))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\t// Sort commits by committed date to ensure correct order\n+\t\t\tsort.Slice(mrCommits, func(i, j int) bool {\n+\t\t\t\treturn mrCommits[i].CommittedDate.Before(*mrCommits[j].CommittedDate)\n+\t\t\t})\n \n-\t\t\t\tlogger.Trace(\"inspecting start commit\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID, \"sha\", mergeRequestCommits[0].ShortID)\n-\t\t\t\tstartCommit, err := object.GetCommit(repo.Storer, plumbing.NewHash(mergeRequestCommits[0].ID))\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"loading start commit: %v\", err))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\t// Attempt to find a suitable base for the target branch (first parent of the first commit in the MR)\n+\t\t\tfirstCommitID := plumbing.NewHash(mrCommits[0].ID)\n+\t\t\tfirstCommit, err := object.GetCommit(repo.Storer, firstCommitID)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"loading first commit %s for MR %d: %w\", firstCommitID.String(), mergeRequest.IID, err))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\tif startCommit.NumParents() == 0 {\n-\t\t\t\t\t// Orphaned commit, start with an empty branch\n-\t\t\t\t\t// TODO: this isn't working as hoped, try to figure this out. in the meantime, we'll skip MRs from orphaned branches\n-\t\t\t\t\t//if err = repo.Storer.SetReference(plumbing.NewSymbolicReference(\"HEAD\", plumbing.ReferenceName(fmt.Sprintf(\"refs/heads/%s\", mergeRequest.TargetBranch)))); err != nil {\n-\t\t\t\t\t//\treturn fmt.Errorf(\"creating empty branch: %s\", err)\n-\t\t\t\t\t//}\n-\t\t\t\t\tsendErr(fmt.Errorf(\"start commit %s for merge request %d has no parents\", mergeRequestCommits[0].ShortID, mergeRequest.IID))\n-\t\t\t\t\tcontinue\n-\t\t\t\t} else {\n-\t\t\t\t\t// Sometimes we will be starting from a merge commit, so look for a suitable parent commit to branch out from\n-\t\t\t\t\tvar startCommitParent *object.Commit\n-\t\t\t\t\tfor i := 0; i \u003c startCommit.NumParents(); i++ {\n-\t\t\t\t\t\tlogger.Trace(\"inspecting start commit parent\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID, \"sha\", mergeRequestCommits[0].ShortID)\n-\t\t\t\t\t\tstartCommitParent, err = startCommit.Parent(0)\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tsendErr(fmt.Errorf(\"loading parent commit: %s\", err))\n-\t\t\t\t\t\t}\n+\t\t\tvar baseCommitHash plumbing.Hash\n+\t\t\tif firstCommit.NumParents() \u003e 0 {\n+\t\t\t\t// Use the first parent as the base for the target branch.\n+\t\t\t\t// This simulates the branch point of the feature branch.\n+\t\t\t\tbaseCommitHash = firstCommit.ParentHashes[0]\n+\t\t\t} else {\n+\t\t\t\t// If no parents, this is likely an initial commit. For simplicity,\n+\t\t\t\t// if a branch isn't found and it's an orphaned commit, we might skip or\n+\t\t\t\t// need more complex handling to create an \"empty\" base branch.\n+\t\t\t\tsendErr(fmt.Errorf(\"first commit %s for MR %d has no parents, cannot determine base branch\", firstCommitID.String(), mergeRequest.IID))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n+\t\t\t// Checkout and create the temporary target branch\n+\t\t\tlogger.Trace(\"creating temporary target branch\", \"mr_id\", mergeRequest.IID, \"branch\", targetBranch, \"base_commit\", baseCommitHash.String())\n+\t\t\tif err = worktree.Checkout(\u0026git.CheckoutOptions{\n+\t\t\t\tCreate: true,\n+\t\t\t\tForce:  true,\n+\t\t\t\tBranch: plumbing.NewBranchReferenceName(targetBranch),\n+\t\t\t\tHash:   baseCommitHash,\n+\t\t\t}); err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"checking out temporary target branch %s for MR %d: %w\", targetBranch, mergeRequest.IID, err))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\t\tif startCommitParent == nil {\n-\t\t\t\t\t\tsendErr(fmt.Errorf(\"identifying suitable parent of start commit %s for merge request %d\", mergeRequestCommits[0].ShortID, mergeRequest.IID))\n-\t\t\t\t\t\tfailureCount++\n-\t\t\t\t\t}\n+\t\t\t// Checkout and create the temporary source branch at the last commit of the MR\n+\t\t\tlastCommitID := plumbing.NewHash(mrCommits[len(mrCommits)-1].ID)\n+\t\t\tlogger.Trace(\"creating temporary source branch\", \"mr_id\", mergeRequest.IID, \"branch\", sourceBranch, \"head_commit\", lastCommitID.String())\n+\t\t\tif err = worktree.Checkout(\u0026git.CheckoutOptions{\n+\t\t\t\tCreate: true,\n+\t\t\t\tForce:  true,\n+\t\t\t\tBranch: plumbing.NewBranchReferenceName(sourceBranch),\n+\t\t\t\tHash:   lastCommitID,\n+\t\t\t}); err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"checking out temporary source branch %s for MR %d: %w\", sourceBranch, mergeRequest.IID, err))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\t\tlogger.Trace(\"creating target branch for merged/closed merge request\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID, \"branch\", mergeRequest.TargetBranch, \"sha\", startCommitParent.Hash)\n-\t\t\t\t\tif err = worktree.Checkout(\u0026git.CheckoutOptions{\n-\t\t\t\t\t\tCreate: true,\n-\t\t\t\t\t\tForce:  true,\n-\t\t\t\t\t\tBranch: plumbing.NewBranchReferenceName(mergeRequest.TargetBranch),\n-\t\t\t\t\t\tHash:   startCommitParent.Hash,\n-\t\t\t\t\t}); err != nil {\n-\t\t\t\t\t\tsendErr(fmt.Errorf(\"checking out temporary target branch: %v\", err))\n-\t\t\t\t\t\tfailureCount++\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t// Push temporary branches to GitHub so they can be referenced by the PR\n+\t\t\tgithubTargetURLWithCredentials := fmt.Sprintf(\"https://%s:%s@%s/%s/%s\", cfg.GithubUser, cfg.GithubToken, cfg.GithubDomain, githubOwner, githubRepoName)\n+\t\t\tlogger.Debug(\"pushing temporary branches to GitHub\", \"mr_id\", mergeRequest.IID, \"source\", sourceBranch, \"target\", targetBranch)\n+\n+\t\t\t// Add temporary remote for these specific branches\n+\t\t\ttempRemoteName := fmt.Sprintf(\"github-temp-mr-%d\", mergeRequest.IID)\n+\t\t\tif _, err = repo.CreateRemote(\u0026config.RemoteConfig{\n+\t\t\t\tName: tempRemoteName,\n+\t\t\t\tURLs: []string{githubTargetURLWithCredentials},\n+\t\t\t}); err != nil \u0026\u0026 !strings.Contains(err.Error(), \"remote already exists\") {\n+\t\t\t\tsendErr(fmt.Errorf(\"creating temporary remote %s: %w\", tempRemoteName, err))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\tendHash := plumbing.NewHash(mergeRequestCommits[len(mergeRequestCommits)-1].ID)\n-\t\t\t\tlogger.Trace(\"creating source branch for merged/closed merge request\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID, \"branch\", mergeRequest.SourceBranch, \"sha\", endHash)\n-\t\t\t\tif err = worktree.Checkout(\u0026git.CheckoutOptions{\n-\t\t\t\t\tCreate: true,\n-\t\t\t\t\tForce:  true,\n-\t\t\t\t\tBranch: plumbing.NewBranchReferenceName(mergeRequest.SourceBranch),\n-\t\t\t\t\tHash:   endHash,\n-\t\t\t\t}); err != nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"checking out temporary source branch: %v\", err))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n+\t\t\tif err = repo.PushContext(ctx, \u0026git.PushOptions{\n+\t\t\t\tRemoteName: tempRemoteName,\n+\t\t\t\tRefSpecs: []config.RefSpec{\n+\t\t\t\t\tconfig.RefSpec(fmt.Sprintf(\"refs/heads/%s:refs/heads/%s\", sourceBranch, sourceBranch)),\n+\t\t\t\t\tconfig.RefSpec(fmt.Sprintf(\"refs/heads/%s:refs/heads/%s\", targetBranch, targetBranch)),\n+\t\t\t\t},\n+\t\t\t\tForce: true,\n+\t\t\t}); err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"pushing temporary branches for MR %d: %w\", mergeRequest.IID, err))\n+\t\t\t\tfailureCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdefer func(tempSourceBranch, tempTargetBranch string) {\n+\t\t\t\t// Attempt to clean up temporary branches on GitHub after PR creation\n+\t\t\t\tlogger.Debug(\"attempting to delete temporary branches on GitHub\", \"source\", tempSourceBranch, \"target\", tempTargetBranch)\n+\t\t\t\t// Need to delete via GitHub API as `go-git` push doesn't support deleting remotes\n+\t\t\t\tif _, err := gh.Git.DeleteRef(ctx, githubOwner, githubRepoName, \"heads/\"+tempSourceBranch); err != nil {\n+\t\t\t\t\tlogger.Warn(\"failed to delete temporary source branch on GitHub\", \"branch\", tempSourceBranch, \"err\", err)\n \t\t\t\t}\n-\n-\t\t\t\tlogger.Debug(\"pushing branches for merged/closed merge request\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"source_branch\", mergeRequest.SourceBranch, \"target_branch\", mergeRequest.TargetBranch)\n-\t\t\t\tif err = repo.PushContext(ctx, \u0026git.PushOptions{\n-\t\t\t\t\tRemoteName: \"github\",\n-\t\t\t\t\tRefSpecs: []config.RefSpec{\n-\t\t\t\t\t\tconfig.RefSpec(fmt.Sprintf(\"refs/heads/%[1]s:refs/heads/%[1]s\", mergeRequest.SourceBranch)),\n-\t\t\t\t\t\tconfig.RefSpec(fmt.Sprintf(\"refs/heads/%[1]s:refs/heads/%[1]s\", mergeRequest.TargetBranch)),\n-\t\t\t\t\t},\n-\t\t\t\t\tForce: true,\n-\t\t\t\t}); err != nil {\n-\t\t\t\t\tupToDateError := errors.New(\"already up-to-date\")\n-\t\t\t\t\tif errors.As(err, \u0026upToDateError) {\n-\t\t\t\t\t\tlogger.Trace(\"branch already exists and is up-to-date on GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"source_branch\", mergeRequest.SourceBranch, \"target_branch\", mergeRequest.TargetBranch)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsendErr(fmt.Errorf(\"pushing temporary branches to github: %v\", err))\n-\t\t\t\t\t\tfailureCount++\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n+\t\t\t\tif _, err := gh.Git.DeleteRef(ctx, githubOwner, githubRepoName, \"heads/\"+tempTargetBranch); err != nil {\n+\t\t\t\t\tlogger.Warn(\"failed to delete temporary target branch on GitHub\", \"branch\", tempTargetBranch, \"err\", err)\n \t\t\t\t}\n-\n-\t\t\t\t// We will clean up these temporary branches after configuring and closing the pull request\n-\t\t\t\tcleanUpBranch = true\n+\t\t\t}(sourceBranch, targetBranch)\n+\t\t} else if cfg.RenameMasterToMain {\n+\t\t\t// Adjust source/target branches if master was renamed to main\n+\t\t\tif sourceBranch == \"master\" {\n+\t\t\t\tsourceBranch = \"main\"\n+\t\t\t}\n+\t\t\tif targetBranch == \"master\" {\n+\t\t\t\ttargetBranch = \"main\"\n \t\t\t}\n \t\t}\n \n-\t\tif renameMasterToMain \u0026\u0026 mergeRequest.TargetBranch == \"master\" {\n-\t\t\tlogger.Trace(\"changing target branch from master to main\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID)\n-\t\t\tmergeRequest.TargetBranch = \"main\"\n+\t\t// Prepare PR title and body\n+\t\tprTitle := mergeRequest.Title\n+\t\tif prTitle == \"\" {\n+\t\t\tprTitle = fmt.Sprintf(\"Migrated MR %d: %s\", mergeRequest.IID, mergeRequest.SourceBranch)\n \t\t}\n \n-\t\tgithubAuthorName := mergeRequest.Author.Name\n-\n-\t\tauthor, err := getGitlabUser(mergeRequest.Author.Username)\n-\t\tif err != nil {\n-\t\t\tsendErr(fmt.Errorf(\"retrieving gitlab user: %v\", err))\n-\t\t\tfailureCount++\n-\t\t\tcontinue\n-\t\t}\n-\t\tif author.WebsiteURL != \"\" {\n-\t\t\tgithubAuthorName = \"@\" + strings.TrimPrefix(strings.ToLower(author.WebsiteURL), \"https://github.com/\")\n+\t\tprBody := fmt.Sprintf(\"Migrated from GitLab: %s\\n\\n\", mergeRequest.WebURL)\n+\t\tprBody += fmt.Sprintf(\"**GitLab MR Number** | %d\\n\", mergeRequest.IID)\n+\t\tif mergeRequest.Description != \"\" {\n+\t\t\tprBody += \"\\n\" + mergeRequest.Description\n \t\t}\n \n-\t\toriginalState := \"\"\n-\t\tif !strings.EqualFold(mergeRequest.State, \"opened\") {\n-\t\t\toriginalState = fmt.Sprintf(\"\u003e This merge request was originally **%s** on GitLab\", mergeRequest.State)\n+\t\t// Create new GitHub Pull Request\n+\t\tnewPR := github.NewPullRequest{\n+\t\t\tTitle: pointer(prTitle),\n+\t\t\tHead:  pointer(sourceBranch),\n+\t\t\tBase:  pointer(targetBranch),\n+\t\t\tBody:  pointer(prBody),\n \t\t}\n \n-\t\tlogger.Debug(\"determining merge request approvers\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID)\n-\t\tapprovers := make([]string, 0)\n-\t\tawards, _, err := gl.AwardEmoji.ListMergeRequestAwardEmoji(project.ID, mergeRequest.IID, \u0026gitlab.ListAwardEmojiOptions{PerPage: 100})\n-\t\tif err != nil {\n-\t\t\tsendErr(fmt.Errorf(\"listing merge request awards: %v\", err))\n-\t\t} else {\n-\t\t\tfor _, award := range awards {\n-\t\t\t\tif award.Name == \"thumbsup\" {\n-\t\t\t\t\tapprover := award.User.Name\n-\n-\t\t\t\t\tapproverUser, err := getGitlabUser(award.User.Username)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tsendErr(fmt.Errorf(\"retrieving gitlab user: %v\", err))\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\tif approverUser.WebsiteURL != \"\" {\n-\t\t\t\t\t\tapprover = \"@\" + strings.TrimPrefix(strings.ToLower(approverUser.WebsiteURL), \"https://github.com/\")\n-\t\t\t\t\t}\n+\t\tlogger.Info(\"creating new GitHub pull request\",\n+\t\t\t\"owner\", githubOwner, \"repo\", githubRepoName,\n+\t\t\t\"source\", sourceBranch, \"target\", targetBranch,\n+\t\t\t\"mr_id\", mergeRequest.IID)\n \n-\t\t\t\t\tapprovers = append(approvers, approver)\n+\t\tcreatedPR, _, err := gh.PullRequests.Create(ctx, githubOwner, githubRepoName, \u0026newPR)\n+\t\tif err != nil {\n+\t\t\tsendErr(fmt.Errorf(\"creating pull request for GitLab MR %d: %w\", mergeRequest.IID, err))\n+\t\t\tfailureCount++\n+\t\t\tif cleanUpBranch {\n+\t\t\t\t// Ensure temporary branches are cleaned up even on PR creation failure\n+\t\t\t\tlogger.Warn(\"PR creation failed, attempting to clean up temporary branches\", \"mr_id\", mergeRequest.IID)\n+\t\t\t\tif _, deleteErr := gh.Git.DeleteRef(ctx, githubOwner, githubRepoName, \"heads/\"+sourceBranch); deleteErr != nil {\n+\t\t\t\t\tlogger.Warn(\"failed to delete temporary source branch\", \"branch\", sourceBranch, \"err\", deleteErr)\n+\t\t\t\t}\n+\t\t\t\tif _, deleteErr := gh.Git.DeleteRef(ctx, githubOwner, githubRepoName, \"heads/\"+targetBranch); deleteErr != nil {\n+\t\t\t\t\tlogger.Warn(\"failed to delete temporary target branch\", \"branch\", targetBranch, \"err\", deleteErr)\n \t\t\t\t}\n \t\t\t}\n+\t\t\tcontinue\n \t\t}\n \n-\t\tdescription := mergeRequest.Description\n-\t\tif strings.TrimSpace(description) == \"\" {\n-\t\t\tdescription = \"_No description_\"\n-\t\t}\n+\t\tlogger.Info(\"successfully created GitHub pull request\", \"mr_id\", mergeRequest.IID, \"github_pr\", createdPR.GetNumber())\n \n-\t\tslices.Sort(approvers)\n-\t\tapproval := strings.Join(approvers, \", \")\n-\t\tif approval == \"\" {\n-\t\t\tapproval = \"_No approvers_\"\n+\t\t// Close PR if original MR was merged or closed\n+\t\tif strings.EqualFold(mergeRequest.State, \"merged\") || strings.EqualFold(mergeRequest.State, \"closed\") {\n+\t\t\tlogger.Debug(\"closing GitHub pull request as original GitLab MR was %q\", \"github_pr\", createdPR.GetNumber(), \"state\", mergeRequest.State)\n+\t\t\tupdateState := \"closed\"\n+\t\t\tupdatePR := github.PullRequest{\n+\t\t\t\tState: \u0026updateState,\n+\t\t\t}\n+\t\t\t_, _, err := gh.PullRequests.Edit(ctx, githubOwner, githubRepoName, createdPR.GetNumber(), \u0026updatePR)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"closing pull request %d: %w\", createdPR.GetNumber(), err))\n+\t\t\t\t// Don't mark as failure here, as the PR was created\n+\t\t\t}\n \t\t}\n \n-\t\tcloseDate := \"\"\n-\t\tif mergeRequest.State == \"closed\" \u0026\u0026 mergeRequest.ClosedAt != nil {\n-\t\t\tcloseDate = fmt.Sprintf(\"\\n\u003e | **Date Originally Closed** | %s |\", mergeRequest.ClosedAt.Format(dateFormat))\n-\t\t} else if mergeRequest.State == \"merged\" \u0026\u0026 mergeRequest.MergedAt != nil {\n-\t\t\tcloseDate = fmt.Sprintf(\"\\n\u003e | **Date Originally Merged** | %s |\", mergeRequest.MergedAt.Format(dateFormat))\n-\t\t}\n+\t\tsuccessCount++\n+\t}\n \n-\t\tmergeRequestTitle := mergeRequest.Title\n-\t\tif len(mergeRequestTitle) \u003e 40 {\n-\t\t\tmergeRequestTitle = mergeRequestTitle[:40] + \"...\"\n-\t\t}\n+\tlogger.Info(\"pull request migration complete\",\n+\t\t\"gitlab_project\", project.PathWithNamespace,\n+\t\t\"total\", totalCount, \"successful\", successCount, \"failed\", failureCount)\n \n-\t\tbody := fmt.Sprintf(`\u003e [!NOTE]\n-\u003e This pull request was migrated from GitLab\n-\u003e\n-\u003e |      |      |\n-\u003e | ---- | ---- |\n-\u003e | **Original Author** | %[1]s |\n-\u003e | **GitLab Project** | [%[4]s/%[5]s](https://%[10]s/%[4]s/%[5]s) |\n-\u003e | **GitLab Merge Request** | [%[11]s](https://%[10]s/%[4]s/%[5]s/merge_requests/%[2]d) |\n-\u003e | **GitLab MR Number** | [%[2]d](https://%[10]s/%[4]s/%[5]s/merge_requests/%[2]d) |\n-\u003e | **Date Originally Opened** | %[6]s |%[7]s\n-\u003e | **Approved on GitLab by** | %[8]s |\n-\u003e |      |      |\n-\u003e\n-%[9]s\n-\n-## Original Description\n-\n-%[3]s`, githubAuthorName, mergeRequest.IID, description, gitlabPath[0], gitlabPath[1], mergeRequest.CreatedAt.Format(dateFormat), closeDate, approval, originalState, gitlabDomain, mergeRequestTitle)\n-\n-\t\tif pullRequest == nil {\n-\t\t\tlogger.Info(\"creating pull request\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"source_branch\", mergeRequest.SourceBranch, \"target_branch\", mergeRequest.TargetBranch)\n-\t\t\tnewPullRequest := github.NewPullRequest{\n-\t\t\t\tTitle:               \u0026mergeRequest.Title,\n-\t\t\t\tHead:                \u0026mergeRequest.SourceBranch,\n-\t\t\t\tBase:                \u0026mergeRequest.TargetBranch,\n-\t\t\t\tBody:                \u0026body,\n-\t\t\t\tMaintainerCanModify: pointer(true),\n-\t\t\t\tDraft:               \u0026mergeRequest.Draft,\n-\t\t\t}\n-\t\t\tif pullRequest, _, err = gh.PullRequests.Create(ctx, githubPath[0], githubPath[1], \u0026newPullRequest); err != nil {\n-\t\t\t\tsendErr(fmt.Errorf(\"creating pull request: %v\", err))\n-\t\t\t\tfailureCount++\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tif mergeRequest.State == \"closed\" || mergeRequest.State == \"merged\" {\n-\t\t\t\tlogger.Debug(\"closing pull request\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber())\n+\treturn nil\n+}\n \n-\t\t\t\tpullRequest.State = pointer(\"closed\")\n-\t\t\t\tif pullRequest, _, err = gh.PullRequests.Edit(ctx, githubPath[0], githubPath[1], pullRequest.GetNumber(), pullRequest); err != nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"updating pull request: %v\", err))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n+// findGitlabProject is a helper to find a GitLab project by its full path.\n+func findGitlabProject(ctx context.Context, glClient *gitlab.Client, projectPath string) (*gitlab.Project, error) {\n+\tgitlabPathParts := strings.Split(projectPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %q. Expected 'group/project'\", projectPath)\n+\t}\n+\tprojectName := gitlabPathParts[1]\n \n-\t\t} else {\n-\t\t\tvar newState *string\n-\t\t\tswitch mergeRequest.State {\n-\t\t\tcase \"opened\":\n-\t\t\t\tnewState = pointer(\"open\")\n-\t\t\tcase \"closed\", \"merged\":\n-\t\t\t\tnewState = pointer(\"closed\")\n-\t\t\t}\n+\tlogger.Debug(\"searching for GitLab project\", \"path\", projectPath)\n+\t// GitLab API ListProjects doesn't have a direct \"path\" filter, search by name and then filter\n+\topts := \u0026gitlab.ListProjectsOptions{Search: \u0026projectName}\n+\tprojectResults, _, err := glClient.Projects.ListProjects(opts, gitlab.WithContext(ctx))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"listing GitLab projects with search term %q: %w\", projectName, err)\n+\t}\n \n-\t\t\tif (newState != nil \u0026\u0026 (pullRequest.State == nil || *pullRequest.State != *newState)) ||\n-\t\t\t\t(pullRequest.Title == nil || *pullRequest.Title != mergeRequest.Title) ||\n-\t\t\t\t(pullRequest.Body == nil || *pullRequest.Body != body) ||\n-\t\t\t\t(pullRequest.Draft == nil || *pullRequest.Draft != mergeRequest.Draft) {\n-\t\t\t\tlogger.Info(\"updating pull request\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber())\n-\n-\t\t\t\tpullRequest.Title = \u0026mergeRequest.Title\n-\t\t\t\tpullRequest.Body = \u0026body\n-\t\t\t\tpullRequest.Draft = \u0026mergeRequest.Draft\n-\t\t\t\tpullRequest.State = newState\n-\t\t\t\tpullRequest.MaintainerCanModify = nil\n-\t\t\t\tif pullRequest, _, err = gh.PullRequests.Edit(ctx, githubPath[0], githubPath[1], pullRequest.GetNumber(), pullRequest); err != nil {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"updating pull request: %v\", err))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tlogger.Trace(\"existing pull request is up-to-date\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber())\n-\t\t\t}\n+\tfor _, item := range projectResults {\n+\t\tif item == nil {\n+\t\t\tcontinue\n \t\t}\n-\n-\t\tif cleanUpBranch {\n-\t\t\tlogger.Debug(\"deleting temporary branches for closed pull request\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber(), \"source_branch\", mergeRequest.SourceBranch, \"target_branch\", mergeRequest.TargetBranch)\n-\t\t\tif err = repo.PushContext(ctx, \u0026git.PushOptions{\n-\t\t\t\tRemoteName: \"github\",\n-\t\t\t\tRefSpecs: []config.RefSpec{\n-\t\t\t\t\tconfig.RefSpec(fmt.Sprintf(\":refs/heads/%s\", mergeRequest.SourceBranch)),\n-\t\t\t\t\tconfig.RefSpec(fmt.Sprintf(\":refs/heads/%s\", mergeRequest.TargetBranch)),\n-\t\t\t\t},\n-\t\t\t\tForce: true,\n-\t\t\t}); err != nil {\n-\t\t\t\tupToDateError := errors.New(\"already up-to-date\")\n-\t\t\t\tif errors.As(err, \u0026upToDateError) {\n-\t\t\t\t\tlogger.Trace(\"branches already deleted on GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber(), \"source_branch\", mergeRequest.SourceBranch, \"target_branch\", mergeRequest.TargetBranch)\n-\t\t\t\t} else {\n-\t\t\t\t\tsendErr(fmt.Errorf(\"pushing branch deletions to github: %v\", err))\n-\t\t\t\t\tfailureCount++\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif item.PathWithNamespace == projectPath {\n+\t\t\tlogger.Debug(\"found GitLab project\", \"path\", projectPath, \"id\", item.ID)\n+\t\t\treturn item, nil\n \t\t}\n+\t}\n+\treturn nil, fmt.Errorf(\"no matching GitLab project found for path: %q\", projectPath)\n+}\n+\n+// listGitlabMergeRequests is a helper to list all merge requests for a given GitLab project.\n+func listGitlabMergeRequests(ctx context.Context, glClient *gitlab.Client, projectID int) ([]*gitlab.MergeRequest, error) {\n+\tvar allMergeRequests []*gitlab.MergeRequest\n+\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n+\t\tOrderBy: pointer(\"created_at\"),\n+\t\tSort:    pointer(\"asc\"),\n+\t\tListOptions: gitlab.ListOptions{\n+\t\t\tPerPage: 100, // GitLab default per page\n+\t\t},\n+\t}\n \n-\t\tvar comments []*gitlab.Note\n-\t\tskipComments := false\n-\t\topts := \u0026gitlab.ListMergeRequestNotesOptions{\n-\t\t\tOrderBy: pointer(\"created_at\"),\n-\t\t\tSort:    pointer(\"asc\"),\n+\tlogger.Debug(\"retrieving all GitLab merge requests\", \"project_id\", projectID)\n+\tfor {\n+\t\tresult, resp, err := glClient.MergeRequests.ListProjectMergeRequests(projectID, opts, gitlab.WithContext(ctx))\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"retrieving GitLab merge requests for project %d: %w\", projectID, err)\n \t\t}\n \n-\t\tlogger.Debug(\"retrieving GitLab merge request comments\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID, \"merge_request_id\", mergeRequest.IID)\n-\t\tfor {\n-\t\t\tresult, resp, err := gl.Notes.ListMergeRequestNotes(project.ID, mergeRequest.IID, opts)\n-\t\t\tif err != nil {\n-\t\t\t\tsendErr(fmt.Errorf(\"listing merge request notes: %v\", err))\n-\t\t\t\tskipComments = true\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\tallMergeRequests = append(allMergeRequests, result...)\n \n-\t\t\tcomments = append(comments, result...)\n+\t\tif resp.NextPage == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\topts.Page = resp.NextPage\n+\t}\n+\treturn allMergeRequests, nil\n+}\n \n-\t\t\tif resp.NextPage == 0 {\n-\t\t\t\tbreak\n-\t\t\t}\n+// listGitlabMergeRequestCommits is a helper to list all commits for a specific GitLab merge request.\n+func listGitlabMergeRequestCommits(ctx context.Context, glClient *gitlab.Client, projectID, mergeRequestIID int) ([]*gitlab.Commit, error) {\n+\tvar allCommits []*gitlab.Commit\n+\topts := \u0026gitlab.GetMergeRequestCommitsOptions{\n+\t\tOrderBy: \"created_at\",\n+\t\tSort:    \"asc\",\n+\t\tListOptions: gitlab.ListOptions{\n+\t\t\tPerPage: 100,\n+\t\t},\n+\t}\n \n-\t\t\topts.Page = resp.NextPage\n+\tlogger.Trace(\"retrieving commits for GitLab merge request\", \"project_id\", projectID, \"mr_iid\", mergeRequestIID)\n+\tfor {\n+\t\tcommits, resp, err := glClient.MergeRequests.GetMergeRequestCommits(projectID, mergeRequestIID, opts, gitlab.WithContext(ctx))\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"retrieving commits for GitLab merge request %d (project %d): %w\", mergeRequestIID, projectID, err)\n \t\t}\n+\t\tallCommits = append(allCommits, commits...)\n+\t\tif resp.NextPage == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\topts.Page = resp.NextPage\n+\t}\n+\treturn allCommits, nil\n+}\n \n-\t\tif skipComments {\n-\t\t\tfailureCount++\n-\t\t} else {\n-\t\t\tlogger.Debug(\"retrieving GitHub pull request comments\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber())\n-\t\t\tprComments, _, err := gh.Issues.ListComments(ctx, githubPath[0], githubPath[1], pullRequest.GetNumber(), \u0026github.IssueListCommentsOptions{Sort: pointer(\"created\"), Direction: pointer(\"asc\")})\n-\t\t\tif err != nil {\n-\t\t\t\tsendErr(fmt.Errorf(\"listing pull request comments: %v\", err))\n-\t\t\t} else {\n-\t\t\t\tlogger.Info(\"migrating merge request comments from GitLab to GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber(), \"count\", len(comments))\n-\n-\t\t\t\tfor _, comment := range comments {\n-\t\t\t\t\tif comment == nil || comment.System {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n+// getGithubUser fetches GitHub user details for a given login.\n+func getGithubUser(ctx context.Context, login string) (*github.User, error) {\n+\tuser, _, err := gh.Users.Get(ctx, login)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get GitHub user %q: %w\", login, err)\n+\t}\n+\treturn user, nil\n+}\n \n-\t\t\t\t\tgithubCommentAuthorName := comment.Author.Name\n+// getGithubSearchResults performs a GitHub search query.\n+func getGithubSearchResults(ctx context.Context, query string) (*github.SearchResult, error) {\n+\tsearchResult, _, err := gh.Search.Issues(ctx, query, nil)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to perform GitHub search query %q: %w\", query, err)\n+\t}\n+\treturn searchResult, nil\n+}\n \n-\t\t\t\t\tcommentAuthor, err := getGitlabUser(comment.Author.Username)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tsendErr(fmt.Errorf(\"retrieving gitlab user: %v\", err))\n-\t\t\t\t\t\tfailureCount++\n-\t\t\t\t\t\tbreak\n-\t\t\t\t\t}\n-\t\t\t\t\tif commentAuthor.WebsiteURL != \"\" {\n-\t\t\t\t\t\tgithubCommentAuthorName = \"@\" + strings.TrimPrefix(strings.ToLower(commentAuthor.WebsiteURL), \"https://github.com/\")\n-\t\t\t\t\t}\n+// getGithubPullRequest retrieves a specific GitHub pull request.\n+func getGithubPullRequest(ctx context.Context, owner, repo string, prNumber int) (*github.PullRequest, error) {\n+\tpr, _, err := gh.PullRequests.Get(ctx, owner, repo, prNumber)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get GitHub pull request %s/%s #%d: %w\", owner, repo, prNumber, err)\n+\t}\n+\treturn pr, nil\n+}\n \n-\t\t\t\t\tcommentBody := fmt.Sprintf(`\u003e [!NOTE]\n-\u003e This comment was migrated from GitLab\n-\u003e\n-\u003e |      |      |\n-\u003e | ---- | ---- |\n-\u003e | **Original Author** | %[1]s |\n-\u003e | **Note ID** | %[2]d |\n-\u003e | **Date Originally Created** | %[3]s |\n-\u003e |      |      |\n-\u003e\n-\n-## Original Comment\n-\n-%[4]s`, githubCommentAuthorName, comment.ID, comment.CreatedAt.Format(\"Mon, 2 Jan 2006\"), comment.Body)\n-\n-\t\t\t\t\tfoundExistingComment := false\n-\t\t\t\t\tfor _, prComment := range prComments {\n-\t\t\t\t\t\tif prComment == nil {\n-\t\t\t\t\t\t\tcontinue\n-\t\t\t\t\t\t}\n+// roundDuration rounds a duration to the nearest multiple of a step.\n+func roundDuration(d, r time.Duration) time.Duration {\n+\tif r \u003c= 0 {\n+\t\treturn d\n+\t}\n+\treturn d.Round(r)\n+}\n \n-\t\t\t\t\t\tif strings.Contains(prComment.GetBody(), fmt.Sprintf(\"**Note ID** | %d\", comment.ID)) {\n-\t\t\t\t\t\t\tfoundExistingComment = true\n-\n-\t\t\t\t\t\t\tif prComment.Body == nil || *prComment.Body != commentBody {\n-\t\t\t\t\t\t\t\tlogger.Debug(\"updating pull request comment\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber(), \"comment_id\", prComment.GetID())\n-\t\t\t\t\t\t\t\tprComment.Body = \u0026commentBody\n-\t\t\t\t\t\t\t\tif _, _, err = gh.Issues.EditComment(ctx, githubPath[0], githubPath[1], prComment.GetID(), prComment); err != nil {\n-\t\t\t\t\t\t\t\t\tsendErr(fmt.Errorf(\"updating pull request comments: %v\", err))\n-\t\t\t\t\t\t\t\t\tfailureCount++\n-\t\t\t\t\t\t\t\t\tbreak\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlogger.Trace(\"existing pull request comment is up-to-date\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber(), \"comment_id\", prComment.GetID())\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+// pointer is a helper function to return a pointer to any given value.\n+func pointer[T any](v T) *T {\n+\treturn \u0026v\n+}\n \n-\t\t\t\t\tif !foundExistingComment {\n-\t\t\t\t\t\tlogger.Debug(\"creating pull request comment\", \"owner\", githubPath[0], \"repo\", githubPath[1], \"pr_number\", pullRequest.GetNumber())\n-\t\t\t\t\t\tnewComment := github.IssueComment{\n-\t\t\t\t\t\t\tBody: \u0026commentBody,\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif _, _, err = gh.Issues.CreateComment(ctx, githubPath[0], githubPath[1], pullRequest.GetNumber(), \u0026newComment); err != nil {\n-\t\t\t\t\t\t\tsendErr(fmt.Errorf(\"creating pull request comment: %v\", err))\n-\t\t\t\t\t\t\tfailureCount++\n-\t\t\t\t\t\t\tbreak\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+// objectCache (assuming this is from the original file or a separate utility)\n+// This part is kept as-is since its internal implementation wasn't provided for review.\n+type objectCache struct {\n+\tsync.Mutex\n+\tobjects map[plumbing.Hash]interface{}\n+}\n \n-\t\t\tsuccessCount++\n-\t\t}\n+func newObjectCache() *objectCache {\n+\treturn \u0026objectCache{\n+\t\tobjects: make(map[plumbing.Hash]interface{}),\n \t}\n+}\n \n-\tskippedCount := totalCount - successCount - failureCount\n-\n-\tlogger.Info(\"migrated merge requests from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"successful\", successCount, \"failed\", failureCount, \"skipped\", skippedCount)\n+func (c *objectCache) Get(hash plumbing.Hash) (interface{}, bool) {\n+\tc.Lock()\n+\tdefer c.Unlock()\n+\tobj, ok := c.objects[hash]\n+\treturn obj, ok\n }\n+\n+func (c *objectCache) Put(hash plumbing.Hash, obj interface{}) {\n+\tc.Lock()\n+\tdefer c.Unlock()\n+\tc.objects[hash] = obj\n+}\n\\ No newline at end of file",
      "sha": "85e02638eb7396b15030615b7bb1b98a7555149f"
    }
  ],
  "number": "2",
  "owner": "livereviewbot",
  "repo": "glabmig"
}
{
  "items": [
    {
      "id": 2443315406,
      "diff_hunk": "@@ -18,6 +18,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n+\t\"sync/atomic\" // For thread-safe error counting",
      "path": "main.go",
      "position": 4,
      "original_position": 4,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528710,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Consider adding a comment explaining why atomic is necessary (thread-safe error counting).",
      "created_at": "2025-10-19T13:31:59Z",
      "updated_at": "2025-10-19T13:31:59Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315406",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 21,
      "original_line": 21,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315406/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315416,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()",
      "path": "main.go",
      "position": 92,
      "original_position": 92,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528722,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "The `parseConfig` function can return an error. Handle it gracefully.",
      "created_at": "2025-10-19T13:32:01Z",
      "updated_at": "2025-10-19T13:32:01Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315416",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 97,
      "original_line": 97,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315416/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315421,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)",
      "path": "main.go",
      "position": 132,
      "original_position": 132,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528728,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "The `setupAPIClients` function can return an error. Handle it gracefully.",
      "created_at": "2025-10-19T13:32:02Z",
      "updated_at": "2025-10-19T13:32:02Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315421",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 116,
      "original_line": 116,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315421/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315429,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to set up API clients\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tgitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n-\tif gitlabToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITLAB_TOKEN\")\n+\tprojects, err := loadProjects(cfg)",
      "path": "main.go",
      "position": 141,
      "original_position": 141,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528739,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "The `loadProjects` function can return an error. Handle it gracefully.",
      "created_at": "2025-10-19T13:32:04Z",
      "updated_at": "2025-10-19T13:32:04Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315429",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 122,
      "original_line": 122,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315429/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315441,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to set up API clients\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tgitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n-\tif gitlabToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITLAB_TOKEN\")\n+\tprojects, err := loadProjects(cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to load projects\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tflag.BoolVar(\u0026loop, \"loop\", false, \"continue migrating until canceled\")\n-\tflag.BoolVar(\u0026report, \"report\", false, \"report on primitives to be migrated instead of beginning migration\")\n+\tif cfg.Report {\n+\t\tprintReport(ctx, projects)\n+\t} else {\n+\t\tif err := performMigration(ctx, cfg, projects); err != nil {\n+\t\t\tlogger.Error(\"migration failed\", \"err\", err)\n+\t\t\tos.Exit(1)\n+\t\t} else if errCount.Load() \u003e 0 {",
      "path": "main.go",
      "position": 155,
      "original_position": 155,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528745,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Consider returning an error from `performMigration` instead of relying on the global `errCount`. This would make error handling more explicit and easier to test.",
      "created_at": "2025-10-19T13:32:05Z",
      "updated_at": "2025-10-19T13:32:05Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315441",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 134,
      "original_line": 134,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315441/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315446,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to set up API clients\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tgitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n-\tif gitlabToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITLAB_TOKEN\")\n+\tprojects, err := loadProjects(cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to load projects\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tflag.BoolVar(\u0026loop, \"loop\", false, \"continue migrating until canceled\")\n-\tflag.BoolVar(\u0026report, \"report\", false, \"report on primitives to be migrated instead of beginning migration\")\n+\tif cfg.Report {\n+\t\tprintReport(ctx, projects)\n+\t} else {\n+\t\tif err := performMigration(ctx, cfg, projects); err != nil {\n+\t\t\tlogger.Error(\"migration failed\", \"err\", err)\n+\t\t\tos.Exit(1)\n+\t\t} else if errCount.Load() \u003e 0 {\n+\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount.Load()))\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}\n+}\n \n-\tflag.BoolVar(\u0026deleteExistingRepos, \"delete-existing-repos\", false, \"whether existing repositories should be deleted before migrating\")\n-\tflag.BoolVar(\u0026enablePullRequests, \"migrate-pull-requests\", false, \"whether pull requests should be migrated\")\n-\tflag.BoolVar(\u0026renameMasterToMain, \"rename-master-to-main\", false, \"rename master branch to main and update pull requests\")\n+// parseConfig parses command-line flags and environment variables into a Config struct.\n+func parseConfig() (*Config, error) {\n+\tcfg := \u0026Config{}\n \n-\tflag.StringVar(\u0026githubDomain, \"github-domain\", defaultGithubDomain, \"specifies the GitHub domain to use\")\n-\tflag.StringVar(\u0026githubRepo, \"github-repo\", \"\", \"the GitHub repository to migrate to\")\n-\tflag.StringVar(\u0026githubUser, \"github-user\", \"\", \"specifies the GitHub user to use, who will author any migrated PRs (required)\")\n-\tflag.StringVar(\u0026gitlabDomain, \"gitlab-domain\", defaultGitlabDomain, \"specifies the GitLab domain to use\")\n-\tflag.StringVar(\u0026gitlabProject, \"gitlab-project\", \"\", \"the GitLab project to migrate\")\n-\tflag.StringVar(\u0026projectsCsvPath, \"projects-csv\", \"\", \"specifies the path to a CSV file describing projects to migrate (incompatible with -gitlab-project and -github-repo)\")\n+\tflag.BoolVar(\u0026cfg.Loop, \"loop\", false, \"continue migrating until canceled\")\n+\tflag.BoolVar(\u0026cfg.Report, \"report\", false, \"report on primitives to be migrated instead of beginning migration\")\n \n-\tflag.IntVar(\u0026maxConcurrency, \"max-concurrency\", 4, \"how many projects to migrate in parallel\")\n+\tflag.BoolVar(\u0026cfg.DeleteExistingRepos, \"delete-existing-repos\", false, \"whether existing repositories should be deleted before migrating\")\n+\tflag.BoolVar(\u0026cfg.EnablePullRequests, \"migrate-pull-requests\", false, \"whether pull requests should be migrated\")\n+\tflag.BoolVar(\u0026cfg.RenameMasterToMain, \"rename-master-to-main\", false, \"rename master branch to main and update pull requests\")\n+\n+\tflag.StringVar(\u0026cfg.GithubDomain, \"github-domain\", defaultGithubDomain, \"specifies the GitHub domain to use\")\n+\tflag.StringVar(\u0026cfg.GithubRepo, \"github-repo\", \"\", \"the GitHub repository to migrate to\")\n+\tflag.StringVar(\u0026cfg.GithubUser, \"github-user\", \"\", \"specifies the GitHub user to use, who will author any migrated PRs (required)\")\n+\tflag.StringVar(\u0026cfg.GitlabDomain, \"gitlab-domain\", defaultGitlabDomain, \"specifies the GitLab domain to use\")\n+\tflag.StringVar(\u0026cfg.GitlabProject, \"gitlab-project\", \"\", \"the GitLab project to migrate\")\n+\tflag.StringVar(\u0026cfg.ProjectsCsvPath, \"projects-csv\", \"\", \"specifies the path to a CSV file describing projects to migrate (incompatible with -gitlab-project and -github-repo)\")\n+\n+\tflag.IntVar(\u0026cfg.MaxConcurrency, \"max-concurrency\", defaultConcurrency, \"how many projects to migrate in parallel\")\n \n \tflag.Parse()\n \n-\tif githubUser == \"\" {\n-\t\tgithubUser = os.Getenv(\"GITHUB_USER\")\n+\tcfg.GithubToken = os.Getenv(\"GITHUB_TOKEN\")\n+\tif cfg.GithubToken == \"\" {\n+\t\treturn nil, errors.New(\"missing environment variable GITHUB_TOKEN\")\n \t}\n \n-\tif githubUser == \"\" {\n-\t\tlogger.Error(\"must specify GitHub user\")\n-\t\tos.Exit(1)\n+\tcfg.GitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n+\tif cfg.GitlabToken == \"\" {\n+\t\treturn nil, errors.New(\"missing environment variable GITLAB_TOKEN\")\n \t}\n \n-\trepoSpecifiedInline := githubRepo != \"\" \u0026\u0026 gitlabProject != \"\"\n-\tif repoSpecifiedInline \u0026\u0026 projectsCsvPath != \"\" {\n-\t\tlogger.Error(\"cannot specify -projects-csv and either -github-repo or -gitlab-project at the same time\")\n-\t\tos.Exit(1)\n+\tif cfg.GithubUser == \"\" {",
      "path": "main.go",
      "position": 213,
      "original_position": 213,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528753,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Consider using `errors.Is` or `errors.As` for more robust error checking.",
      "created_at": "2025-10-19T13:32:06Z",
      "updated_at": "2025-10-19T13:32:06Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315446",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 173,
      "original_line": 173,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315446/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315452,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to set up API clients\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tgitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n-\tif gitlabToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITLAB_TOKEN\")\n+\tprojects, err := loadProjects(cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to load projects\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tflag.BoolVar(\u0026loop, \"loop\", false, \"continue migrating until canceled\")\n-\tflag.BoolVar(\u0026report, \"report\", false, \"report on primitives to be migrated instead of beginning migration\")\n+\tif cfg.Report {\n+\t\tprintReport(ctx, projects)\n+\t} else {\n+\t\tif err := performMigration(ctx, cfg, projects); err != nil {\n+\t\t\tlogger.Error(\"migration failed\", \"err\", err)\n+\t\t\tos.Exit(1)\n+\t\t} else if errCount.Load() \u003e 0 {\n+\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount.Load()))\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}\n+}\n \n-\tflag.BoolVar(\u0026deleteExistingRepos, \"delete-existing-repos\", false, \"whether existing repositories should be deleted before migrating\")\n-\tflag.BoolVar(\u0026enablePullRequests, \"migrate-pull-requests\", false, \"whether pull requests should be migrated\")\n-\tflag.BoolVar(\u0026renameMasterToMain, \"rename-master-to-main\", false, \"rename master branch to main and update pull requests\")\n+// parseConfig parses command-line flags and environment variables into a Config struct.\n+func parseConfig() (*Config, error) {\n+\tcfg := \u0026Config{}\n \n-\tflag.StringVar(\u0026githubDomain, \"github-domain\", defaultGithubDomain, \"specifies the GitHub domain to use\")\n-\tflag.StringVar(\u0026githubRepo, \"github-repo\", \"\", \"the GitHub repository to migrate to\")\n-\tflag.StringVar(\u0026githubUser, \"github-user\", \"\", \"specifies the GitHub user to use, who will author any migrated PRs (required)\")\n-\tflag.StringVar(\u0026gitlabDomain, \"gitlab-domain\", defaultGitlabDomain, \"specifies the GitLab domain to use\")\n-\tflag.StringVar(\u0026gitlabProject, \"gitlab-project\", \"\", \"the GitLab project to migrate\")\n-\tflag.StringVar(\u0026projectsCsvPath, \"projects-csv\", \"\", \"specifies the path to a CSV file describing projects to migrate (incompatible with -gitlab-project and -github-repo)\")\n+\tflag.BoolVar(\u0026cfg.Loop, \"loop\", false, \"continue migrating until canceled\")\n+\tflag.BoolVar(\u0026cfg.Report, \"report\", false, \"report on primitives to be migrated instead of beginning migration\")\n \n-\tflag.IntVar(\u0026maxConcurrency, \"max-concurrency\", 4, \"how many projects to migrate in parallel\")\n+\tflag.BoolVar(\u0026cfg.DeleteExistingRepos, \"delete-existing-repos\", false, \"whether existing repositories should be deleted before migrating\")\n+\tflag.BoolVar(\u0026cfg.EnablePullRequests, \"migrate-pull-requests\", false, \"whether pull requests should be migrated\")\n+\tflag.BoolVar(\u0026cfg.RenameMasterToMain, \"rename-master-to-main\", false, \"rename master branch to main and update pull requests\")\n+\n+\tflag.StringVar(\u0026cfg.GithubDomain, \"github-domain\", defaultGithubDomain, \"specifies the GitHub domain to use\")\n+\tflag.StringVar(\u0026cfg.GithubRepo, \"github-repo\", \"\", \"the GitHub repository to migrate to\")\n+\tflag.StringVar(\u0026cfg.GithubUser, \"github-user\", \"\", \"specifies the GitHub user to use, who will author any migrated PRs (required)\")\n+\tflag.StringVar(\u0026cfg.GitlabDomain, \"gitlab-domain\", defaultGitlabDomain, \"specifies the GitLab domain to use\")\n+\tflag.StringVar(\u0026cfg.GitlabProject, \"gitlab-project\", \"\", \"the GitLab project to migrate\")\n+\tflag.StringVar(\u0026cfg.ProjectsCsvPath, \"projects-csv\", \"\", \"specifies the path to a CSV file describing projects to migrate (incompatible with -gitlab-project and -github-repo)\")\n+\n+\tflag.IntVar(\u0026cfg.MaxConcurrency, \"max-concurrency\", defaultConcurrency, \"how many projects to migrate in parallel\")\n \n \tflag.Parse()\n \n-\tif githubUser == \"\" {\n-\t\tgithubUser = os.Getenv(\"GITHUB_USER\")\n+\tcfg.GithubToken = os.Getenv(\"GITHUB_TOKEN\")\n+\tif cfg.GithubToken == \"\" {\n+\t\treturn nil, errors.New(\"missing environment variable GITHUB_TOKEN\")\n \t}\n \n-\tif githubUser == \"\" {\n-\t\tlogger.Error(\"must specify GitHub user\")\n-\t\tos.Exit(1)\n+\tcfg.GitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n+\tif cfg.GitlabToken == \"\" {\n+\t\treturn nil, errors.New(\"missing environment variable GITLAB_TOKEN\")\n \t}\n \n-\trepoSpecifiedInline := githubRepo != \"\" \u0026\u0026 gitlabProject != \"\"\n-\tif repoSpecifiedInline \u0026\u0026 projectsCsvPath != \"\" {\n-\t\tlogger.Error(\"cannot specify -projects-csv and either -github-repo or -gitlab-project at the same time\")\n-\t\tos.Exit(1)\n+\tif cfg.GithubUser == \"\" {\n+\t\tcfg.GithubUser = os.Getenv(\"GITHUB_USER\")\n \t}\n-\tif !repoSpecifiedInline \u0026\u0026 projectsCsvPath == \"\" {\n-\t\tlogger.Error(\"must specify either -projects-csv or both of -github-repo and -gitlab-project\")\n-\t\tos.Exit(1)\n+\n+\tif cfg.GithubUser == \"\" {\n+\t\treturn nil, errors.New(\"must specify GitHub user via -github-user or GITHUB_USER environment variable\")\n+\t}\n+\n+\trepoSpecifiedInline := cfg.GithubRepo != \"\" \u0026\u0026 cfg.GitlabProject != \"\"\n+\tif repoSpecifiedInline \u0026\u0026 cfg.ProjectsCsvPath != \"\" {\n+\t\treturn nil, errors.New(\"cannot specify -projects-csv and either -github-repo or -gitlab-project at the same time\")\n \t}\n+\tif !repoSpecifiedInline \u0026\u0026 cfg.ProjectsCsvPath == \"\" {\n+\t\treturn nil, errors.New(\"must specify either -projects-csv or both of -github-repo and -gitlab-project\")\n+\t}\n+\n+\treturn cfg, nil\n+}\n \n+// setupSignalHandler sets up a goroutine to listen for OS interrupt signals.\n+func setupSignalHandler(cancel context.CancelFunc) {\n+\tc := make(chan os.Signal, 1)\n+\tsignal.Notify(c, os.Interrupt)\n+\tgo func() {\n+\t\tselect {\n+\t\tcase \u003c-c:\n+\t\t\tlogger.Info(\"received interrupt signal, shutting down...\")\n+\t\t\tcancel()\n+\t\tcase \u003c-context.Background().Done(): // Fallback if main context finishes\n+\t\t\tsignal.Stop(c)\n+\t\t}\n+\t}()\n+}\n+\n+// setupRetryableHTTPClient configures and returns a retryable HTTP client.\n+func setupRetryableHTTPClient() *retryablehttp.Client {\n \tretryClient := \u0026retryablehttp.Client{\n \t\tHTTPClient:   cleanhttp.DefaultPooledClient(),\n-\t\tLogger:       nil,\n+\t\tLogger:       nil, // retryablehttp's logger is verbose, using hclog's Trace instead\n \t\tRetryMax:     2,\n \t\tRetryWaitMin: 30 * time.Second,\n \t\tRetryWaitMax: 300 * time.Second,\n \t}\n \n \tretryClient.Backoff = func(min, max time.Duration, attemptNum int, resp *http.Response) (sleep time.Duration) {\n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tdefer func() {\n-\t\t\tlogger.Trace(\"waiting before retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode, \"sleep\", sleep, \"attempt\", attemptNum, \"max_attempts\", retryClient.RetryMax)\n+\t\t\tlogger.Trace(\"waiting before retrying failed API request\",\n+\t\t\t\t\"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode,\n+\t\t\t\t\"sleep\", sleep, \"attempt\", attemptNum, \"max_attempts\", retryClient.RetryMax)\n \t\t}()\n \n \t\tif resp != nil {\n \t\t\t// Check the Retry-After header\n-\t\t\tif s, ok := resp.Header[\"Retry-After\"]; ok {\n+\t\t\tif s, ok := resp.Header[\"Retry-After\"]; ok \u0026\u0026 len(s) \u003e 0 {",
      "path": "main.go",
      "position": 284,
      "original_position": 284,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528758,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Check if `len(s) \u003e 0` to prevent potential index out of range errors when accessing `s[0]` if the header value is empty.",
      "created_at": "2025-10-19T13:32:07Z",
      "updated_at": "2025-10-19T13:32:07Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315452",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 236,
      "original_line": 236,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315452/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315459,
      "diff_hunk": "@@ -180,20 +243,18 @@ func main() {\n \t\t\t// Reference:\n \t\t\t// - https://docs.github.com/en/rest/using-the-rest-api/rate-limits-for-the-rest-api?apiVersion=2022-11-28\n \t\t\t// - https://docs.github.com/en/rest/using-the-rest-api/best-practices-for-using-the-rest-api?apiVersion=2022-11-28\n-\t\t\tif v, ok := resp.Header[\"X-Ratelimit-Remaining\"]; ok {\n+\t\t\tif v, ok := resp.Header[\"X-Ratelimit-Remaining\"]; ok \u0026\u0026 len(v) \u003e 0 {",
      "path": "main.go",
      "position": 293,
      "original_position": 293,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528767,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Check if `len(v) \u003e 0` to prevent potential index out of range errors when accessing `v[0]` if the header value is empty.",
      "created_at": "2025-10-19T13:32:09Z",
      "updated_at": "2025-10-19T13:32:09Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315459",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 246,
      "original_line": 246,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315459/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315468,
      "diff_hunk": "@@ -180,20 +243,18 @@ func main() {\n \t\t\t// Reference:\n \t\t\t// - https://docs.github.com/en/rest/using-the-rest-api/rate-limits-for-the-rest-api?apiVersion=2022-11-28\n \t\t\t// - https://docs.github.com/en/rest/using-the-rest-api/best-practices-for-using-the-rest-api?apiVersion=2022-11-28\n-\t\t\tif v, ok := resp.Header[\"X-Ratelimit-Remaining\"]; ok {\n+\t\t\tif v, ok := resp.Header[\"X-Ratelimit-Remaining\"]; ok \u0026\u0026 len(v) \u003e 0 {\n \t\t\t\tif remaining, err := strconv.ParseInt(v[0], 10, 64); err == nil \u0026\u0026 remaining == 0 {\n-\n \t\t\t\t\t// If x-ratelimit-reset is present, this indicates the UTC timestamp when we can retry\n-\t\t\t\t\tif w, ok := resp.Header[\"X-Ratelimit-Reset\"]; ok {\n+\t\t\t\t\tif w, ok := resp.Header[\"X-Ratelimit-Reset\"]; ok \u0026\u0026 len(w) \u003e 0 {",
      "path": "main.go",
      "position": 298,
      "original_position": 298,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528778,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Check if `len(w) \u003e 0` to prevent potential index out of range errors when accessing `w[0]` if the header value is empty.",
      "created_at": "2025-10-19T13:32:10Z",
      "updated_at": "2025-10-19T13:32:10Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315468",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 249,
      "original_line": 249,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315468/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315480,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)",
      "path": "main.go",
      "position": 331,
      "original_position": 331,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528785,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Consider adding a comment explaining why `StatusForbidden` is sometimes used for rate limits. This isn't standard and might confuse others.",
      "created_at": "2025-10-19T13:32:11Z",
      "updated_at": "2025-10-19T13:32:11Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315480",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 285,
      "original_line": 285,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315480/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315486,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)",
      "path": "main.go",
      "position": 356,
      "original_position": 356,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528793,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Use consistent naming for variables (requestURL vs requestMethod).",
      "created_at": "2025-10-19T13:32:12Z",
      "updated_at": "2025-10-19T13:32:12Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315486",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 306,
      "original_line": 306,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315486/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315496,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {",
      "path": "main.go",
      "position": 368,
      "original_position": 368,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528801,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Consider renaming httpClient to ghHttpClient to better reflect its usage",
      "created_at": "2025-10-19T13:32:13Z",
      "updated_at": "2025-10-19T13:32:14Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315496",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 317,
      "original_line": 317,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315496/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315503,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)",
      "path": "main.go",
      "position": 385,
      "original_position": 385,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528808,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:15Z",
      "updated_at": "2025-10-19T13:32:15Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315503",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 328,
      "original_line": 328,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315503/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315508,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)",
      "path": "main.go",
      "position": 403,
      "original_position": 403,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528815,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:16Z",
      "updated_at": "2025-10-19T13:32:16Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315508",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 340,
      "original_line": 340,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315508/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315517,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)",
      "path": "main.go",
      "position": 420,
      "original_position": 420,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528823,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:17Z",
      "updated_at": "2025-10-19T13:32:17Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315517",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 352,
      "original_line": 352,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315517/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315551,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)",
      "path": "main.go",
      "position": 431,
      "original_position": 431,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528832,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:18Z",
      "updated_at": "2025-10-19T13:32:18Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315551",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 360,
      "original_line": 360,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315551/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315556,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)",
      "path": "main.go",
      "position": 448,
      "original_position": 448,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528835,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:19Z",
      "updated_at": "2025-10-19T13:32:20Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315556",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 365,
      "original_line": 365,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315556/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315561,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes",
      "path": "main.go",
      "position": 475,
      "original_position": 475,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528843,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Consider using `sync.Pool` instead of a mutex to protect the `results` slice if performance is critical and the order of results isn't important.  This could reduce contention.",
      "created_at": "2025-10-19T13:32:21Z",
      "updated_at": "2025-10-19T13:32:21Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315561",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 390,
      "original_line": 390,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315561/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315567,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it",
      "path": "main.go",
      "position": 495,
      "original_position": 495,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528853,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Returning nil here after logging an error might mask issues. Consider returning the error up to the errgroup and handling the logging at a higher level.",
      "created_at": "2025-10-19T13:32:22Z",
      "updated_at": "2025-10-19T13:32:22Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315567",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 401,
      "original_line": 401,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315567/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315575,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)",
      "path": "main.go",
      "position": 556,
      "original_position": 556,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528864,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:23Z",
      "updated_at": "2025-10-19T13:32:23Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315575",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 431,
      "original_line": 431,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315575/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315583,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {",
      "path": "main.go",
      "position": 567,
      "original_position": 567,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528871,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:24Z",
      "updated_at": "2025-10-19T13:32:24Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315583",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 437,
      "original_line": 437,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315583/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315595,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {",
      "path": "main.go",
      "position": 586,
      "original_position": 586,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528878,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:26Z",
      "updated_at": "2025-10-19T13:32:26Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315595",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 442,
      "original_line": 442,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315595/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315612,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))",
      "path": "main.go",
      "position": 646,
      "original_position": 646,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528885,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Returning nil here after logging an error might mask issues. Consider returning the error up to the errgroup and handling the logging at a higher level.",
      "created_at": "2025-10-19T13:32:27Z",
      "updated_at": "2025-10-19T13:32:27Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315612",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 470,
      "original_line": 470,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315612/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315620,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {",
      "path": "main.go",
      "position": 667,
      "original_position": 667,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528893,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Consider adding a small jitter to the `time.Sleep` duration to avoid potential synchronization issues across multiple instances of the program.",
      "created_at": "2025-10-19T13:32:28Z",
      "updated_at": "2025-10-19T13:32:28Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315620",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 487,
      "original_line": 487,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315620/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315625,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)",
      "path": "main.go",
      "position": 674,
      "original_position": 674,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528901,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "The sleep duration should be configurable via a flag.",
      "created_at": "2025-10-19T13:32:29Z",
      "updated_at": "2025-10-19T13:32:29Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315625",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 494,
      "original_line": 494,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315625/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315648,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)",
      "path": "main.go",
      "position": 706,
      "original_position": 706,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528914,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:31Z",
      "updated_at": "2025-10-19T13:32:31Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315648",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 511,
      "original_line": 511,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315648/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315664,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)",
      "path": "main.go",
      "position": 733,
      "original_position": 733,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528918,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:32Z",
      "updated_at": "2025-10-19T13:32:32Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315664",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 526,
      "original_line": 526,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315664/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315671,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)",
      "path": "main.go",
      "position": 740,
      "original_position": 740,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528925,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:33Z",
      "updated_at": "2025-10-19T13:32:33Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315671",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 531,
      "original_line": 531,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315671/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315676,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)\n \t}\n \n-\tlogger.Info(\"mirroring repository from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"github_org\", githubPath[0], \"github_repo\", githubPath[1])\n+\tlogger.Info(\"mirroring repository from GitLab to GitHub\",\n+\t\t\"gitlab_group\", gitlabGroupName, \"gitlab_project\", gitlabProjectName,\n+\t\t\"github_owner\", githubOwner, \"github_repo\", githubRepoName)\n \n-\tuser, err := getGithubUser(ctx, githubPath[0])\n+\tuser, err := getGithubUser(ctx, githubOwner)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving github user: %v\", err)\n+\t\treturn fmt.Errorf(\"retrieving GitHub user %q: %w\", githubOwner, err)",
      "path": "main.go",
      "position": 752,
      "original_position": 752,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528935,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:34Z",
      "updated_at": "2025-10-19T13:32:34Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315676",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 540,
      "original_line": 540,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315676/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315681,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)\n \t}\n \n-\tlogger.Info(\"mirroring repository from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"github_org\", githubPath[0], \"github_repo\", githubPath[1])\n+\tlogger.Info(\"mirroring repository from GitLab to GitHub\",\n+\t\t\"gitlab_group\", gitlabGroupName, \"gitlab_project\", gitlabProjectName,\n+\t\t\"github_owner\", githubOwner, \"github_repo\", githubRepoName)\n \n-\tuser, err := getGithubUser(ctx, githubPath[0])\n+\tuser, err := getGithubUser(ctx, githubOwner)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving github user: %v\", err)\n+\t\treturn fmt.Errorf(\"retrieving GitHub user %q: %w\", githubOwner, err)\n \t}\n \n-\tvar org string\n-\tif strings.EqualFold(*user.Type, \"organization\") {\n-\t\torg = githubPath[0]\n-\t} else if !strings.EqualFold(*user.Type, \"user\") || !strings.EqualFold(*user.Login, githubPath[0]) {\n-\t\treturn fmt.Errorf(\"configured owner is neither an organization nor the current user: %s\", githubPath[0])\n+\tvar githubOrg string\n+\tif strings.EqualFold(*user.Type, \"Organization\") {\n+\t\tgithubOrg = githubOwner\n+\t} else if !strings.EqualFold(*user.Type, \"User\") || !strings.EqualFold(*user.Login, githubOwner) {\n+\t\treturn fmt.Errorf(\"configured GitHub owner %q is neither an organization nor the authenticated user\", githubOwner)",
      "path": "main.go",
      "position": 764,
      "original_position": 764,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528947,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:36Z",
      "updated_at": "2025-10-19T13:32:36Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315681",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 547,
      "original_line": 547,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315681/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315688,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)\n \t}\n \n-\tlogger.Info(\"mirroring repository from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"github_org\", githubPath[0], \"github_repo\", githubPath[1])\n+\tlogger.Info(\"mirroring repository from GitLab to GitHub\",\n+\t\t\"gitlab_group\", gitlabGroupName, \"gitlab_project\", gitlabProjectName,\n+\t\t\"github_owner\", githubOwner, \"github_repo\", githubRepoName)\n \n-\tuser, err := getGithubUser(ctx, githubPath[0])\n+\tuser, err := getGithubUser(ctx, githubOwner)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving github user: %v\", err)\n+\t\treturn fmt.Errorf(\"retrieving GitHub user %q: %w\", githubOwner, err)\n \t}\n \n-\tvar org string\n-\tif strings.EqualFold(*user.Type, \"organization\") {\n-\t\torg = githubPath[0]\n-\t} else if !strings.EqualFold(*user.Type, \"user\") || !strings.EqualFold(*user.Login, githubPath[0]) {\n-\t\treturn fmt.Errorf(\"configured owner is neither an organization nor the current user: %s\", githubPath[0])\n+\tvar githubOrg string\n+\tif strings.EqualFold(*user.Type, \"Organization\") {\n+\t\tgithubOrg = githubOwner\n+\t} else if !strings.EqualFold(*user.Type, \"User\") || !strings.EqualFold(*user.Login, githubOwner) {\n+\t\treturn fmt.Errorf(\"configured GitHub owner %q is neither an organization nor the authenticated user\", githubOwner)\n \t}\n \n-\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t_, _, err = gh.Repositories.Get(ctx, githubPath[0], githubPath[1])\n+\t// Check for existing GitHub repository\n+\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t_, _, err = gh.Repositories.Get(ctx, githubOwner, githubRepoName)\n \n \tvar githubError *github.ErrorResponse\n-\tif err != nil \u0026\u0026 (!errors.As(err, \u0026githubError) || githubError == nil || githubError.Response == nil || githubError.Response.StatusCode != http.StatusNotFound) {\n-\t\treturn fmt.Errorf(\"retrieving github repo: %v\", err)\n-\t}\n-\n-\tvar createRepo, repoDeleted bool\n+\trepoExists := true\n \tif err != nil {\n-\t\tcreateRepo = true\n-\t} else if deleteExistingRepos {\n-\t\tlogger.Warn(\"existing repository was found on GitHub, proceeding to delete\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t\tif _, err = gh.Repositories.Delete(ctx, githubPath[0], githubPath[1]); err != nil {\n-\t\t\treturn fmt.Errorf(\"deleting existing github repo: %v\", err)\n+\t\tif errors.As(err, \u0026githubError) \u0026\u0026 githubError != nil \u0026\u0026 githubError.Response != nil \u0026\u0026 githubError.Response.StatusCode == http.StatusNotFound {\n+\t\t\trepoExists = false\n+\t\t} else {\n+\t\t\treturn fmt.Errorf(\"retrieving GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)",
      "path": "main.go",
      "position": 789,
      "original_position": 789,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528956,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:37Z",
      "updated_at": "2025-10-19T13:32:37Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315688",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 560,
      "original_line": 560,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315688/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315695,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)\n \t}\n \n-\tlogger.Info(\"mirroring repository from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"github_org\", githubPath[0], \"github_repo\", githubPath[1])\n+\tlogger.Info(\"mirroring repository from GitLab to GitHub\",\n+\t\t\"gitlab_group\", gitlabGroupName, \"gitlab_project\", gitlabProjectName,\n+\t\t\"github_owner\", githubOwner, \"github_repo\", githubRepoName)\n \n-\tuser, err := getGithubUser(ctx, githubPath[0])\n+\tuser, err := getGithubUser(ctx, githubOwner)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving github user: %v\", err)\n+\t\treturn fmt.Errorf(\"retrieving GitHub user %q: %w\", githubOwner, err)\n \t}\n \n-\tvar org string\n-\tif strings.EqualFold(*user.Type, \"organization\") {\n-\t\torg = githubPath[0]\n-\t} else if !strings.EqualFold(*user.Type, \"user\") || !strings.EqualFold(*user.Login, githubPath[0]) {\n-\t\treturn fmt.Errorf(\"configured owner is neither an organization nor the current user: %s\", githubPath[0])\n+\tvar githubOrg string\n+\tif strings.EqualFold(*user.Type, \"Organization\") {\n+\t\tgithubOrg = githubOwner\n+\t} else if !strings.EqualFold(*user.Type, \"User\") || !strings.EqualFold(*user.Login, githubOwner) {\n+\t\treturn fmt.Errorf(\"configured GitHub owner %q is neither an organization nor the authenticated user\", githubOwner)\n \t}\n \n-\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t_, _, err = gh.Repositories.Get(ctx, githubPath[0], githubPath[1])\n+\t// Check for existing GitHub repository\n+\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t_, _, err = gh.Repositories.Get(ctx, githubOwner, githubRepoName)\n \n \tvar githubError *github.ErrorResponse\n-\tif err != nil \u0026\u0026 (!errors.As(err, \u0026githubError) || githubError == nil || githubError.Response == nil || githubError.Response.StatusCode != http.StatusNotFound) {\n-\t\treturn fmt.Errorf(\"retrieving github repo: %v\", err)\n-\t}\n-\n-\tvar createRepo, repoDeleted bool\n+\trepoExists := true\n \tif err != nil {\n-\t\tcreateRepo = true\n-\t} else if deleteExistingRepos {\n-\t\tlogger.Warn(\"existing repository was found on GitHub, proceeding to delete\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t\tif _, err = gh.Repositories.Delete(ctx, githubPath[0], githubPath[1]); err != nil {\n-\t\t\treturn fmt.Errorf(\"deleting existing github repo: %v\", err)\n+\t\tif errors.As(err, \u0026githubError) \u0026\u0026 githubError != nil \u0026\u0026 githubError.Response != nil \u0026\u0026 githubError.Response.StatusCode == http.StatusNotFound {\n+\t\t\trepoExists = false\n+\t\t} else {\n+\t\t\treturn fmt.Errorf(\"retrieving GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t\t}\n+\t}\n \n-\t\tcreateRepo = true\n+\tshouldCreateRepo := false\n+\trepoDeleted := false\n+\tif !repoExists {\n+\t\tshouldCreateRepo = true\n+\t} else if cfg.DeleteExistingRepos {\n+\t\tlogger.Warn(\"existing repository found on GitHub, proceeding to delete\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t\tif _, err = gh.Repositories.Delete(ctx, githubOwner, githubRepoName); err != nil {\n+\t\t\treturn fmt.Errorf(\"deleting existing GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)",
      "path": "main.go",
      "position": 801,
      "original_position": 801,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528962,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:38Z",
      "updated_at": "2025-10-19T13:32:38Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315695",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 571,
      "original_line": 571,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315695/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315725,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) \u003c 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)\n \t}\n \n-\tlogger.Info(\"mirroring repository from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"github_org\", githubPath[0], \"github_repo\", githubPath[1])\n+\tlogger.Info(\"mirroring repository from GitLab to GitHub\",\n+\t\t\"gitlab_group\", gitlabGroupName, \"gitlab_project\", gitlabProjectName,\n+\t\t\"github_owner\", githubOwner, \"github_repo\", githubRepoName)\n \n-\tuser, err := getGithubUser(ctx, githubPath[0])\n+\tuser, err := getGithubUser(ctx, githubOwner)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving github user: %v\", err)\n+\t\treturn fmt.Errorf(\"retrieving GitHub user %q: %w\", githubOwner, err)\n \t}\n \n-\tvar org string\n-\tif strings.EqualFold(*user.Type, \"organization\") {\n-\t\torg = githubPath[0]\n-\t} else if !strings.EqualFold(*user.Type, \"user\") || !strings.EqualFold(*user.Login, githubPath[0]) {\n-\t\treturn fmt.Errorf(\"configured owner is neither an organization nor the current user: %s\", githubPath[0])\n+\tvar githubOrg string\n+\tif strings.EqualFold(*user.Type, \"Organization\") {\n+\t\tgithubOrg = githubOwner\n+\t} else if !strings.EqualFold(*user.Type, \"User\") || !strings.EqualFold(*user.Login, githubOwner) {\n+\t\treturn fmt.Errorf(\"configured GitHub owner %q is neither an organization nor the authenticated user\", githubOwner)\n \t}\n \n-\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t_, _, err = gh.Repositories.Get(ctx, githubPath[0], githubPath[1])\n+\t// Check for existing GitHub repository\n+\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t_, _, err = gh.Repositories.Get(ctx, githubOwner, githubRepoName)\n \n \tvar githubError *github.ErrorResponse\n-\tif err != nil \u0026\u0026 (!errors.As(err, \u0026githubError) || githubError == nil || githubError.Response == nil || githubError.Response.StatusCode != http.StatusNotFound) {\n-\t\treturn fmt.Errorf(\"retrieving github repo: %v\", err)\n-\t}\n-\n-\tvar createRepo, repoDeleted bool\n+\trepoExists := true\n \tif err != nil {\n-\t\tcreateRepo = true\n-\t} else if deleteExistingRepos {\n-\t\tlogger.Warn(\"existing repository was found on GitHub, proceeding to delete\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t\tif _, err = gh.Repositories.Delete(ctx, githubPath[0], githubPath[1]); err != nil {\n-\t\t\treturn fmt.Errorf(\"deleting existing github repo: %v\", err)\n+\t\tif errors.As(err, \u0026githubError) \u0026\u0026 githubError != nil \u0026\u0026 githubError.Response != nil \u0026\u0026 githubError.Response.StatusCode == http.StatusNotFound {\n+\t\t\trepoExists = false\n+\t\t} else {\n+\t\t\treturn fmt.Errorf(\"retrieving GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t\t}\n+\t}\n \n-\t\tcreateRepo = true\n+\tshouldCreateRepo := false\n+\trepoDeleted := false\n+\tif !repoExists {\n+\t\tshouldCreateRepo = true\n+\t} else if cfg.DeleteExistingRepos {\n+\t\tlogger.Warn(\"existing repository found on GitHub, proceeding to delete\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t\tif _, err = gh.Repositories.Delete(ctx, githubOwner, githubRepoName); err != nil {\n+\t\t\treturn fmt.Errorf(\"deleting existing GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n+\t\t}\n+\t\tshouldCreateRepo = true\n \t\trepoDeleted = true\n \t}\n \n \tdefaultBranch := \"main\"\n-\tif !renameMasterToMain \u0026\u0026 project.DefaultBranch != \"\" {\n+\tif !cfg.RenameMasterToMain \u0026\u0026 project.DefaultBranch != \"\" {\n \t\tdefaultBranch = project.DefaultBranch\n \t}\n \n-\thomepage := fmt.Sprintf(\"https://%s/%s/%s\", gitlabDomain, gitlabPath[0], gitlabPath[1])\n+\thomepage := fmt.Sprintf(\"https://%s/%s/%s\", cfg.GitlabDomain, gitlabGroupName, gitlabProjectName)\n \n-\tif createRepo {\n+\tif shouldCreateRepo {\n \t\tif repoDeleted {\n-\t\t\tlogger.Warn(\"recreating GitHub repository\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n+\t\t\tlogger.Warn(\"recreating GitHub repository\", \"owner\", githubOwner, \"repo\", githubRepoName)\n \t\t} else {\n-\t\t\tlogger.Debug(\"repository not found on GitHub, proceeding to create\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n+\t\t\tlogger.Debug(\"repository not found on GitHub, proceeding to create\", \"owner\", githubOwner, \"repo\", githubRepoName)\n \t\t}\n \t\tnewRepo := github.Repository{\n-\t\t\tName:          pointer(githubPath[1]),\n+\t\t\tName:          pointer(githubRepoName),\n \t\t\tDescription:   \u0026project.Description,\n \t\t\tHomepage:      \u0026homepage,\n \t\t\tDefaultBranch: \u0026defaultBranch,\n-\t\t\tPrivate:       pointer(true),\n+\t\t\tPrivate:       pointer(true), // Assuming private by default\n \t\t\tHasIssues:     pointer(true),\n \t\t\tHasProjects:   pointer(true),\n \t\t\tHasWiki:       pointer(true),\n \t\t}\n-\t\tif _, _, err = gh.Repositories.Create(ctx, org, \u0026newRepo); err != nil {\n-\t\t\treturn fmt.Errorf(\"creating github repo: %v\", err)\n+\t\tif _, _, err = gh.Repositories.Create(ctx, githubOrg, \u0026newRepo); err != nil {\n+\t\t\treturn fmt.Errorf(\"creating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)",
      "path": "main.go",
      "position": 840,
      "original_position": 840,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528972,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Return the error directly instead of wrapping it in fmt.Errorf.  The caller can add context if needed.",
      "created_at": "2025-10-19T13:32:39Z",
      "updated_at": "2025-10-19T13:32:39Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315725",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 601,
      "original_line": 601,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315725/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315733,
      "diff_hunk": "@@ -562,585 +613,510 @@ func migrateProject(ctx context.Context, proj []string) error {\n \t\tAllowSquashMerge:  pointer(true),\n \t\tAllowUpdateBranch: pointer(true),\n \t}\n-\tif _, _, err = gh.Repositories.Edit(ctx, githubPath[0], githubPath[1], \u0026updateRepo); err != nil {\n-\t\treturn fmt.Errorf(\"updating github repo: %v\", err)\n+\tif _, _, err = gh.Repositories.Edit(ctx, githubOwner, githubRepoName, \u0026updateRepo); err != nil {\n+\t\treturn fmt.Errorf(\"updating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)",
      "path": "main.go",
      "position": 859,
      "original_position": 859,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528982,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Use `%w` for wrapping errors to preserve the original error's context.",
      "created_at": "2025-10-19T13:32:41Z",
      "updated_at": "2025-10-19T13:32:41Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315733",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 617,
      "original_line": 617,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315733/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315746,
      "diff_hunk": "@@ -562,585 +613,510 @@ func migrateProject(ctx context.Context, proj []string) error {\n \t\tAllowSquashMerge:  pointer(true),\n \t\tAllowUpdateBranch: pointer(true),\n \t}\n-\tif _, _, err = gh.Repositories.Edit(ctx, githubPath[0], githubPath[1], \u0026updateRepo); err != nil {\n-\t\treturn fmt.Errorf(\"updating github repo: %v\", err)\n+\tif _, _, err = gh.Repositories.Edit(ctx, githubOwner, githubRepoName, \u0026updateRepo); err != nil {\n+\t\treturn fmt.Errorf(\"updating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t}\n \n-\tcloneUrl.User = url.UserPassword(\"oauth2\", gitlabToken)\n-\tcloneUrlWithCredentials := cloneUrl.String()\n+\tcloneURL.User = url.UserPassword(\"oauth2\", cfg.GitlabToken)\n+\tcloneURLWithCredentials := cloneURL.String()\n \n \t// In-memory filesystem for worktree operations\n \tfs := memfs.New()\n \n-\tlogger.Debug(\"cloning repository\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", project.HTTPURLToRepo)\n+\tlogger.Debug(\"cloning repository\", \"gitlab_project\", proj.GitlabPath, \"url\", project.HTTPURLToRepo)\n \trepo, err := git.CloneContext(ctx, memory.NewStorage(), fs, \u0026git.CloneOptions{\n-\t\tURL:        cloneUrlWithCredentials,\n-\t\tAuth:       nil,\n+\t\tURL:        cloneURLWithCredentials,\n \t\tRemoteName: \"gitlab\",\n-\t\tMirror:     true,\n+\t\tMirror:     true, // Clone as a mirror to preserve all refs\n \t})\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"cloning gitlab repo: %v\", err)\n+\t\treturn fmt.Errorf(\"cloning GitLab repo %s: %w\", proj.GitlabPath, err)",
      "path": "main.go",
      "position": 882,
      "original_position": 882,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354528995,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Use `%w` for wrapping errors to preserve the original error's context.",
      "created_at": "2025-10-19T13:32:42Z",
      "updated_at": "2025-10-19T13:32:42Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315746",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 633,
      "original_line": 633,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315746/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315756,
      "diff_hunk": "@@ -562,585 +613,510 @@ func migrateProject(ctx context.Context, proj []string) error {\n \t\tAllowSquashMerge:  pointer(true),\n \t\tAllowUpdateBranch: pointer(true),\n \t}\n-\tif _, _, err = gh.Repositories.Edit(ctx, githubPath[0], githubPath[1], \u0026updateRepo); err != nil {\n-\t\treturn fmt.Errorf(\"updating github repo: %v\", err)\n+\tif _, _, err = gh.Repositories.Edit(ctx, githubOwner, githubRepoName, \u0026updateRepo); err != nil {\n+\t\treturn fmt.Errorf(\"updating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t}\n \n-\tcloneUrl.User = url.UserPassword(\"oauth2\", gitlabToken)\n-\tcloneUrlWithCredentials := cloneUrl.String()\n+\tcloneURL.User = url.UserPassword(\"oauth2\", cfg.GitlabToken)\n+\tcloneURLWithCredentials := cloneURL.String()\n \n \t// In-memory filesystem for worktree operations\n \tfs := memfs.New()\n \n-\tlogger.Debug(\"cloning repository\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", project.HTTPURLToRepo)\n+\tlogger.Debug(\"cloning repository\", \"gitlab_project\", proj.GitlabPath, \"url\", project.HTTPURLToRepo)\n \trepo, err := git.CloneContext(ctx, memory.NewStorage(), fs, \u0026git.CloneOptions{\n-\t\tURL:        cloneUrlWithCredentials,\n-\t\tAuth:       nil,\n+\t\tURL:        cloneURLWithCredentials,\n \t\tRemoteName: \"gitlab\",\n-\t\tMirror:     true,\n+\t\tMirror:     true, // Clone as a mirror to preserve all refs\n \t})\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"cloning gitlab repo: %v\", err)\n+\t\treturn fmt.Errorf(\"cloning GitLab repo %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tif renameMasterToMain {\n-\t\tif masterBranch, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n-\t\t\tlogger.Info(\"renaming master branch to main prior to push\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n+\tif cfg.RenameMasterToMain {\n+\t\tif masterBranchRef, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n+\t\t\tlogger.Info(\"renaming 'master' branch to 'main'\", \"project\", proj.GitlabPath, \"sha\", masterBranchRef.Hash())\n \n-\t\t\tlogger.Debug(\"creating main branch\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n-\t\t\tmainBranch := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranch.Hash())\n-\t\t\tif err = repo.Storer.SetReference(mainBranch); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"creating main branch: %v\", err)\n+\t\t\tmainBranchRef := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranchRef.Hash())\n+\t\t\tif err = repo.Storer.SetReference(mainBranchRef); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"creating 'main' branch: %w\", err)",
      "path": "main.go",
      "position": 898,
      "original_position": 898,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354529009,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Use `%w` for wrapping errors to preserve the original error's context.",
      "created_at": "2025-10-19T13:32:43Z",
      "updated_at": "2025-10-19T13:32:43Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315756",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 642,
      "original_line": 642,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315756/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315787,
      "diff_hunk": "@@ -562,585 +613,510 @@ func migrateProject(ctx context.Context, proj []string) error {\n \t\tAllowSquashMerge:  pointer(true),\n \t\tAllowUpdateBranch: pointer(true),\n \t}\n-\tif _, _, err = gh.Repositories.Edit(ctx, githubPath[0], githubPath[1], \u0026updateRepo); err != nil {\n-\t\treturn fmt.Errorf(\"updating github repo: %v\", err)\n+\tif _, _, err = gh.Repositories.Edit(ctx, githubOwner, githubRepoName, \u0026updateRepo); err != nil {\n+\t\treturn fmt.Errorf(\"updating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t}\n \n-\tcloneUrl.User = url.UserPassword(\"oauth2\", gitlabToken)\n-\tcloneUrlWithCredentials := cloneUrl.String()\n+\tcloneURL.User = url.UserPassword(\"oauth2\", cfg.GitlabToken)\n+\tcloneURLWithCredentials := cloneURL.String()\n \n \t// In-memory filesystem for worktree operations\n \tfs := memfs.New()\n \n-\tlogger.Debug(\"cloning repository\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", project.HTTPURLToRepo)\n+\tlogger.Debug(\"cloning repository\", \"gitlab_project\", proj.GitlabPath, \"url\", project.HTTPURLToRepo)\n \trepo, err := git.CloneContext(ctx, memory.NewStorage(), fs, \u0026git.CloneOptions{\n-\t\tURL:        cloneUrlWithCredentials,\n-\t\tAuth:       nil,\n+\t\tURL:        cloneURLWithCredentials,\n \t\tRemoteName: \"gitlab\",\n-\t\tMirror:     true,\n+\t\tMirror:     true, // Clone as a mirror to preserve all refs\n \t})\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"cloning gitlab repo: %v\", err)\n+\t\treturn fmt.Errorf(\"cloning GitLab repo %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tif renameMasterToMain {\n-\t\tif masterBranch, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n-\t\t\tlogger.Info(\"renaming master branch to main prior to push\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n+\tif cfg.RenameMasterToMain {\n+\t\tif masterBranchRef, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n+\t\t\tlogger.Info(\"renaming 'master' branch to 'main'\", \"project\", proj.GitlabPath, \"sha\", masterBranchRef.Hash())\n \n-\t\t\tlogger.Debug(\"creating main branch\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n-\t\t\tmainBranch := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranch.Hash())\n-\t\t\tif err = repo.Storer.SetReference(mainBranch); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"creating main branch: %v\", err)\n+\t\t\tmainBranchRef := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranchRef.Hash())\n+\t\t\tif err = repo.Storer.SetReference(mainBranchRef); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"creating 'main' branch: %w\", err)\n \t\t\t}\n-\n-\t\t\tlogger.Debug(\"deleting master branch\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n-\t\t\tif err = repo.Storer.RemoveReference(masterBranch.Name()); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"deleting master branch: %v\", err)\n+\t\t\tif err = repo.Storer.RemoveReference(masterBranchRef.Name()); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"deleting 'master' branch: %w\", err)",
      "path": "main.go",
      "position": 905,
      "original_position": 905,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354529029,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Use `%w` for wrapping errors to preserve the original error's context.",
      "created_at": "2025-10-19T13:32:45Z",
      "updated_at": "2025-10-19T13:32:45Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315787",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 645,
      "original_line": 645,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315787/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443315794,
      "diff_hunk": "@@ -562,585 +613,510 @@ func migrateProject(ctx context.Context, proj []string) error {\n \t\tAllowSquashMerge:  pointer(true),\n \t\tAllowUpdateBranch: pointer(true),\n \t}\n-\tif _, _, err = gh.Repositories.Edit(ctx, githubPath[0], githubPath[1], \u0026updateRepo); err != nil {\n-\t\treturn fmt.Errorf(\"updating github repo: %v\", err)\n+\tif _, _, err = gh.Repositories.Edit(ctx, githubOwner, githubRepoName, \u0026updateRepo); err != nil {\n+\t\treturn fmt.Errorf(\"updating GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t}\n \n-\tcloneUrl.User = url.UserPassword(\"oauth2\", gitlabToken)\n-\tcloneUrlWithCredentials := cloneUrl.String()\n+\tcloneURL.User = url.UserPassword(\"oauth2\", cfg.GitlabToken)\n+\tcloneURLWithCredentials := cloneURL.String()\n \n \t// In-memory filesystem for worktree operations\n \tfs := memfs.New()\n \n-\tlogger.Debug(\"cloning repository\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"url\", project.HTTPURLToRepo)\n+\tlogger.Debug(\"cloning repository\", \"gitlab_project\", proj.GitlabPath, \"url\", project.HTTPURLToRepo)\n \trepo, err := git.CloneContext(ctx, memory.NewStorage(), fs, \u0026git.CloneOptions{\n-\t\tURL:        cloneUrlWithCredentials,\n-\t\tAuth:       nil,\n+\t\tURL:        cloneURLWithCredentials,\n \t\tRemoteName: \"gitlab\",\n-\t\tMirror:     true,\n+\t\tMirror:     true, // Clone as a mirror to preserve all refs\n \t})\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"cloning gitlab repo: %v\", err)\n+\t\treturn fmt.Errorf(\"cloning GitLab repo %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tif renameMasterToMain {\n-\t\tif masterBranch, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n-\t\t\tlogger.Info(\"renaming master branch to main prior to push\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n+\tif cfg.RenameMasterToMain {\n+\t\tif masterBranchRef, err := repo.Reference(plumbing.NewBranchReferenceName(\"master\"), false); err == nil {\n+\t\t\tlogger.Info(\"renaming 'master' branch to 'main'\", \"project\", proj.GitlabPath, \"sha\", masterBranchRef.Hash())\n \n-\t\t\tlogger.Debug(\"creating main branch\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n-\t\t\tmainBranch := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranch.Hash())\n-\t\t\tif err = repo.Storer.SetReference(mainBranch); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"creating main branch: %v\", err)\n+\t\t\tmainBranchRef := plumbing.NewHashReference(plumbing.NewBranchReferenceName(\"main\"), masterBranchRef.Hash())\n+\t\t\tif err = repo.Storer.SetReference(mainBranchRef); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"creating 'main' branch: %w\", err)\n \t\t\t}\n-\n-\t\t\tlogger.Debug(\"deleting master branch\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"sha\", masterBranch.Hash())\n-\t\t\tif err = repo.Storer.RemoveReference(masterBranch.Name()); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"deleting master branch: %v\", err)\n+\t\t\tif err = repo.Storer.RemoveReference(masterBranchRef.Name()); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"deleting 'master' branch: %w\", err)\n \t\t\t}\n+\t\t} else if !errors.Is(err, plumbing.ErrReferenceNotFound) {\n+\t\t\treturn fmt.Errorf(\"checking for 'master' branch: %w\", err)",
      "path": "main.go",
      "position": 908,
      "original_position": 908,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": null,
      "pull_request_review_id": 3354529033,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Use `%w` for wrapping errors to preserve the original error's context.",
      "created_at": "2025-10-19T13:32:47Z",
      "updated_at": "2025-10-19T13:32:47Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443315794",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 648,
      "original_line": 648,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443315794/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443331006,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to set up API clients\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tgitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n-\tif gitlabToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITLAB_TOKEN\")\n+\tprojects, err := loadProjects(cfg)",
      "path": "main.go",
      "position": 141,
      "original_position": 141,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": 2443315429,
      "pull_request_review_id": 3354542650,
      "user": {
        "id": 796107,
        "login": "shrsv",
        "name": "",
        "html_url": "https://github.com/shrsv",
        "avatar_url": "https://avatars.githubusercontent.com/u/796107?v=4",
        "type": "User"
      },
      "body": "Why do you say so?",
      "created_at": "2025-10-19T14:09:06Z",
      "updated_at": "2025-10-19T14:09:06Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443331006",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "COLLABORATOR",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 122,
      "original_line": 122,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443331006/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2443331053,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()\n+\tif err != nil {\n+\t\tlogger.Error(\"configuration error\", \"err\", err)\n+\t\tos.Exit(1)\n+\t}\n \n \t// Bypass pre-emptive rate limit checks in the GitHub client, as we will handle these via go-retryablehttp\n \tvalueCtx := context.WithValue(context.Background(), github.BypassRateLimitCheck, true)\n \n \t// Assign a Done channel so we can abort on Ctrl-c\n \tctx, cancel := context.WithCancel(valueCtx)\n+\tdefer cancel() // Ensure cancel is called on exit\n \n-\tc := make(chan os.Signal, 1)\n-\tsignal.Notify(c, os.Interrupt)\n-\tdefer func() {\n-\t\tsignal.Stop(c)\n-\t\tcancel()\n-\t}()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase \u003c-c:\n-\t\t\tcancel()\n-\t\tcase \u003c-ctx.Done():\n-\t\t}\n-\t}()\n-\n-\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n-\t\tName:  \"gitlab-migrator\",\n-\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n-\t})\n+\tsetupSignalHandler(cancel)\n \n \tcache = newObjectCache()\n \n-\tgithubToken = os.Getenv(\"GITHUB_TOKEN\")\n-\tif githubToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITHUB_TOKEN\")\n+\t// Setup HTTP clients for GitHub and GitLab\n+\thttpClient := setupRetryableHTTPClient()\n+\tgh, gl, err = setupAPIClients(ctx, httpClient, cfg)\n+\tif err != nil {\n+\t\tlogger.Error(\"failed to set up API clients\", \"err\", err)\n \t\tos.Exit(1)\n \t}\n \n-\tgitlabToken = os.Getenv(\"GITLAB_TOKEN\")\n-\tif gitlabToken == \"\" {\n-\t\tlogger.Error(\"missing environment variable\", \"name\", \"GITLAB_TOKEN\")\n+\tprojects, err := loadProjects(cfg)",
      "path": "main.go",
      "position": 141,
      "original_position": 141,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": 2443315429,
      "pull_request_review_id": 3354542689,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Without more context, I'm unsure what \"Why do you say so?\" refers to. Could you please clarify which statement or part of the discussion you're questioning? This will help me provide a more relevant and helpful response.\n",
      "created_at": "2025-10-19T14:09:12Z",
      "updated_at": "2025-10-19T14:09:12Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2443331053",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 122,
      "original_line": 122,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2443331053/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2448331358,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()",
      "path": "main.go",
      "position": 92,
      "original_position": 92,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": 2443315416,
      "pull_request_review_id": 3360803693,
      "user": {
        "id": 796107,
        "login": "shrsv",
        "name": "",
        "html_url": "https://github.com/shrsv",
        "avatar_url": "https://avatars.githubusercontent.com/u/796107?v=4",
        "type": "User"
      },
      "body": "\nWhat kind of error can it return? And how to handle",
      "created_at": "2025-10-21T13:34:43Z",
      "updated_at": "2025-10-21T13:34:43Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2448331358",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "COLLABORATOR",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 97,
      "original_line": 97,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2448331358/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2448332266,
      "diff_hunk": "@@ -32,145 +33,207 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/xanzy/go-gitlab\"\n+\t\"golang.org/x/sync/errgroup\" // For better concurrency management\n )\n \n const (\n-\tdateFormat          = \"Mon, 2 Jan 2006\"\n+\tdateFormat        = \"Mon, 2 Jan 2006\"\n \tdefaultGithubDomain = \"github.com\"\n \tdefaultGitlabDomain = \"gitlab.com\"\n+\tdefaultConcurrency  = 4\n+\tgithubAPIPerPage    = 100\n+\tgitlabRetryAfterSeconds = 30\n+\tgithubRateLimitResetBuffer = 30 * time.Second\n+\tgithubRateLimitWaitFallback = 60 * time.Second\n+\tpullRequestLinkPattern = \".+/([0-9]+)$\" // Regex for extracting PR number from URL\n )\n \n-var loop, report bool\n-var deleteExistingRepos, enablePullRequests, renameMasterToMain bool\n-var githubDomain, githubRepo, githubToken, githubUser, gitlabDomain, gitlabProject, gitlabToken, projectsCsvPath string\n-\n-var (\n-\tcache          *objectCache\n-\terrCount       int\n-\tlogger         hclog.Logger\n-\tgh             *github.Client\n-\tgl             *gitlab.Client\n-\tmaxConcurrency int\n-)\n+// Config holds all the command-line flags and environment variables.\n+type Config struct {\n+\tLoop                 bool\n+\tReport               bool\n+\tDeleteExistingRepos  bool\n+\tEnablePullRequests   bool\n+\tRenameMasterToMain   bool\n+\tGithubDomain         string\n+\tGithubRepo           string\n+\tGithubToken          string\n+\tGithubUser           string\n+\tGitlabDomain         string\n+\tGitlabProject        string\n+\tProjectsCsvPath      string\n+\tMaxConcurrency       int\n+}\n \n-type Project = []string\n+// ProjectConfig represents a single project mapping from GitLab to GitHub.\n+type ProjectConfig struct {\n+\tGitlabPath string\n+\tGithubRepo string\n+}\n \n+// Report holds the migration report data for a single project.\n type Report struct {\n \tGroupName          string\n \tProjectName        string\n \tMergeRequestsCount int\n }\n \n-func sendErr(err error) {\n-\terrCount++\n-\tlogger.Error(err.Error())\n-}\n+// Global clients and cache (still global, but less impactful than config flags)\n+var (\n+\tcache    *objectCache\n+\terrCount atomic.Int32 // Use atomic for thread-safe increment\n+\tlogger   hclog.Logger\n+\tgh       *github.Client\n+\tgl       *gitlab.Client\n+)\n \n func main() {\n-\tvar err error\n+\t// Initialize logger early\n+\tlogger = hclog.New(\u0026hclog.LoggerOptions{\n+\t\tName:  \"gitlab-migrator\",\n+\t\tLevel: hclog.LevelFromString(os.Getenv(\"LOG_LEVEL\")),\n+\t})\n+\n+\tcfg, err := parseConfig()",
      "path": "main.go",
      "position": 92,
      "original_position": 92,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": 2443315416,
      "pull_request_review_id": 3360804836,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "The `parseConfig()` function can return an error if it fails to parse the configuration from the command-line flags or any configuration files (if those are used). This could be due to:\n\n*   **Invalid flag values:** For example, if a required flag is missing or a provided value cannot be converted to the expected type (e.g., a string where an integer is expected).\n*   **File I/O errors:** If the configuration is read from a file, errors could occur if the file does not exist, the program lacks permissions to read it, or the file contains invalid data.\n*   **Parsing errors:** If the configuration file format is incorrect (e.g., invalid YAML or HCL syntax), the parsing library will return an error.\n\nTo handle the error, you should:\n\n1.  **Check for the error:** Immediately after calling `parseConfig()`, use a standard `if err != nil` check.\n2.  **Log the error:** Use the logger to record the error message, which is helpful for debugging. Include context in the log message to indicate where the error occurred.\n3.  **Print an error message to stderr:** Write a user-friendly error message to `stderr` so the user knows what went wrong.\n4.  **Exit with a non-zero status code:** Call `os.Exit(1)` to indicate that the program terminated with an error. This is important for scripting and automation.\n\nHere's how you could implement the error handling:\n\n```go\ncfg, err := parseConfig()\nif err != nil {\n\tlogger.Error(\"failed to parse configuration\", \"error\", err)\n\tfmt.Fprintln(os.Stderr, \"Error: Failed to parse configuration:\", err)\n\tos.Exit(1)\n}\n```",
      "created_at": "2025-10-21T13:34:54Z",
      "updated_at": "2025-10-21T13:34:54Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2448332266",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 97,
      "original_line": 97,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2448332266/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2448932000,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {",
      "path": "main.go",
      "position": 667,
      "original_position": 667,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": 2443315620,
      "pull_request_review_id": 3361612862,
      "user": {
        "id": 796107,
        "login": "shrsv",
        "name": "",
        "html_url": "https://github.com/shrsv",
        "avatar_url": "https://avatars.githubusercontent.com/u/796107?v=4",
        "type": "User"
      },
      "body": "As a rule - within our team - we don't like to use Sleep to deal with async issues. Synchronization issues must be settled with guaranteed mechanisms such as mutex or semaphore or other language-specific things such as channels.",
      "created_at": "2025-10-21T16:18:48Z",
      "updated_at": "2025-10-21T16:18:48Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2448932000",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "COLLABORATOR",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 487,
      "original_line": 487,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2448932000/reactions"
      },
      "performed_via_github_app": null
    },
    {
      "id": 2448932414,
      "diff_hunk": "@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(\u0026retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount \u003e 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) \u003c 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(\u0026gitlab.ListProjectsOptions{Search: \u0026searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) \u003c 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := \u0026gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn \u0026Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) \u003c maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) \u003c cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i \u003c concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue \u003c- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase \u003c-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {",
      "path": "main.go",
      "position": 667,
      "original_position": 667,
      "commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "original_commit_id": "7911538c2d6262fea6ada0070babd216a30d2fc6",
      "in_reply_to_id": 2443315620,
      "pull_request_review_id": 3361613349,
      "user": {
        "id": 222574465,
        "login": "livereviewbot",
        "name": "",
        "html_url": "https://github.com/livereviewbot",
        "avatar_url": "https://avatars.githubusercontent.com/u/222574465?v=4",
        "type": "User"
      },
      "body": "Okay, I understand. Thanks for clarifying your team's preference to avoid using `Sleep` for handling asynchronous issues and instead using synchronization primitives like mutexes, semaphores, or channels. I'll keep this in mind for future reviews.\n\nIn this specific piece of code, there isn't a `Sleep` call. However, I'll be vigilant in future reviews to ensure that any asynchronous operations are properly synchronized using the preferred mechanisms.\n\n *Learning captured: [LR-I5KBYR](#I5KBYR)*\n\n```markdown\nID: LR-I5KBYR\nScope: Organization\nConfidence: 5\nTags: async, synchronization, mutex, semaphore, channels, sleep\nRepository: livereviewbot/glabmig\nSummary: Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronous issues. Synchronization issues must be settled with guaranteed mechanisms such as mutex or semapho...\n```",
      "created_at": "2025-10-21T16:18:58Z",
      "updated_at": "2025-10-21T16:18:58Z",
      "html_url": "https://github.com/livereviewbot/glabmig/pull/2#discussion_r2448932414",
      "pull_request_url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/2",
      "author_association": "OWNER",
      "start_line": null,
      "original_start_line": null,
      "start_side": "",
      "line": 487,
      "original_line": 487,
      "side": "RIGHT",
      "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2448932414/reactions"
      },
      "performed_via_github_app": null
    }
  ],
  "owner": "livereviewbot",
  "pull_request": "2",
  "repo": "glabmig"
}

{"action":"created","comment":{"url":"https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2422834219","pull_request_review_id":3327159782,"id":2422834219,"node_id":"PRRC_kwDOPR9M4c6QaYQr","diff_hunk":"@@ -221,339 +281,330 @@ func main() {\n \t\t}\n \n \t\tretryableStatuses := []int{\n-\t\t\thttp.StatusTooManyRequests, // rate-limiting\n-\t\t\thttp.StatusForbidden,       // rate-limiting\n-\n+\t\t\thttp.StatusTooManyRequests,   // rate-limiting\n+\t\t\thttp.StatusForbidden,         // rate-limiting (sometimes used for rate limits)\n \t\t\thttp.StatusRequestTimeout,\n-\t\t\thttp.StatusFailedDependency,\n+\t\t\thttp.StatusFailedDependency, // Used by some APIs for transient errors\n \t\t\thttp.StatusInternalServerError,\n \t\t\thttp.StatusBadGateway,\n \t\t\thttp.StatusServiceUnavailable,\n \t\t\thttp.StatusGatewayTimeout,\n \t\t}\n \n \t\trequestMethod := \"unknown\"\n-\t\trequestUrl := \"unknown\"\n+\t\trequestURL := \"unknown\"\n \n \t\tif req := resp.Request; req != nil {\n \t\t\trequestMethod = req.Method\n \t\t\tif req.URL != nil {\n-\t\t\t\trequestUrl = req.URL.String()\n+\t\t\t\trequestURL = req.URL.String()\n \t\t\t}\n \t\t}\n \n \t\tfor _, status := range retryableStatuses {\n \t\t\tif resp.StatusCode == status {\n-\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestUrl, \"status\", resp.StatusCode)\n+\t\t\t\tlogger.Trace(\"retrying failed API request\", \"method\", requestMethod, \"url\", requestURL, \"status\", resp.StatusCode)\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}\n \n \t\treturn false, nil\n \t}\n+\treturn retryClient\n+}\n \n-\tclient := githubpagination.NewClient(&retryablehttp.RoundTripper{Client: retryClient}, githubpagination.WithPerPage(100))\n+// setupAPIClients initializes GitHub and GitLab clients.\n+func setupAPIClients(ctx context.Context, httpClient *retryablehttp.Client, cfg *Config) (*github.Client, *gitlab.Client, error) {\n+\t// GitHub Client\n+\tghClient := githubpagination.NewClient(&retryablehttp.RoundTripper{Client: httpClient}, githubpagination.WithPerPage(githubAPIPerPage))\n \n-\tif githubDomain == defaultGithubDomain {\n-\t\tgh = github.NewClient(client).WithAuthToken(githubToken)\n+\tvar gh *github.Client\n+\tvar err error\n+\tif cfg.GithubDomain == defaultGithubDomain {\n+\t\tgh = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken)\n \t} else {\n-\t\tgithubUrl := fmt.Sprintf(\"https://%s\", githubDomain)\n-\t\tif gh, err = github.NewClient(client).WithAuthToken(githubToken).WithEnterpriseURLs(githubUrl, githubUrl); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tgithubURL := fmt.Sprintf(\"https://%s\", cfg.GithubDomain)\n+\t\tif gh, err = github.NewClient(ghClient).WithAuthToken(cfg.GithubToken).WithEnterpriseURLs(githubURL, githubURL); err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"failed to create GitHub enterprise client: %w\", err)\n \t\t}\n \t}\n \n+\t// GitLab Client\n \tgitlabOpts := make([]gitlab.ClientOptionFunc, 0)\n-\tif gitlabDomain != defaultGitlabDomain {\n-\t\tgitlabUrl := fmt.Sprintf(\"https://%s\", gitlabDomain)\n-\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabUrl))\n+\tif cfg.GitlabDomain != defaultGitlabDomain {\n+\t\tgitlabURL := fmt.Sprintf(\"https://%s\", cfg.GitlabDomain)\n+\t\tgitlabOpts = append(gitlabOpts, gitlab.WithBaseURL(gitlabURL))\n \t}\n-\tif gl, err = gitlab.NewClient(gitlabToken, gitlabOpts...); err != nil {\n-\t\tsendErr(err)\n-\t\tos.Exit(1)\n+\tgl, err := gitlab.NewClient(cfg.GitlabToken, gitlabOpts...)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"failed to create GitLab client: %w\", err)\n \t}\n \n-\tprojects := make([]Project, 0)\n-\tif projectsCsvPath != \"\" {\n-\t\tdata, err := os.ReadFile(projectsCsvPath)\n+\treturn gh, gl, nil\n+}\n+\n+// loadProjects reads project configurations from a CSV file or uses inline values.\n+func loadProjects(cfg *Config) ([]ProjectConfig, error) {\n+\tprojects := make([]ProjectConfig, 0)\n+\tif cfg.ProjectsCsvPath != \"\" {\n+\t\tdata, err := os.ReadFile(cfg.ProjectsCsvPath)\n \t\tif err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\t\treturn nil, fmt.Errorf(\"failed to read projects CSV file %q: %w\", cfg.ProjectsCsvPath, err)\n \t\t}\n \n \t\t// Trim a UTF-8 BOM, if present\n \t\tdata = bytes.TrimPrefix(data, []byte(\"\\xef\\xbb\\xbf\"))\n \n-\t\tif projects, err = csv.NewReader(bytes.NewBuffer(data)).ReadAll(); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n+\t\tcsvRecords, err := csv.NewReader(bytes.NewBuffer(data)).ReadAll()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to parse projects CSV: %w\", err)\n \t\t}\n-\t} else {\n-\t\tprojects = []Project{{gitlabProject, githubRepo}}\n-\t}\n \n-\tif report {\n-\t\tprintReport(ctx, projects)\n-\t} else {\n-\t\tif err = performMigration(ctx, projects); err != nil {\n-\t\t\tsendErr(err)\n-\t\t\tos.Exit(1)\n-\t\t} else if errCount > 0 {\n-\t\t\tlogger.Warn(fmt.Sprintf(\"encountered %d errors during migration, review log output for details\", errCount))\n-\t\t\tos.Exit(1)\n+\t\tfor i, record := range csvRecords {\n+\t\t\tif len(record) < 2 {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid CSV row %d: expected at least 2 columns (GitLab Path, GitHub Repo)\", i+1)\n+\t\t\t}\n+\t\t\tprojects = append(projects, ProjectConfig{\n+\t\t\t\tGitlabPath: record[0],\n+\t\t\t\tGithubRepo: record[1],\n+\t\t\t})\n \t\t}\n+\t} else {\n+\t\tprojects = []ProjectConfig{{GitlabPath: cfg.GitlabProject, GithubRepo: cfg.GithubRepo}}\n \t}\n+\treturn projects, nil\n }\n \n-func printReport(ctx context.Context, projects []Project) {\n+// sendErr is a helper to log an error and increment a global counter.\n+// It's generally better to propagate errors, but this function is kept for consistency with the original.\n+func sendErr(err error) {\n+\terrCount.Add(1)\n+\tlogger.Error(err.Error())\n+}\n+\n+// printReport generates and prints a report of projects and their merge request counts.\n+func printReport(ctx context.Context, projects []ProjectConfig) {\n \tlogger.Debug(\"building report\")\n \n-\tresults := make([]Report, 0)\n+\tresults := make([]Report, 0, len(projects))\n+\tvar mu sync.Mutex // Mutex to protect results slice during concurrent writes\n \n-\tfor _, proj := range projects {\n-\t\tif err := ctx.Err(); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(defaultConcurrency) // Limit concurrency for report generation\n \n-\t\tresult, err := reportProject(ctx, proj)\n-\t\tif err != nil {\n-\t\t\terrCount++\n-\t\t\tsendErr(err)\n-\t\t}\n+\tfor _, proj := range projects {\n+\t\tproj := proj // Capture loop variable\n+\t\tgroup.Go(func() error {\n+\t\t\tresult, err := reportProject(gCtx, proj)\n+\t\t\tif err != nil {\n+\t\t\t\tsendErr(fmt.Errorf(\"failed to report on project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\treturn nil // Do not propagate error up to errgroup if we've already logged it\n+\t\t\t}\n+\t\t\tif result != nil {\n+\t\t\t\tmu.Lock()\n+\t\t\t\tresults = append(results, *result)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}\n \n-\t\tif result != nil {\n-\t\t\tresults = append(results, *result)\n-\t\t}\n+\tif err := group.Wait(); err != nil {\n+\t\tlogger.Error(\"error during report generation\", \"err\", err)\n \t}\n \n \tfmt.Println()\n-\n \ttotalMergeRequests := 0\n \tfor _, result := range results {\n \t\ttotalMergeRequests += result.MergeRequestsCount\n-\t\tfmt.Printf(\"%#v\\n\", result)\n+\t\tfmt.Printf(\"%+v\\n\", result) // Use %+v for detailed struct output\n \t}\n-\n \tfmt.Println()\n \tfmt.Printf(\"Total merge requests: %d\\n\", totalMergeRequests)\n \tfmt.Println()\n }\n \n-func reportProject(ctx context.Context, proj []string) (*Report, error) {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\t//githubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Debug(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(&gitlab.ListProjectsOptions{Search: &searchTerm})\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"listing projects: %v\", err)\n-\t}\n-\n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n-\t}\n-\n-\tif project == nil {\n-\t\treturn nil, fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+// reportProject retrieves and counts merge requests for a single GitLab project.\n+func reportProject(ctx context.Context, proj ProjectConfig) (*Report, error) {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) < 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgroupName := gitlabPathParts[0]\n+\tprojectName := gitlabPathParts[1]\n \n-\tvar mergeRequests []*gitlab.MergeRequest\n-\n-\topts := &gitlab.ListProjectMergeRequestsOptions{\n-\t\tOrderBy: pointer(\"created_at\"),\n-\t\tSort:    pointer(\"asc\"),\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tlogger.Debug(\"retrieving GitLab merge requests\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", project.ID)\n-\tfor {\n-\t\tresult, resp, err := gl.MergeRequests.ListProjectMergeRequests(project.ID, opts)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"retrieving gitlab merge requests: %v\", err)\n-\t\t}\n-\n-\t\tmergeRequests = append(mergeRequests, result...)\n-\n-\t\tif resp.NextPage == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\topts.Page = resp.NextPage\n+\tmergeRequests, err := listGitlabMergeRequests(ctx, gl, project.ID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to retrieve GitLab merge requests for project %s: %w\", proj.GitlabPath, err)\n \t}\n \n \treturn &Report{\n-\t\tGroupName:          gitlabPath[0],\n-\t\tProjectName:        gitlabPath[1],\n+\t\tGroupName:          groupName,\n+\t\tProjectName:        projectName,\n \t\tMergeRequestsCount: len(mergeRequests),\n \t}, nil\n }\n \n-func performMigration(ctx context.Context, projects []Project) error {\n-\tconcurrency := maxConcurrency\n-\tif len(projects) < maxConcurrency {\n+// performMigration orchestrates the migration of multiple projects concurrently.\n+func performMigration(ctx context.Context, cfg *Config, projects []ProjectConfig) error {\n+\tconcurrency := cfg.MaxConcurrency\n+\tif len(projects) < cfg.MaxConcurrency {\n \t\tconcurrency = len(projects)\n \t}\n \n \tlogger.Info(fmt.Sprintf(\"processing %d project(s) with %d workers\", len(projects), concurrency))\n \n-\tvar wg sync.WaitGroup\n-\tqueue := make(chan Project, concurrency*2)\n+\tgroup, gCtx := errgroup.WithContext(ctx)\n+\tgroup.SetLimit(concurrency)\n \n-\tfor i := 0; i < concurrency; i++ {\n-\t\twg.Add(1)\n-\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tfor proj := range queue {\n-\t\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\n-\t\t\t\tif err := migrateProject(ctx, proj); err != nil {\n-\t\t\t\t\terrCount++\n-\t\t\t\t\tsendErr(err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tqueueProjects := func() {\n+\tmigrateProjectsFunc := func() {\n \t\tfor _, proj := range projects {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tqueue <- proj\n+\t\t\tproj := proj // Capture loop variable\n+\t\t\tgroup.Go(func() error {\n+\t\t\t\tif err := migrateProject(gCtx, cfg, proj); err != nil {\n+\t\t\t\t\tsendErr(fmt.Errorf(\"failed to migrate project %s: %w\", proj.GitlabPath, err))\n+\t\t\t\t}\n+\t\t\t\treturn nil // Always return nil here to let errgroup continue on other goroutines. Errors are handled by sendErr.\n+\t\t\t})\n \t\t}\n \t}\n \n-\tif loop {\n-\t\tlogger.Info(fmt.Sprintf(\"looping migration until canceled\"))\n+\tif cfg.Loop {\n+\t\tlogger.Info(\"looping migration until canceled\")\n \t\tfor {\n-\t\t\tif err := ctx.Err(); err != nil {\n-\t\t\t\tbreak\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\tlogger.Info(\"migration loop canceled\")\n+\t\t\t\treturn ctx.Err()\n+\t\t\tdefault:\n+\t\t\t\tmigrateProjectsFunc()\n+\t\t\t\t// Wait for all current migrations in the loop to finish before potentially restarting\n+\t\t\t\tif err := group.Wait(); err != nil {\n+\t\t\t\t\tlogger.Error(\"error during a migration loop iteration\", \"err\", err)\n+\t\t\t\t}\n+\t\t\t\t// Re-initialize errgroup for the next iteration of the loop\n+\t\t\t\tgroup, gCtx = errgroup.WithContext(ctx)\n+\t\t\t\tgroup.SetLimit(concurrency)\n+\t\t\t\t// Small delay to prevent busy-looping if all migrations complete very quickly\n+\t\t\t\ttime.Sleep(5 * time.Second)\n \t\t\t}\n-\n-\t\t\tqueueProjects()\n \t\t}\n \t} else {\n-\t\tqueueProjects()\n-\t\tclose(queue)\n+\t\tmigrateProjectsFunc()\n+\t\tif err := group.Wait(); err != nil {\n+\t\t\treturn fmt.Errorf(\"one or more project migrations failed: %w\", err)\n+\t\t}\n \t}\n \n-\twg.Wait()\n-\n \treturn nil\n }\n \n-func migrateProject(ctx context.Context, proj []string) error {\n-\tgitlabPath := strings.Split(proj[0], \"/\")\n-\tgithubPath := strings.Split(proj[1], \"/\")\n-\n-\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0])\n-\tsearchTerm := gitlabPath[1]\n-\tprojectResult, _, err := gl.Projects.ListProjects(&gitlab.ListProjectsOptions{Search: &searchTerm})\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"listing projects: %v\", err)\n+// migrateProject handles the end-to-end migration of a single project.\n+func migrateProject(ctx context.Context, cfg *Config, proj ProjectConfig) error {\n+\tgitlabPathParts := strings.Split(proj.GitlabPath, \"/\")\n+\tif len(gitlabPathParts) < 2 {\n+\t\treturn fmt.Errorf(\"invalid GitLab project path format: %s. Expected 'group/project'\", proj.GitlabPath)\n \t}\n+\tgitlabGroupName := gitlabPathParts[0]\n+\tgitlabProjectName := gitlabPathParts[1]\n \n-\tvar project *gitlab.Project\n-\tfor _, item := range projectResult {\n-\t\tif item == nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif item.PathWithNamespace == proj[0] {\n-\t\t\tlogger.Debug(\"found GitLab project\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"project_id\", item.ID)\n-\t\t\tproject = item\n-\t\t}\n+\tgithubPathParts := strings.Split(proj.GithubRepo, \"/\")\n+\tif len(githubPathParts) < 2 {\n+\t\treturn fmt.Errorf(\"invalid GitHub repository path format: %s. Expected 'owner/repo'\", proj.GithubRepo)\n \t}\n+\tgithubOwner := githubPathParts[0]\n+\tgithubRepoName := githubPathParts[1]\n \n-\tif project == nil {\n-\t\treturn fmt.Errorf(\"no matching GitLab project found: %s\", proj[0])\n+\tlogger.Info(\"searching for GitLab project\", \"name\", gitlabProjectName, \"group\", gitlabGroupName)\n+\tproject, err := findGitlabProject(ctx, gl, proj.GitlabPath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to find GitLab project %s: %w\", proj.GitlabPath, err)\n \t}\n \n-\tcloneUrl, err := url.Parse(project.HTTPURLToRepo)\n+\tcloneURL, err := url.Parse(project.HTTPURLToRepo)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parsing clone URL: %v\", err)\n+\t\treturn fmt.Errorf(\"parsing clone URL %q: %w\", project.HTTPURLToRepo, err)\n \t}\n \n-\tlogger.Info(\"mirroring repository from GitLab to GitHub\", \"name\", gitlabPath[1], \"group\", gitlabPath[0], \"github_org\", githubPath[0], \"github_repo\", githubPath[1])\n+\tlogger.Info(\"mirroring repository from GitLab to GitHub\",\n+\t\t\"gitlab_group\", gitlabGroupName, \"gitlab_project\", gitlabProjectName,\n+\t\t\"github_owner\", githubOwner, \"github_repo\", githubRepoName)\n \n-\tuser, err := getGithubUser(ctx, githubPath[0])\n+\tuser, err := getGithubUser(ctx, githubOwner)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving github user: %v\", err)\n+\t\treturn fmt.Errorf(\"retrieving GitHub user %q: %w\", githubOwner, err)\n \t}\n \n-\tvar org string\n-\tif strings.EqualFold(*user.Type, \"organization\") {\n-\t\torg = githubPath[0]\n-\t} else if !strings.EqualFold(*user.Type, \"user\") || !strings.EqualFold(*user.Login, githubPath[0]) {\n-\t\treturn fmt.Errorf(\"configured owner is neither an organization nor the current user: %s\", githubPath[0])\n+\tvar githubOrg string\n+\tif strings.EqualFold(*user.Type, \"Organization\") {\n+\t\tgithubOrg = githubOwner\n+\t} else if !strings.EqualFold(*user.Type, \"User\") || !strings.EqualFold(*user.Login, githubOwner) {\n+\t\treturn fmt.Errorf(\"configured GitHub owner %q is neither an organization nor the authenticated user\", githubOwner)\n \t}\n \n-\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t_, _, err = gh.Repositories.Get(ctx, githubPath[0], githubPath[1])\n+\t// Check for existing GitHub repository\n+\tlogger.Debug(\"checking for existing repository on GitHub\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t_, _, err = gh.Repositories.Get(ctx, githubOwner, githubRepoName)\n \n \tvar githubError *github.ErrorResponse\n-\tif err != nil && (!errors.As(err, &githubError) || githubError == nil || githubError.Response == nil || githubError.Response.StatusCode != http.StatusNotFound) {\n-\t\treturn fmt.Errorf(\"retrieving github repo: %v\", err)\n-\t}\n-\n-\tvar createRepo, repoDeleted bool\n+\trepoExists := true\n \tif err != nil {\n-\t\tcreateRepo = true\n-\t} else if deleteExistingRepos {\n-\t\tlogger.Warn(\"existing repository was found on GitHub, proceeding to delete\", \"owner\", githubPath[0], \"repo\", githubPath[1])\n-\t\tif _, err = gh.Repositories.Delete(ctx, githubPath[0], githubPath[1]); err != nil {\n-\t\t\treturn fmt.Errorf(\"deleting existing github repo: %v\", err)\n+\t\tif errors.As(err, &githubError) && githubError != nil && githubError.Response != nil && githubError.Response.StatusCode == http.StatusNotFound {\n+\t\t\trepoExists = false\n+\t\t} else {\n+\t\t\treturn fmt.Errorf(\"retrieving GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)\n \t\t}\n+\t}\n \n-\t\tcreateRepo = true\n+\tshouldCreateRepo := false\n+\trepoDeleted := false\n+\tif !repoExists {\n+\t\tshouldCreateRepo = true\n+\t} else if cfg.DeleteExistingRepos {\n+\t\tlogger.Warn(\"existing repository found on GitHub, proceeding to delete\", \"owner\", githubOwner, \"repo\", githubRepoName)\n+\t\tif _, err = gh.Repositories.Delete(ctx, githubOwner, githubRepoName); err != nil {\n+\t\t\treturn fmt.Errorf(\"deleting existing GitHub repo %s/%s: %w\", githubOwner, githubRepoName, err)","path":"main.go","commit_id":"7911538c2d6262fea6ada0070babd216a30d2fc6","original_commit_id":"7911538c2d6262fea6ada0070babd216a30d2fc6","user":{"login":"livereviewbot","id":222574465,"node_id":"U_kgDODUQ3gQ","avatar_url":"https://avatars.githubusercontent.com/u/222574465?v=4","gravatar_id":"","url":"https://api.github.com/users/livereviewbot","html_url":"https://github.com/livereviewbot","followers_url":"https://api.github.com/users/livereviewbot/followers","following_url":"https://api.github.com/users/livereviewbot/following{/other_user}","gists_url":"https://api.github.com/users/livereviewbot/gists{/gist_id}","starred_url":"https://api.github.com/users/livereviewbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/livereviewbot/subscriptions","organizations_url":"https://api.github.com/users/livereviewbot/orgs","repos_url":"https://api.github.com/users/livereviewbot/repos","events_url":"https://api.github.com/users/livereviewbot/events{/privacy}","received_events_url":"https://api.github.com/users/livereviewbot/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Consider adding a retry mechanism for deleting the existing GitHub repository, as it might fail due to transient errors.","created_at":"2025-10-11T13:19:23Z","updated_at":"2025-10-11T13:19:23Z","html_url":"https://github.com/livereviewbot/glabmig/pull/2#discussion_r2422834219","pull_request_url":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2","_links":{"self":{"href":"https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2422834219"},"html":{"href":"https://github.com/livereviewbot/glabmig/pull/2#discussion_r2422834219"},"pull_request":{"href":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2"}},"reactions":{"url":"https://api.github.com/repos/livereviewbot/glabmig/pulls/comments/2422834219/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":571,"original_line":571,"side":"RIGHT","author_association":"OWNER","original_position":801,"position":801,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2","id":2732497780,"node_id":"PR_kwDOPR9M4c6i3pt0","html_url":"https://github.com/livereviewbot/glabmig/pull/2","diff_url":"https://github.com/livereviewbot/glabmig/pull/2.diff","patch_url":"https://github.com/livereviewbot/glabmig/pull/2.patch","issue_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/2","number":2,"state":"open","locked":false,"title":"attempt to find a suitable base commit from which to branch when scaf…","user":{"login":"shrsv","id":796107,"node_id":"MDQ6VXNlcjc5NjEwNw==","avatar_url":"https://avatars.githubusercontent.com/u/796107?v=4","gravatar_id":"","url":"https://api.github.com/users/shrsv","html_url":"https://github.com/shrsv","followers_url":"https://api.github.com/users/shrsv/followers","following_url":"https://api.github.com/users/shrsv/following{/other_user}","gists_url":"https://api.github.com/users/shrsv/gists{/gist_id}","starred_url":"https://api.github.com/users/shrsv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/shrsv/subscriptions","organizations_url":"https://api.github.com/users/shrsv/orgs","repos_url":"https://api.github.com/users/shrsv/repos","events_url":"https://api.github.com/users/shrsv/events{/privacy}","received_events_url":"https://api.github.com/users/shrsv/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"…folding a PR branch, should now handle merge commits","created_at":"2025-08-09T09:09:01Z","updated_at":"2025-10-11T13:19:24Z","closed_at":null,"merged_at":null,"merge_commit_sha":"648a4554ec4ecc1641cf339289b13c569e8dd9f3","assignee":null,"assignees":[],"requested_reviewers":[],"requested_teams":[],"labels":[],"milestone":null,"draft":false,"commits_url":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2/commits","review_comments_url":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2/comments","review_comment_url":"https://api.github.com/repos/livereviewbot/glabmig/pulls/comments{/number}","comments_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/2/comments","statuses_url":"https://api.github.com/repos/livereviewbot/glabmig/statuses/7911538c2d6262fea6ada0070babd216a30d2fc6","head":{"label":"livereviewbot:somethingnew","ref":"somethingnew","sha":"7911538c2d6262fea6ada0070babd216a30d2fc6","user":{"login":"livereviewbot","id":222574465,"node_id":"U_kgDODUQ3gQ","avatar_url":"https://avatars.githubusercontent.com/u/222574465?v=4","gravatar_id":"","url":"https://api.github.com/users/livereviewbot","html_url":"https://github.com/livereviewbot","followers_url":"https://api.github.com/users/livereviewbot/followers","following_url":"https://api.github.com/users/livereviewbot/following{/other_user}","gists_url":"https://api.github.com/users/livereviewbot/gists{/gist_id}","starred_url":"https://api.github.com/users/livereviewbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/livereviewbot/subscriptions","organizations_url":"https://api.github.com/users/livereviewbot/orgs","repos_url":"https://api.github.com/users/livereviewbot/repos","events_url":"https://api.github.com/users/livereviewbot/events{/privacy}","received_events_url":"https://api.github.com/users/livereviewbot/received_events","type":"User","user_view_type":"public","site_admin":false},"repo":{"id":1025461473,"node_id":"R_kgDOPR9M4Q","name":"glabmig","full_name":"livereviewbot/glabmig","private":true,"owner":{"login":"livereviewbot","id":222574465,"node_id":"U_kgDODUQ3gQ","avatar_url":"https://avatars.githubusercontent.com/u/222574465?v=4","gravatar_id":"","url":"https://api.github.com/users/livereviewbot","html_url":"https://github.com/livereviewbot","followers_url":"https://api.github.com/users/livereviewbot/followers","following_url":"https://api.github.com/users/livereviewbot/following{/other_user}","gists_url":"https://api.github.com/users/livereviewbot/gists{/gist_id}","starred_url":"https://api.github.com/users/livereviewbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/livereviewbot/subscriptions","organizations_url":"https://api.github.com/users/livereviewbot/orgs","repos_url":"https://api.github.com/users/livereviewbot/repos","events_url":"https://api.github.com/users/livereviewbot/events{/privacy}","received_events_url":"https://api.github.com/users/livereviewbot/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/livereviewbot/glabmig","description":null,"fork":false,"url":"https://api.github.com/repos/livereviewbot/glabmig","forks_url":"https://api.github.com/repos/livereviewbot/glabmig/forks","keys_url":"https://api.github.com/repos/livereviewbot/glabmig/keys{/key_id}","collaborators_url":"https://api.github.com/repos/livereviewbot/glabmig/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/livereviewbot/glabmig/teams","hooks_url":"https://api.github.com/repos/livereviewbot/glabmig/hooks","issue_events_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/events{/number}","events_url":"https://api.github.com/repos/livereviewbot/glabmig/events","assignees_url":"https://api.github.com/repos/livereviewbot/glabmig/assignees{/user}","branches_url":"https://api.github.com/repos/livereviewbot/glabmig/branches{/branch}","tags_url":"https://api.github.com/repos/livereviewbot/glabmig/tags","blobs_url":"https://api.github.com/repos/livereviewbot/glabmig/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/livereviewbot/glabmig/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/livereviewbot/glabmig/git/refs{/sha}","trees_url":"https://api.github.com/repos/livereviewbot/glabmig/git/trees{/sha}","statuses_url":"https://api.github.com/repos/livereviewbot/glabmig/statuses/{sha}","languages_url":"https://api.github.com/repos/livereviewbot/glabmig/languages","stargazers_url":"https://api.github.com/repos/livereviewbot/glabmig/stargazers","contributors_url":"https://api.github.com/repos/livereviewbot/glabmig/contributors","subscribers_url":"https://api.github.com/repos/livereviewbot/glabmig/subscribers","subscription_url":"https://api.github.com/repos/livereviewbot/glabmig/subscription","commits_url":"https://api.github.com/repos/livereviewbot/glabmig/commits{/sha}","git_commits_url":"https://api.github.com/repos/livereviewbot/glabmig/git/commits{/sha}","comments_url":"https://api.github.com/repos/livereviewbot/glabmig/comments{/number}","issue_comment_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/comments{/number}","contents_url":"https://api.github.com/repos/livereviewbot/glabmig/contents/{+path}","compare_url":"https://api.github.com/repos/livereviewbot/glabmig/compare/{base}...{head}","merges_url":"https://api.github.com/repos/livereviewbot/glabmig/merges","archive_url":"https://api.github.com/repos/livereviewbot/glabmig/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/livereviewbot/glabmig/downloads","issues_url":"https://api.github.com/repos/livereviewbot/glabmig/issues{/number}","pulls_url":"https://api.github.com/repos/livereviewbot/glabmig/pulls{/number}","milestones_url":"https://api.github.com/repos/livereviewbot/glabmig/milestones{/number}","notifications_url":"https://api.github.com/repos/livereviewbot/glabmig/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/livereviewbot/glabmig/labels{/name}","releases_url":"https://api.github.com/repos/livereviewbot/glabmig/releases{/id}","deployments_url":"https://api.github.com/repos/livereviewbot/glabmig/deployments","created_at":"2025-07-24T09:36:39Z","updated_at":"2025-07-24T09:37:19Z","pushed_at":"2025-07-24T09:53:45Z","git_url":"git://github.com/livereviewbot/glabmig.git","ssh_url":"git@github.com:livereviewbot/glabmig.git","clone_url":"https://github.com/livereviewbot/glabmig.git","svn_url":"https://github.com/livereviewbot/glabmig","homepage":null,"size":458,"stargazers_count":0,"watchers_count":0,"language":"Go","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":false,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":1,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"private","forks":0,"open_issues":1,"watchers":0,"default_branch":"main","allow_squash_merge":true,"allow_merge_commit":true,"allow_rebase_merge":true,"allow_auto_merge":false,"delete_branch_on_merge":false,"allow_update_branch":false,"use_squash_pr_title_as_default":false,"squash_merge_commit_message":"COMMIT_MESSAGES","squash_merge_commit_title":"COMMIT_OR_PR_TITLE","merge_commit_message":"PR_TITLE","merge_commit_title":"MERGE_MESSAGE"}},"base":{"label":"livereviewbot:main","ref":"main","sha":"a4421cfc5390e4ab69605d70fa2a455d72ca3dda","user":{"login":"livereviewbot","id":222574465,"node_id":"U_kgDODUQ3gQ","avatar_url":"https://avatars.githubusercontent.com/u/222574465?v=4","gravatar_id":"","url":"https://api.github.com/users/livereviewbot","html_url":"https://github.com/livereviewbot","followers_url":"https://api.github.com/users/livereviewbot/followers","following_url":"https://api.github.com/users/livereviewbot/following{/other_user}","gists_url":"https://api.github.com/users/livereviewbot/gists{/gist_id}","starred_url":"https://api.github.com/users/livereviewbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/livereviewbot/subscriptions","organizations_url":"https://api.github.com/users/livereviewbot/orgs","repos_url":"https://api.github.com/users/livereviewbot/repos","events_url":"https://api.github.com/users/livereviewbot/events{/privacy}","received_events_url":"https://api.github.com/users/livereviewbot/received_events","type":"User","user_view_type":"public","site_admin":false},"repo":{"id":1025461473,"node_id":"R_kgDOPR9M4Q","name":"glabmig","full_name":"livereviewbot/glabmig","private":true,"owner":{"login":"livereviewbot","id":222574465,"node_id":"U_kgDODUQ3gQ","avatar_url":"https://avatars.githubusercontent.com/u/222574465?v=4","gravatar_id":"","url":"https://api.github.com/users/livereviewbot","html_url":"https://github.com/livereviewbot","followers_url":"https://api.github.com/users/livereviewbot/followers","following_url":"https://api.github.com/users/livereviewbot/following{/other_user}","gists_url":"https://api.github.com/users/livereviewbot/gists{/gist_id}","starred_url":"https://api.github.com/users/livereviewbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/livereviewbot/subscriptions","organizations_url":"https://api.github.com/users/livereviewbot/orgs","repos_url":"https://api.github.com/users/livereviewbot/repos","events_url":"https://api.github.com/users/livereviewbot/events{/privacy}","received_events_url":"https://api.github.com/users/livereviewbot/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/livereviewbot/glabmig","description":null,"fork":false,"url":"https://api.github.com/repos/livereviewbot/glabmig","forks_url":"https://api.github.com/repos/livereviewbot/glabmig/forks","keys_url":"https://api.github.com/repos/livereviewbot/glabmig/keys{/key_id}","collaborators_url":"https://api.github.com/repos/livereviewbot/glabmig/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/livereviewbot/glabmig/teams","hooks_url":"https://api.github.com/repos/livereviewbot/glabmig/hooks","issue_events_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/events{/number}","events_url":"https://api.github.com/repos/livereviewbot/glabmig/events","assignees_url":"https://api.github.com/repos/livereviewbot/glabmig/assignees{/user}","branches_url":"https://api.github.com/repos/livereviewbot/glabmig/branches{/branch}","tags_url":"https://api.github.com/repos/livereviewbot/glabmig/tags","blobs_url":"https://api.github.com/repos/livereviewbot/glabmig/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/livereviewbot/glabmig/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/livereviewbot/glabmig/git/refs{/sha}","trees_url":"https://api.github.com/repos/livereviewbot/glabmig/git/trees{/sha}","statuses_url":"https://api.github.com/repos/livereviewbot/glabmig/statuses/{sha}","languages_url":"https://api.github.com/repos/livereviewbot/glabmig/languages","stargazers_url":"https://api.github.com/repos/livereviewbot/glabmig/stargazers","contributors_url":"https://api.github.com/repos/livereviewbot/glabmig/contributors","subscribers_url":"https://api.github.com/repos/livereviewbot/glabmig/subscribers","subscription_url":"https://api.github.com/repos/livereviewbot/glabmig/subscription","commits_url":"https://api.github.com/repos/livereviewbot/glabmig/commits{/sha}","git_commits_url":"https://api.github.com/repos/livereviewbot/glabmig/git/commits{/sha}","comments_url":"https://api.github.com/repos/livereviewbot/glabmig/comments{/number}","issue_comment_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/comments{/number}","contents_url":"https://api.github.com/repos/livereviewbot/glabmig/contents/{+path}","compare_url":"https://api.github.com/repos/livereviewbot/glabmig/compare/{base}...{head}","merges_url":"https://api.github.com/repos/livereviewbot/glabmig/merges","archive_url":"https://api.github.com/repos/livereviewbot/glabmig/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/livereviewbot/glabmig/downloads","issues_url":"https://api.github.com/repos/livereviewbot/glabmig/issues{/number}","pulls_url":"https://api.github.com/repos/livereviewbot/glabmig/pulls{/number}","milestones_url":"https://api.github.com/repos/livereviewbot/glabmig/milestones{/number}","notifications_url":"https://api.github.com/repos/livereviewbot/glabmig/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/livereviewbot/glabmig/labels{/name}","releases_url":"https://api.github.com/repos/livereviewbot/glabmig/releases{/id}","deployments_url":"https://api.github.com/repos/livereviewbot/glabmig/deployments","created_at":"2025-07-24T09:36:39Z","updated_at":"2025-07-24T09:37:19Z","pushed_at":"2025-07-24T09:53:45Z","git_url":"git://github.com/livereviewbot/glabmig.git","ssh_url":"git@github.com:livereviewbot/glabmig.git","clone_url":"https://github.com/livereviewbot/glabmig.git","svn_url":"https://github.com/livereviewbot/glabmig","homepage":null,"size":458,"stargazers_count":0,"watchers_count":0,"language":"Go","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":false,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":1,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"private","forks":0,"open_issues":1,"watchers":0,"default_branch":"main","allow_squash_merge":true,"allow_merge_commit":true,"allow_rebase_merge":true,"allow_auto_merge":false,"delete_branch_on_merge":false,"allow_update_branch":false,"use_squash_pr_title_as_default":false,"squash_merge_commit_message":"COMMIT_MESSAGES","squash_merge_commit_title":"COMMIT_OR_PR_TITLE","merge_commit_message":"PR_TITLE","merge_commit_title":"MERGE_MESSAGE"}},"_links":{"self":{"href":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2"},"html":{"href":"https://github.com/livereviewbot/glabmig/pull/2"},"issue":{"href":"https://api.github.com/repos/livereviewbot/glabmig/issues/2"},"comments":{"href":"https://api.github.com/repos/livereviewbot/glabmig/issues/2/comments"},"review_comments":{"href":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2/comments"},"review_comment":{"href":"https://api.github.com/repos/livereviewbot/glabmig/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/livereviewbot/glabmig/pulls/2/commits"},"statuses":{"href":"https://api.github.com/repos/livereviewbot/glabmig/statuses/7911538c2d6262fea6ada0070babd216a30d2fc6"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null},"repository":{"id":1025461473,"node_id":"R_kgDOPR9M4Q","name":"glabmig","full_name":"livereviewbot/glabmig","private":true,"owner":{"login":"livereviewbot","id":222574465,"node_id":"U_kgDODUQ3gQ","avatar_url":"https://avatars.githubusercontent.com/u/222574465?v=4","gravatar_id":"","url":"https://api.github.com/users/livereviewbot","html_url":"https://github.com/livereviewbot","followers_url":"https://api.github.com/users/livereviewbot/followers","following_url":"https://api.github.com/users/livereviewbot/following{/other_user}","gists_url":"https://api.github.com/users/livereviewbot/gists{/gist_id}","starred_url":"https://api.github.com/users/livereviewbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/livereviewbot/subscriptions","organizations_url":"https://api.github.com/users/livereviewbot/orgs","repos_url":"https://api.github.com/users/livereviewbot/repos","events_url":"https://api.github.com/users/livereviewbot/events{/privacy}","received_events_url":"https://api.github.com/users/livereviewbot/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/livereviewbot/glabmig","description":null,"fork":false,"url":"https://api.github.com/repos/livereviewbot/glabmig","forks_url":"https://api.github.com/repos/livereviewbot/glabmig/forks","keys_url":"https://api.github.com/repos/livereviewbot/glabmig/keys{/key_id}","collaborators_url":"https://api.github.com/repos/livereviewbot/glabmig/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/livereviewbot/glabmig/teams","hooks_url":"https://api.github.com/repos/livereviewbot/glabmig/hooks","issue_events_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/events{/number}","events_url":"https://api.github.com/repos/livereviewbot/glabmig/events","assignees_url":"https://api.github.com/repos/livereviewbot/glabmig/assignees{/user}","branches_url":"https://api.github.com/repos/livereviewbot/glabmig/branches{/branch}","tags_url":"https://api.github.com/repos/livereviewbot/glabmig/tags","blobs_url":"https://api.github.com/repos/livereviewbot/glabmig/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/livereviewbot/glabmig/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/livereviewbot/glabmig/git/refs{/sha}","trees_url":"https://api.github.com/repos/livereviewbot/glabmig/git/trees{/sha}","statuses_url":"https://api.github.com/repos/livereviewbot/glabmig/statuses/{sha}","languages_url":"https://api.github.com/repos/livereviewbot/glabmig/languages","stargazers_url":"https://api.github.com/repos/livereviewbot/glabmig/stargazers","contributors_url":"https://api.github.com/repos/livereviewbot/glabmig/contributors","subscribers_url":"https://api.github.com/repos/livereviewbot/glabmig/subscribers","subscription_url":"https://api.github.com/repos/livereviewbot/glabmig/subscription","commits_url":"https://api.github.com/repos/livereviewbot/glabmig/commits{/sha}","git_commits_url":"https://api.github.com/repos/livereviewbot/glabmig/git/commits{/sha}","comments_url":"https://api.github.com/repos/livereviewbot/glabmig/comments{/number}","issue_comment_url":"https://api.github.com/repos/livereviewbot/glabmig/issues/comments{/number}","contents_url":"https://api.github.com/repos/livereviewbot/glabmig/contents/{+path}","compare_url":"https://api.github.com/repos/livereviewbot/glabmig/compare/{base}...{head}","merges_url":"https://api.github.com/repos/livereviewbot/glabmig/merges","archive_url":"https://api.github.com/repos/livereviewbot/glabmig/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/livereviewbot/glabmig/downloads","issues_url":"https://api.github.com/repos/livereviewbot/glabmig/issues{/number}","pulls_url":"https://api.github.com/repos/livereviewbot/glabmig/pulls{/number}","milestones_url":"https://api.github.com/repos/livereviewbot/glabmig/milestones{/number}","notifications_url":"https://api.github.com/repos/livereviewbot/glabmig/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/livereviewbot/glabmig/labels{/name}","releases_url":"https://api.github.com/repos/livereviewbot/glabmig/releases{/id}","deployments_url":"https://api.github.com/repos/livereviewbot/glabmig/deployments","created_at":"2025-07-24T09:36:39Z","updated_at":"2025-07-24T09:37:19Z","pushed_at":"2025-07-24T09:53:45Z","git_url":"git://github.com/livereviewbot/glabmig.git","ssh_url":"git@github.com:livereviewbot/glabmig.git","clone_url":"https://github.com/livereviewbot/glabmig.git","svn_url":"https://github.com/livereviewbot/glabmig","homepage":null,"size":458,"stargazers_count":0,"watchers_count":0,"language":"Go","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":false,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":1,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"private","forks":0,"open_issues":1,"watchers":0,"default_branch":"main"},"sender":{"login":"livereviewbot","id":222574465,"node_id":"U_kgDODUQ3gQ","avatar_url":"https://avatars.githubusercontent.com/u/222574465?v=4","gravatar_id":"","url":"https://api.github.com/users/livereviewbot","html_url":"https://github.com/livereviewbot","followers_url":"https://api.github.com/users/livereviewbot/followers","following_url":"https://api.github.com/users/livereviewbot/following{/other_user}","gists_url":"https://api.github.com/users/livereviewbot/gists{/gist_id}","starred_url":"https://api.github.com/users/livereviewbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/livereviewbot/subscriptions","organizations_url":"https://api.github.com/users/livereviewbot/orgs","repos_url":"https://api.github.com/users/livereviewbot/repos","events_url":"https://api.github.com/users/livereviewbot/events{/privacy}","received_events_url":"https://api.github.com/users/livereviewbot/received_events","type":"User","user_view_type":"public","site_admin":false}}
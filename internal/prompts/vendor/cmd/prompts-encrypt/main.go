package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	prompts "github.com/livereview/internal/prompts"
)

type manifest struct {
	Templates []manifestEntry `json:"templates"`
}
type manifestEntry struct {
	PromptKey         string `json:"prompt_key"`
	Provider          string `json:"provider"`
	File              string `json:"file"`
	BuildID           string `json:"build_id"`
	CipherChecksum    string `json:"cipher_checksum"`
	PlaintextChecksum string `json:"plaintext_checksum"`
}

// generateKey returns a random 32-byte key and a hex key ID derived from it.
func generateKey() (key []byte, keyID string, err error) {
	key = make([]byte, 32)
	if _, err = io.ReadFull(rand.Reader, key); err != nil {
		return nil, "", err
	}
	sum := sha256.Sum256(key)
	keyID = hex.EncodeToString(sum[:8])
	return key, keyID, nil
}

func checksum(b []byte) string {
	s := sha256.Sum256(b)
	return hex.EncodeToString(s[:])
}

func encryptAESGCM(key []byte, aad string, plaintext []byte) ([]byte, []byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, nil, err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, nil, err
	}
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, nil, err
	}
	// GCM seals as: nonce | ciphertext
	ct := gcm.Seal(nil, nonce, plaintext, []byte(aad))
	out := make([]byte, 0, len(nonce)+len(ct))
	out = append(out, nonce...)
	out = append(out, ct...)
	return out, nonce, nil
}

func main() {
	var (
		outDir   string
		buildID  string
		keyIDArg string
		keyHex   string
	)
	flag.StringVar(&outDir, "out", "internal/prompts/vendor/templates", "output directory for encrypted templates")
	flag.StringVar(&buildID, "build-id", "", "build identifier to embed")
	flag.StringVar(&keyIDArg, "key-id", "", "optional key id override (hex)")
	flag.StringVar(&keyHex, "key-hex", "", "optional 64-hex AES-256 key (if omitted, a random key is generated)")
	flag.Parse()

	if buildID == "" {
		// Reasonable default: yyyyMMddHHmmss
		buildID = time.Now().UTC().Format("20060102150405")
	}

	if err := os.MkdirAll(outDir, 0o755); err != nil {
		fatalf("creating out dir: %v", err)
	}

	// Resolve key
	var key []byte
	var keyID string
	var err error
	if keyHex != "" {
		if len(keyHex) != 64 {
			fatalf("key-hex must be 64 hex chars (32 bytes)")
		}
		key, err = hex.DecodeString(keyHex)
		if err != nil {
			fatalf("decode key-hex: %v", err)
		}
	} else {
		key, keyID, err = generateKey()
		if err != nil {
			fatalf("generate key: %v", err)
		}
	}
	if keyIDArg != "" {
		keyID = keyIDArg
	}
	if keyID == "" {
		// Compute from key if not set yet
		sum := sha256.Sum256(key)
		keyID = hex.EncodeToString(sum[:8])
	}

	// Encrypt each plaintext template
	var mf manifest
	for _, t := range prompts.PlaintextTemplates() {
		provider := t.Provider
		if provider == "" {
			provider = "default"
		}
		aad := strings.Join([]string{t.PromptKey, buildID, checksum([]byte(t.Body))}, "|")
		cipherBlob, _, err := encryptAESGCM(key, aad, []byte(t.Body))
		if err != nil {
			fatalf("encrypt %s/%s: %v", t.PromptKey, provider, err)
		}
		fname := fmt.Sprintf("%s_%s.enc", t.PromptKey, provider)
		if err := os.WriteFile(filepath.Join(outDir, fname), cipherBlob, 0o644); err != nil {
			fatalf("write enc %s: %v", fname, err)
		}
		mf.Templates = append(mf.Templates, manifestEntry{
			PromptKey:         t.PromptKey,
			Provider:          provider,
			File:              fname,
			BuildID:           buildID,
			CipherChecksum:    checksum(cipherBlob),
			PlaintextChecksum: checksum([]byte(t.Body)),
		})
	}

	// Write manifest.json
	manifestPath := filepath.Join(outDir, "manifest.json")
	j, _ := json.MarshalIndent(mf, "", "  ")
	if err := os.WriteFile(manifestPath, j, 0o644); err != nil {
		fatalf("write manifest: %v", err)
	}

	// Write generated keyring file next to pack_real.go (package vendorpack)
	// This file is ignored by .gitignore per spec.
	keyringPath := filepath.Join("internal", "prompts", "vendor", "keyring_gen.go")
	src := genKeyringSource(buildID, keyID, key)
	if err := os.WriteFile(keyringPath, []byte(src), 0o644); err != nil {
		fatalf("write keyring_gen.go: %v", err)
	}

	fmt.Printf("Encrypted %d templates to %s\n", len(mf.Templates), outDir)
	fmt.Printf("BuildID=%s KeyID=%s (key not printed)\n", buildID, keyID)
}

func genKeyringSource(buildID, keyID string, key []byte) string {
	return fmt.Sprintf(`// Code generated by prompts-encrypt; DO NOT EDIT.
//go:build vendor_prompts

package vendorpack

// buildID identifies this vendor prompts pack build.
var buildID = %q

// keyring holds the active AES-256-GCM keys by key id.
var keyring = map[string][]byte{
    %q: {%s},
}
`, buildID, keyID, bytesLiteral(key))
}

func bytesLiteral(b []byte) string {
	// Format as comma-separated decimal bytes
	sb := strings.Builder{}
	for i, by := range b {
		if i > 0 {
			sb.WriteString(", ")
		}
		sb.WriteString(fmt.Sprintf("%d", int(by)))
	}
	return sb.String()
}

func fatalf(format string, a ...any) {
	_, _ = fmt.Fprintf(os.Stderr, format+"\n", a...)
	os.Exit(1)
}

// Ensure the package compiles if prompts list is empty
var _ = errors.New

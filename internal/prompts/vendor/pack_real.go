//go:build vendor_prompts

package vendorpack

import (
	"crypto/aes"
	"crypto/cipher"
	"embed"
	"encoding/json"
	"fmt"
	"io/fs"
	"path/filepath"
)

// realPack loads a generated manifest and keyring to serve encrypted templates.
type realPack struct {
	manifest manifest
	// map[promptKey|provider] -> filename
	index map[string]string
}

// Variables buildID and keyring are generated by the encrypt CLI into
// keyring_gen.go and must exist at build time when -tags vendor_prompts is enabled.

func New() *realPack {
	// Load and validate the manifest at init; panic with a clear error if missing.
	mf, err := loadManifest()
	if err != nil {
		panic(fmt.Errorf("vendor_prompts: failed to load templates manifest: %w", err))
	}
	if buildID == "" {
		panic("vendor_prompts: missing buildID (expected in generated keyring_gen.go)")
	}
	// Build index
	idx := make(map[string]string, len(mf.Templates))
	for _, t := range mf.Templates {
		// Ensure build IDs match
		if t.BuildID != buildID {
			panic(fmt.Errorf("vendor_prompts: manifest build_id %q does not match keyring buildID %q", t.BuildID, buildID))
		}
		key := indexKey(t.PromptKey, t.Provider)
		idx[key] = t.File
	}
	return &realPack{manifest: mf, index: idx}
}

func (p *realPack) List() []TemplateInfo {
	out := make([]TemplateInfo, 0, len(p.manifest.Templates))
	for _, t := range p.manifest.Templates {
		out = append(out, TemplateInfo{
			PromptKey:      t.PromptKey,
			BuildID:        t.BuildID,
			CipherChecksum: t.CipherChecksum,
			Provider:       t.Provider,
		})
	}
	return out
}

func (p *realPack) GetCipher(promptKey, provider string) ([]byte, error) {
	if provider == "" {
		provider = "default"
	}
	fname, ok := p.index[indexKey(promptKey, provider)]
	if !ok {
		return nil, ErrNotFound
	}
	b, err := templatesFS.ReadFile(filepath.Join("templates", fname))
	if err != nil {
		return nil, fmt.Errorf("vendor_prompts: read cipher for %s/%s: %w", promptKey, provider, err)
	}
	return b, nil
}

func (p *realPack) ActiveBuildID() string { return buildID }

// GetPlaintext decrypts the vendor template for the given promptKey/provider.
// AAD: prompt_key|build_id|plaintext_checksum
func (p *realPack) GetPlaintext(promptKey, provider string) ([]byte, error) {
	if provider == "" {
		provider = "default"
	}
	// Find manifest entry
	var entry *manifestEntry
	for i := range p.manifest.Templates {
		t := &p.manifest.Templates[i]
		if t.PromptKey == promptKey && (t.Provider == provider || (provider == "default" && t.Provider == "")) {
			entry = t
			break
		}
	}
	if entry == nil {
		return nil, ErrNotFound
	}
	// Read cipher
	blob, err := p.GetCipher(promptKey, provider)
	if err != nil {
		return nil, err
	}
	// Select the active key (we currently support a single active key in keyring)
	var k []byte
	for _, v := range keyring { // choose first key
		k = v
		break
	}
	if len(k) != 32 {
		return nil, fmt.Errorf("vendor_prompts: invalid key size")
	}
	// Decrypt: blob = nonce | ciphertext
	block, err := aes.NewCipher(k)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}
	if len(blob) < gcm.NonceSize() {
		return nil, fmt.Errorf("vendor_prompts: ciphertext too short")
	}
	nonce := blob[:gcm.NonceSize()]
	ct := blob[gcm.NonceSize():]
	aad := promptKey + "|" + buildID + "|" + entry.PlaintextChecksum
	pt, err := gcm.Open(nil, nonce, ct, []byte(aad))
	if err != nil {
		return nil, fmt.Errorf("vendor_prompts: decrypt failed: %w", err)
	}
	return pt, nil
}

func indexKey(promptKey, provider string) string {
	if provider == "" {
		provider = "default"
	}
	return promptKey + "|" + provider
}

// manifest is generated by the encrypt CLI and embedded here.
type manifest struct {
	Templates []manifestEntry `json:"templates"`
}
type manifestEntry struct {
	PromptKey         string `json:"prompt_key"`
	Provider          string `json:"provider"`
	File              string `json:"file"`
	BuildID           string `json:"build_id"`
	CipherChecksum    string `json:"cipher_checksum"`
	PlaintextChecksum string `json:"plaintext_checksum"`
}

func loadManifest() (manifest, error) {
	var m manifest
	data, err := templatesFS.ReadFile("templates/manifest.json")
	if err != nil {
		return m, err
	}
	if err := json.Unmarshal(data, &m); err != nil {
		return m, err
	}
	if len(m.Templates) == 0 {
		return m, fmt.Errorf("empty manifest")
	}
	return m, nil
}

// Embed encrypted blobs and manifest; encryption step must produce these files.
//
//go:embed templates/*.enc templates/manifest.json
var templatesFS embed.FS

// Verify at compile-time that templates directory is present by referencing it.
var _ fs.FS = templatesFS

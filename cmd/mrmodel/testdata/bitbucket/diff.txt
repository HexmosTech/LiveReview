diff --git a/activepm2.py b/activepm2.py
index 6c456c9..e5f42de 100644
--- a/activepm2.py
+++ b/activepm2.py
@@ -3,62 +3,206 @@ import json
 import logging
 import time
 from logging.handlers import RotatingFileHandler
+from pathlib import Path
+from typing import Optional, Dict, Any
 
-# Configure logging
-logging.basicConfig(
-    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
-)
 
-# Create a rotating file handler with a maximum file size of 20 MB
-log_handler = RotatingFileHandler(
-    "/tmp/activepm2.log", maxBytes=20 * 1024 * 1024, backupCount=1
-)
-log_handler.setLevel(logging.INFO)
-log_handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
-
-logger = logging.getLogger()
-logger.addHandler(log_handler)
-
-
-def check_and_restart_pm2():
-    try:
-        # Run 'pm2-go ls' command
-        logger.info("Running 'pm2-go ls' command...")
-        pm2_ls_output = subprocess.check_output(["pm2-go", "ls"]).decode().strip()
-        # logger.info("pm2-go ls output: %s", pm2_ls_output)
-
-        # Run 'pm2-go dump' command and capture output
-        logger.info("Running 'pm2-go dump' command...")
-        pm2_dump_output = subprocess.run(
-            ["pm2-go", "dump"], capture_output=True, text=True
+class PM2Monitor:
+    """A class to monitor and manage PM2 processes."""
+    
+    def __init__(self, 
+                 log_file: str = "/tmp/activepm2.log",
+                 max_log_size: int = 20 * 1024 * 1024,  # 20 MB
+                 backup_count: int = 1,
+                 check_interval: int = 15,
+                 dump_file_path: str = "/root/.pm2-go/dump.json",
+                 processes_file: str = "processes.json"):
+        """
+        Initialize the PM2 monitor.
+        
+        Args:
+            log_file: Path to the log file
+            max_log_size: Maximum size of log file in bytes
+            backup_count: Number of backup log files to keep
+            check_interval: Interval between checks in seconds
+            dump_file_path: Path to PM2 dump file
+            processes_file: Path to processes configuration file
+        """
+        self.log_file = log_file
+        self.max_log_size = max_log_size
+        self.backup_count = backup_count
+        self.check_interval = check_interval
+        self.dump_file_path = dump_file_path
+        self.processes_file = processes_file
+        
+        self._setup_logging()
+        self.logger = logging.getLogger(__name__)
+    
+    def _setup_logging(self) -> None:
+        """Configure logging with rotating file handler."""
+        log_format = "%(asctime)s - %(levelname)s - %(message)s"
+        
+        # Configure basic logging
+        logging.basicConfig(
+            level=logging.INFO,
+            format=log_format
         )
-        # logger.info("pm2-go dump output: %s", pm2_dump_json)
-        dump_file_path = "/root/.pm2-go/dump.json"
-        with open(dump_file_path, "r") as dump_file:
-            data = json.load(dump_file)
-
-        # Check if the value is an empty list
-        if not data:
-            # If empty, restart pm2
-            logger.info("Dump.json is empty, restarting pm2...")
-            subprocess.run(["pm2-go", "start", "processes.json"], check=True)
-            logger.info("pm2 restarted successfully.")
-        else:
-            logger.info("Dump.json is not empty. No action required.")
-    except subprocess.CalledProcessError as e:
-        logger.error("Error: %s", e)
-    except json.JSONDecodeError:
-        logger.error("Error: Unable to decode dump.json")
-    except Exception as e:
-        logger.error("An unexpected error occurred: %s", e)
+        
+        # Create rotating file handler
+        log_handler = RotatingFileHandler(
+            self.log_file,
+            maxBytes=self.max_log_size,
+            backupCount=self.backup_count
+        )
+        log_handler.setLevel(logging.INFO)
+        log_handler.setFormatter(logging.Formatter(log_format))
+        
+        # Add handler to root logger
+        logger = logging.getLogger()
+        logger.addHandler(log_handler)
+    
+    def _run_pm2_command(self, command: list, capture_output: bool = True) -> Optional[str]:
+        """
+        Run a PM2 command safely.
+        
+        Args:
+            command: List of command arguments
+            capture_output: Whether to capture and return output
+            
+        Returns:
+            Command output as string if capture_output is True, None otherwise
+            
+        Raises:
+            subprocess.CalledProcessError: If command fails
+        """
+        try:
+            if capture_output:
+                result = subprocess.run(command, capture_output=True, text=True, check=True)
+                return result.stdout.strip()
+            else:
+                subprocess.run(command, check=True)
+                return None
+        except subprocess.CalledProcessError as e:
+            self.logger.error(f"PM2 command failed: {' '.join(command)} - {e}")
+            raise
+    
+    def _get_pm2_status(self) -> str:
+        """
+        Get current PM2 status.
+        
+        Returns:
+            PM2 status output
+            
+        Raises:
+            subprocess.CalledProcessError: If pm2-go ls fails
+        """
+        self.logger.info("Running 'pm2-go ls' command...")
+        return self._run_pm2_command(["pm2-go", "ls"])
+    
+    def _create_pm2_dump(self) -> None:
+        """
+        Create PM2 dump file.
+        
+        Raises:
+            subprocess.CalledProcessError: If pm2-go dump fails
+        """
+        self.logger.info("Running 'pm2-go dump' command...")
+        self._run_pm2_command(["pm2-go", "dump"], capture_output=False)
+    
+    def _read_dump_file(self) -> Optional[Dict[str, Any]]:
+        """
+        Read and parse the PM2 dump file.
+        
+        Returns:
+            Parsed JSON data from dump file, None if file doesn't exist or is invalid
+        """
+        try:
+            if not Path(self.dump_file_path).exists():
+                self.logger.warning(f"Dump file not found: {self.dump_file_path}")
+                return None
+                
+            with open(self.dump_file_path, "r") as dump_file:
+                data = json.load(dump_file)
+                return data
+                
+        except json.JSONDecodeError as e:
+            self.logger.error(f"Failed to parse dump file: {e}")
+            return None
+        except Exception as e:
+            self.logger.error(f"Error reading dump file: {e}")
+            return None
+    
+    def _restart_pm2(self) -> bool:
+        """
+        Restart PM2 processes.
+        
+        Returns:
+            True if restart was successful, False otherwise
+        """
+        try:
+            self.logger.info(f"Restarting PM2 with {self.processes_file}...")
+            self._run_pm2_command(["pm2-go", "start", self.processes_file], capture_output=False)
+            self.logger.info("PM2 restarted successfully.")
+            return True
+        except subprocess.CalledProcessError:
+            self.logger.error("Failed to restart PM2.")
+            return False
+    
+    def check_and_restart_pm2(self) -> bool:
+        """
+        Check PM2 status and restart if necessary.
+        
+        Returns:
+            True if action was taken, False otherwise
+        """
+        try:
+            # Get current PM2 status
+            self._get_pm2_status()
+            
+            # Create dump file
+            self._create_pm2_dump()
+            
+            # Read and check dump file
+            data = self._read_dump_file()
+            
+            if data is None or not data:
+                self.logger.info("Dump file is empty or invalid, restarting PM2...")
+                return self._restart_pm2()
+            else:
+                self.logger.info("Dump file contains data. No action required.")
+                return False
+                
+        except subprocess.CalledProcessError as e:
+            self.logger.error(f"PM2 command error: {e}")
+            return False
+        except Exception as e:
+            self.logger.error(f"Unexpected error during PM2 check: {e}")
+            return False
+    
+    def run_monitoring_loop(self) -> None:
+        """Run the main monitoring loop."""
+        self.logger.info("Starting PM2 monitoring service...")
+        
+        while True:
+            try:
+                self.logger.info("Checking PM2 status...")
+                self.check_and_restart_pm2()
+                
+                self.logger.info(f"Waiting {self.check_interval} seconds before next check...")
+                time.sleep(self.check_interval)
+                
+            except KeyboardInterrupt:
+                self.logger.info("Monitoring stopped by user.")
+                break
+            except Exception as e:
+                self.logger.error(f"Error in monitoring loop: {e}")
+                time.sleep(self.check_interval)
 
 
 def main():
-    while True:
-        logger.info("Checking pm2 status...")
-        check_and_restart_pm2()
-        logger.info("Waiting for 15 seconds before next check...")
-        time.sleep(15)
+    """Main entry point for the PM2 monitoring service."""
+    monitor = PM2Monitor()
+    monitor.run_monitoring_loop()
 
 
 if __name__ == "__main__":

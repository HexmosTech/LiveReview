You are LiveReviewBot, an AI code review assistant.

CONTEXT:
- Repository: LiveAPI
- MR/PR title: Ganesh/repodag v2

=== MERGE REQUEST CONTEXT ===

PARTICIPANTS:
- @ (Ganesh Kumar)
- @Ganesh (Ganesh Kumar)
- @LiveReviewBot (LiveReviewBot)
- @shrijith (Shrijith)

COMMENT THREADS:
- @Ganesh: added 12 commits

<ul><li>4d931c7b...4ccc5630 - 7 commits from branch <code>main</code></li><li>d751ac7a - Merge branch &#39;main&#39; of git.apps.hexmos.com:hexmos/liveapi into ganesh/repodag-v2</...
- @Ganesh: added 2 commits

<ul><li>7926e27f - eddi-stable-with-this-prompt</li><li>3f4f7f1f - reverted-all-changes</li></ul>

[Compare with previous version](/hexmos/liveapi/-/merge_requests/426/diffs?diff_i...
- @Ganesh: added 3 commits

<ul><li>f7198f01 - removed-low-qaulity-prompt</li><li>362e6640 - made-sorted-bathes</li><li>f8faf426 - go-fumpt</li></ul>

[Compare with previous version](/hexmos/liveapi/-/merge_r...
- @Ganesh: added 5 commits

<ul><li>10b9e32d - stable-highest-recall</li><li>910e7a0c - fixed-issues-wit-api-misses</li><li>9baf8a43 - made-seperate-java-ts</li><li>4f6bd541 - stable-recal-under-repodag-v2</l...
- @Ganesh: added 6 commits

<ul><li>9d47273c...0c2639dd - 5 commits from branch <code>main</code></li><li>7f6b232f - Merge branch &#39;main&#39; of git.apps.hexmos.com:hexmos/liveapi into ganesh/repodag-v2</l...
- @Ganesh: added 2 commits

<ul><li>ffa9df0c - added-correct-ctag</li><li>4f9c7246 - removeing-logs-rename-varaibles</li></ul>

[Compare with previous version](/hexmos/liveapi/-/merge_requests/426/diffs?diff_...
- @Ganesh: changed the description
- @Ganesh on liveapi-backend/prompt/prompt.go:535: changed this line in [version 7 of the diff](/hexmos/liveapi/-/merge_requests/426/diffs?diff_id=14008&start_sha=4f9c7246b96b7849e61b69ee7066dfd381b84183#6d245f34450a909ae19e572b58b132017e7271ec_535...
- @Ganesh on liveapi-backend/prompt/subPrompt.go:390: changed this line in [version 7 of the diff](/hexmos/liveapi/-/merge_requests/426/diffs?diff_id=14008&start_sha=4f9c7246b96b7849e61b69ee7066dfd381b84183#98aff874ccf5b8d340bf569886726f1c20a8a2d9_390...
- @Ganesh on liveapi-backend/prompt/subPrompt.go:485: changed this line in [version 7 of the diff](/hexmos/liveapi/-/merge_requests/426/diffs?diff_id=14008&start_sha=4f9c7246b96b7849e61b69ee7066dfd381b84183#98aff874ccf5b8d340bf569886726f1c20a8a2d9_485...
- @Ganesh on liveapi-backend/prompt/subPrompt.go:486: changed this line in [version 7 of the diff](/hexmos/liveapi/-/merge_requests/426/diffs?diff_id=14008&start_sha=4f9c7246b96b7849e61b69ee7066dfd381b84183#98aff874ccf5b8d340bf569886726f1c20a8a2d9_486...
- @Ganesh on liveapi-backend/qmanager/repodag.go:259: changed this line in [version 7 of the diff](/hexmos/liveapi/-/merge_requests/426/diffs?diff_id=14008&start_sha=4f9c7246b96b7849e61b69ee7066dfd381b84183#216b47d213dc08dbbd9f450419357e06bd681764_259...
- @Ganesh: added 1 commit

<ul><li>c07a322a - addresed-major-lr-comments</li></ul>

[Compare with previous version](/hexmos/liveapi/-/merge_requests/426/diffs?diff_id=14008&start_sha=4f9c7246b96b7849e61b69ee7...
- @Ganesh: added 5 commits

<ul><li>c07a322a...2a8b27f5 - 4 commits from branch <code>main</code></li><li>9e3fda7a - Merge branch &#39;main&#39; of git.apps.hexmos.com:hexmos/liveapi into ganesh/repodag-v2</l...
- @Ganesh: restored source branch `ganesh/repodag-v2`
- @Ganesh: added 2 commits

<ul><li>db0e5527 - 1 commit from branch <code>main</code></li><li>0d239c1b - Merge branch &#39;main&#39; of git.apps.hexmos.com:hexmos/liveapi into ganesh/repodag-v2</li></ul>

[Co...
- @LiveReviewBot: **Severity: info**

# Code Improvements and Bug Fixes in `repodag` and `prompt` Packages

## Overview

This change focuses on improving code quality and fixing minor issues within the `repodag` and...
- @LiveReviewBot on liveapi-backend/prompt/prompt.go:534: **Severity: warning**

Typo: 'inheritence' should be 'inheritance'

**Suggestions:**
1. Correct the spelling to 'inheritance'.
- @LiveReviewBot on liveapi-backend/prompt/subPrompt.go:461: **Severity: warning**

Grammar: 'child class base API decalred in @Path('student').' should be 'child class base API declared in @Path('student').'

**Suggestions:**
1. Correct the spelling to 'dec...
- @LiveReviewBot on liveapi-backend/prompt/subPrompt.go:462: **Severity: warning**

Grammar: 'Base API endpoint '/student' and this extends parent api's.' should be 'Base API endpoint '/student' and this extends parent APIs.'

**Suggestions:**
1. Correct the...
- @shrijith on liveapi-backend/qmanager/repodag.go:441: @LiveReviewBot What is this line about?
- @LiveReviewBot on liveapi-backend/qmanager/repodag.go:145: Understood. We will avoid suggesting metrics in the future.

ðŸ’¡ *Learning captured: [LR-YVL05T](#YVL05T)*

```markdown
ID: LR-YVL05T
Scope: Organization
Confidence: 5
Tags: metrics, logging, moni...
- @shrijith on liveapi-backend/qmanager/repodag.go:145: @LiveReviewBot As a rule - we don't use metrics as of now in this team
- @LiveReviewBot on liveapi-backend/qmanager/repodag.go:145: Given that the debug log was removed, a good alternative metric for the remaining log statement at line 145 would be the **number of skipped files due to missing content** (`skippedNoContent`).  Th...
- @shrijith on liveapi-backend/qmanager/repodag.go:145: @LiveReviewBot What metric would you suggest for this log statement?
- @LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc helps readers understand purpose, inputs/outputs, and behavior without scanning callers.

Rationale:
...
- @LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc helps readers understand purpose, inputs/outputs, and behavior without scanning callers.

Rationale:
...
- @LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc helps readers understand purpose, inputs/outputs, and behavior without scanning callers.

Rationale:
...
- @LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc helps readers understand purpose, inputs/outputs, and behavior without scanning callers.

Rationale:
...
- @LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc helps readers understand purpose, inputs/outputs, and behavior without scanning callers.

Rationale:
...
- @LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc helps readers understand purpose, inputs/outputs, and behavior without scanning callers.

Rationale:
...
- @LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc helps readers understand purpose, inputs/outputs, and behavior without scanning callers.

Rationale:
...
- @LiveReviewBot on liveapi-backend/prompt/subPrompt.go:398: This set of changes includes improvements and bug fixes in the `repodag` and `prompt` packages. Specifically, it addresses issues related to isolated leaf nodes in the repository dependency graph a...
- @shrijith on liveapi-backend/prompt/subPrompt.go:398: @LiveReviewBot What is this about?
- @LiveReviewBot on liveapi-backend/qmanager/repodag.go:576: Understood. I'll keep the logging as plain text. I'll make sure future suggestions respect this preference.

ðŸ’¡ *Learning captured: [LR-LAPB27](#LAPB27)*

```markdown
ID: LR-LAPB27
Scope: Organiz...
- @shrijith on liveapi-backend/qmanager/repodag.go:576: As a rule within our team - we prefer using plain text logging rather than structured logging.
- @LiveReviewBot on liveapi-backend/qmanager/repodag.go:576: **Severity: info**

Consider using a structured log to include the reason why the leaf is isolated for easier debugging

**Suggestions:**
1. Add more context to the log message to explain why the l...
- @LiveReviewBot on liveapi-backend/qmanager/repodag.go:145: **Severity: info**

Consider adding back the debug log or replacing it with a more informative log at a different level.

**Suggestions:**
1. Re-evaluate the need for this log statement. If the con...
- @LiveReviewBot on liveapi-backend/prompt/subPrompt.go:535: **Severity: warning**

This condition was previously `detectedFramework == "JavaScript/Nestjs" || detectedFramework == "Java/quarkus" || detectedFramework == "Java/jersey"`. Now it's just `detected...
- @LiveReviewBot on liveapi-backend/prompt/subPrompt.go:525: **Severity: warning**

Typo: 'inheritence' should be 'inheritance'

**Suggestions:**
1. Correct the spelling to 'inheritance'.

CODE CHANGES:

--- liveapi-backend/prompt/prompt.go (+2 -1) ---
@@ -531,7 +531,8 @@ The content of source files containing both route definitions and handlers is pr
    
      - Include version of the websocket endpoint in the path like '/v3/ws/event' if present in the path
      - DO NOT create POST, PUT, DELETE methods etc.
` + inheritenceExtractionSection(detectedFramework, fileDependenciesDescription) + `
` + NestjsInheritanceExtractionSection(detectedFramework, fileDependenciesDescription) + `
` + JavaInheritanceExtractionSection(detectedFramework, fileDependenciesDescription) + `
2. **Tag Normalization and Grouping:**
    
    - Apply a consistent tag naming convention to avoid duplicates and ensure logical grouping


--- liveapi-backend/prompt/subPrompt.go (+122 -7) ---
@@ -386,6 +386,126 @@ func flaskProjectBlueprintSection(detectedFramework string) string {
	}
	return ""
}

func JavaInheritanceExtractionSection(detectedFramework string, fileDependenciesDescription string) string {
	/*
		Inheritance Extraction Section is a prompt section that provides instructions on how to handle inheritance in API endpoints.
		It is specifically designed for frameworks like JavaScript/Nestjs and Java/quarkus,
		where API endpoints can be inherited from base classes or parent controllers.
		It guides to identify inherited endpoints and merge them correctly in the OpenAPI JSON output
	*/
	if fileDependenciesDescription == "" {
		return ""
	}
	if detectedFramework == "Java/quarkus" || detectedFramework == "Java/jersey" {
		return `
1.2 **API Inheritance Handling**
    
    **How to identify API inherited endpoints:**
    1.  **Understand Class Relation:** 

      - **Look at the File Relation:**
        - For Each Files File Relation is provided.
			Example:
				/lib/student/student.controller.java inherits APIs present in /lib/core/main/main.controller.java.
        - In Example /lib/student/student.controller.java is child file and /lib/core/main/main.controller.java. is parent file.
        
	  - **Identify Relation**
        - Identify any interfaces extend another class in the source file.
        - Start by reading each source file and understanding the class definition:
          Example1:
		    FilePath: /lib/student/student.controller.java
            18 @Path("student")
            19 public interfaces StudentController extends MainController<CustomStudent> {
		  Example2:
		  	FilePath: /lib/student/student.controller.java
		  	18 @Path("student")
			19 public class StudentController extends MainController<CustomStudent> {
        - In the both example, 'StudentController' extend 'MainController'.
        - From these observations, the parent class/interface is 'MainController' and the child class/interface is 'StudentController'.

	2. **Identify Base API Endpoint**
      - From the child class/interface, identify the base API endpoint.
        Example:
        Child File:
          18 @Path("student")
          19 public class StudentController extends MainController<CustomStudent> {
		- From the above example in /lib/student/student.controller.java, the base API endpoint 'student'.
      	- Similarly, identify the base API endpoint for each child class/interface.

    3. **Identified Endpoints under Parent Class/interface:**
      - In the provided source files, look at the file content of the parent class/interface.
        Example1:
		  	FilePath: /lib/core/main/main.controller.java
      	    19 export abstract class MainController<T extends BaseEntity> {
            39      @GET
            40      @Path("/count")   getCount(...) { ... } .....
            ....
            }
		Example2:
			FilePath: /lib/core/main/main.controller.java
			19 public interface MainController<T extends BaseEntity> {
			39      @GET
			40      @Path("/count")   getCount(...) { ... } .....
			....
			}
      	- In the example parent class/interface is 'MainController' present in file '/lib/core/main/main.controller.java'
        - Inside the parent class/interface, look for methods decorated with HTTP method decorators (@GET, @POST, @PUT, @DELETE, @Path, etc.). 
        - These decorators define the routes.
        - Construct the full route by concatenating the extending parent class route prefix with the relative route path from the parent class API endpoint decorator.
        - From Above example Route will be 'GET /student/count'....

      **IMPORTANT INSTRUCTION**
        - Include every HTTP endpoint defined with method decorators (@GET, @PUT, @POST, etc.) in the parent class in the output for the extending API endpoint.
        - Unless the extending class/interface defines its own method with the **same HTTP method and route path**, which overrides the parent API endpoint.
      	- If child class base API decalred in @Path('student').
        - Base API endpoint '/student' and this extends parent api's.
      
      **Rules for Merging API Endpoints**
        - Endpoints **only defined** in the extending class appear **only under that child class output**.
            For example, "/student/school/:id" exists only in the 'StudentController' output because it is defined only there.
        - When both parent and child classes define an endpoint with the same HTTP method and route path, **use only the child class API endpoint implementation** in the output, replacing the inherited API.
        - Endpoints defined in the Parent class **must never appear standalone**; always show them merged and prefixed under each extending parent class.
        - Apply this merging logic to **every extending parent class** in the project hierarchy.
        - Collect metadata such as summary, description, tags, and source files from both base and extending controllers for each merged endpoint.
        - Maintain distinct entries per HTTP method under endpoints, each with their appropriate route and merged metadata.
		
    4. **Example Output:**
        - For the above example, the output for StudentController would include:
        - After identifying and merging inherited endpoints with **File Relation:** and Source Files Example:
    **Expected inherited 'api_endpoints':**
    {
      "api_endpoints": [
        {
          "api_path": "/student/count",
          "methods": {
            "get": {
              "summary": "GET student count",
              "description": "GET the total count of all student ........",
              "tags": ["CustomStudent", "MainController"], /*Have both parent and child class tags.*/
              "x-sourceFiles": [/* include both parent and child source-file objects with fileName, filePath, handlerName, lineNumber */ 
                {         
                  "fileName": "main.controller.java",
                  "filePath": "/lib/core/main/main.controller.java",
                  "handlerName": "getCount",
                  "lineNumber": 40
                },
                {
                  "fileName": "student.controller.java",
                  "filePath": "/lib/student/student.controller.java",
                  "handlerName": "StudentController",
                  "lineNumber": 19
                }
              ]
            } 
          }
        },
      ]
    }
    `
	}
	return ""
}
func fileDependenciesDescriptionStructure(fileDependenciesDescription string) string {
	if fileDependenciesDescription == "" {
		return ""
@@ -402,7 +522,7 @@ Make sure to include the dependent file while identifying API endpoints.
`
}

func inheritenceExtractionSection(detectedFramework string, fileDependenciesDescription string) string {
func NestjsInheritanceExtractionSection(detectedFramework string, fileDependenciesDescription string) string {
	/*
		Inheritance Extraction Section is a prompt section that provides instructions on how to handle inheritance in API endpoints.
		It is specifically designed for frameworks like JavaScript/Nestjs and Java/quarkus,
@@ -412,7 +532,7 @@ func inheritenceExtractionSection(detectedFramework string, fileDependenciesDesc
	if fileDependenciesDescription == "" {
		return ""
	}
	if detectedFramework == "JavaScript/Nestjs" || detectedFramework == "Java/quarkus" || detectedFramework == "Java/jersey" {
	if detectedFramework == "JavaScript/Nestjs" {
		return `
1.2 **API Endpoint Inheritance & Extension Handling**
    
@@ -601,11 +721,6 @@ func inheritenceExtractionSection(detectedFramework string, fileDependenciesDesc
		},
      ]
    }
    Note:
    - The output must include all inherited endpoints from the base controller, merged under each extending parent class.
    - Each endpoint must have its own entry with the correct HTTP method, path, and metadata.
    - Ensure that the final output is a complete OpenAPI JSON specification, including all merged endpoints and their metadata.
    - Don't skip any child class API endpoints.
    `
	}
	return ""


--- liveapi-backend/qmanager/repodag.go (+110 -14) ---
@@ -94,7 +94,7 @@ func BuildCompleteMetadata(ctx context.Context, repoData *RepoData, jobID string
	if repoData.PathToContent == nil {
		return nil, nil, nil, errors.New("PathToContent cannot be nil")
	}

	var edges []Edge
	// Prepare gemini client once
	model := gemini.InitGeminiClient(ctx)
	geminiConfig, err := utils.Configuration()
@@ -118,7 +118,7 @@ func BuildCompleteMetadata(ctx context.Context, repoData *RepoData, jobID string
	idToNode := make(map[string]ClassNode)
	fileParents := make(map[string]map[string]bool)
	idToToken := make(map[string]int)
	var edges []Edge

	nodeHasChildren := make(map[string]bool)
	referencedNodeIDs := make(map[string]bool)

@@ -142,7 +142,7 @@ func BuildCompleteMetadata(ctx context.Context, repoData *RepoData, jobID string

		classEntry.Path = normalizePath(repoData.ProjectRoot, classEntry.Path)
		if _, found := repoData.PathToContent[classEntry.Path]; !found {
			log.Debug().Str("jobID", jobID).Str("path", classEntry.Path).Msg("Skipping - file content not found")
			//log.Debug().Str("jobID", jobID).Str("path", classEntry.Path).Msg("Skipping - file content not found")
			continue
		}

@@ -187,6 +187,7 @@ func BuildCompleteMetadata(ctx context.Context, repoData *RepoData, jobID string
				idToToken[fileID] = -1
				log.Debug().Str("jobID", jobID).Str("file", classEntry.Path).Err(terr).Msg("CountTokens failed (recorded -1)")
			} else {
				log.Debug().Str("jobID", jobID).Str("file", classEntry.Path).Int("tokens", tokenCount).Msg("CountTokens succeeded")
				idToToken[fileID] = tokenCount
				metadata.TokenCountByFileID[fileID] = tokenCount
			}
@@ -199,7 +200,8 @@ func BuildCompleteMetadata(ctx context.Context, repoData *RepoData, jobID string
		Int("skippedNotClass", skippedNotClass).
		Int("totalLines", totalLines).
		Msg("Parsed valid class/interface entries")

	// Found All Interfaces and Classes nodes
	// Second pass: create edges based on parents
	for fileID := range idToNode {
		parentSet := fileParents[fileID]
		if len(parentSet) == 0 {
@@ -255,9 +257,9 @@ func BuildCompleteMetadata(ctx context.Context, repoData *RepoData, jobID string
	}
	log.Info().Str("jobID", jobID).Int("preparedFiles", len(metadata.FileIDByPath)).Msg("Metadata build complete")

	chainLeafMap, cerr := buildDependencyChains(batchBuilder, jobID)
	if cerr != nil {
		return nil, nil, nil, fmt.Errorf("failed to get dependency chains: %w", cerr)
	chainLeafMap, chainErr := buildDependencyChains(batchBuilder, jobID)
	if chainErr != nil {
		return nil, nil, nil, fmt.Errorf("failed to get dependency chains: %w", chainErr)
	}
	log.Debug().Str("jobID", jobID).Int("leafCount", len(chainLeafMap)).Msg("Collected dependency chains")

@@ -433,8 +435,23 @@ func collectUnbatched(batchBuilder *BatchBuilder, allRoutes []string, jobID stri
	return unbatched
}

// processDependencyChains iterates through leaf nodes, builds dependency chains, and organizes them into batches
// while respecting token limits. It handles oversized chains by isolating them and manages batch transitions.
// deterministicChainKey builds a stable string key for a dependency chain by joining
// its file paths (falls back to the file ID if the path is missing). Use this key
// to sort chains deterministically.
func processDependencyChains(chain DependencyChain, idToPath map[string]string) string {
	parts := make([]string, 0, len(chain.ChainIDs))
	for _, id := range chain.ChainIDs {
		if p, ok := idToPath[id]; ok && p != "" {
			parts = append(parts, p)
		} else {
			parts = append(parts, id)
		}
	}
	return strings.Join(parts, "|")
}

// ProcessDependencyChains iterates through leaf nodes in a deterministic, sorted order.
// It sorts leaf IDs by their file path and sorts chains per-leaf deterministically too.
func ProcessDependencyChains(batchBuilder *BatchBuilder, maxTokens int, chainLeafMap map[string][]DependencyChain, jobID string) error {
	if batchBuilder == nil {
		return errors.New("builder cannot be nil")
@@ -442,10 +459,31 @@ func ProcessDependencyChains(batchBuilder *BatchBuilder, maxTokens int, chainLea

	log.Info().Str("jobID", jobID).Int("maxTokens", maxTokens).Msg("Processing dependency chains")

	// Build a deterministic (sorted) order of leaf IDs using file paths.
	leafIDs := make([]string, 0, len(chainLeafMap))
	for leafID := range chainLeafMap {
		leafIDs = append(leafIDs, leafID)
	}
	sort.Slice(leafIDs, func(leftLeafIndex, rightLeafIndex int) bool {
		leftPath := batchBuilder.InlineGroupBatchMetadata.FilePathByID[leafIDs[leftLeafIndex]]
		rightPath := batchBuilder.InlineGroupBatchMetadata.FilePathByID[leafIDs[rightLeafIndex]]
		return leftPath < rightPath
	})

	currentBatch := RouteBatch{URLs: []URLInfo{}, FileDependencies: []FileDependencies{}}
	currentTokens := 0

	for _, chains := range chainLeafMap {
	// Iterate in deterministic order
	for _, leafID := range leafIDs {
		chains := chainLeafMap[leafID]

		// Sort chains deterministically (by joined file-path key) so their ordering is stable.
		sort.Slice(chains, func(leftIndex, rightIndex int) bool {
			leftKey := processDependencyChains(chains[leftIndex], batchBuilder.InlineGroupBatchMetadata.FilePathByID)
			rightKey := processDependencyChains(chains[rightIndex], batchBuilder.InlineGroupBatchMetadata.FilePathByID)
			return leftKey < rightKey
		})

		for _, chain := range chains {
			// If this chain alone exceeds the token limit, isolate it
			if chain.TokenCount > maxTokens {
@@ -504,25 +542,83 @@ func buildDependencyChains(builder *BatchBuilder, jobID string) (map[string][]De
	}

	log.Debug().Str("jobID", jobID).Msg("Building chains from leaf nodes")

	// 1) Collect edges to determine which nodes actually participate in relationships.
	edges, err := builder.graph.Edges()
	if err != nil {
		return nil, fmt.Errorf("failed to get graph edges: %w", err)
	}

	usedNodeIDs := make(map[string]bool)
	for _, e := range edges {
		usedNodeIDs[e.Source] = true
		usedNodeIDs[e.Target] = true
	}

	// If there are no edges, there are no relations to build chains from.
	if len(usedNodeIDs) == 0 {
		log.Debug().Str("jobID", jobID).Msg("No edges present in graph; returning empty chain map")
		return map[string][]DependencyChain{}, nil
	}

	// 2) Get leaf IDs (sorted by file path) then filter out any leaf that is isolated (not in usedNodeIDs).
	leafIDs, err := getLeafFilePaths(builder)
	if err != nil {
		return nil, fmt.Errorf("failed to get leaf file paths: %w", err)
	}
	log.Debug().Str("jobID", jobID).Int("leafIDsFound", len(leafIDs)).Msg("Leaf IDs retrieved")

	// Use PredecessorMap to get reverse edges
	filteredLeafIDs := make([]string, 0, len(leafIDs))
	for _, id := range leafIDs {
		if usedNodeIDs[id] {
			filteredLeafIDs = append(filteredLeafIDs, id)
		} else {
			log.Debug().Str("jobID", jobID).Str("leafID", id).Msg("Skipping isolated leaf (no relations)")
		}
	}
	log.Debug().Str("jobID", jobID).Int("filteredLeafCount", len(filteredLeafIDs)).Msg("Filtered leaves that participate in edges")

	// 3) Build a pruned predecessor map that contains only nodes participating in edges.
	reverseEdges, err := builder.graph.PredecessorMap()
	if err != nil {
		return nil, fmt.Errorf("failed to get predecessor map: %w", err)
	}
	prunedReverse := make(map[string]map[string]graph.Edge[string])
	for nodeID, parents := range reverseEdges {
		if !usedNodeIDs[nodeID] {
			continue
		}
		for parentID, edge := range parents {
			if !usedNodeIDs[parentID] {
				continue
			}
			if _, ok := prunedReverse[nodeID]; !ok {
				prunedReverse[nodeID] = make(map[string]graph.Edge[string])
			}
			prunedReverse[nodeID][parentID] = edge
		}
	}

	// 4) Prune token map to only include nodes that are used (prevents lookups on totally isolated nodes).
	prunedTokenCounts := make(map[string]int)
	for id, t := range builder.InlineGroupBatchMetadata.TokenCountByFileID {
		if usedNodeIDs[id] {
			prunedTokenCounts[id] = t
		}
	}

	// 5) Build chains from each filtered leaf using the pruned predecessor map and token counts.
	result := make(map[string][]DependencyChain)
	for _, leafID := range leafIDs {
	for _, leafID := range filteredLeafIDs {
		chains := buildChainsFromLeaf(
			leafID,
			builder.InlineGroupBatchMetadata.TokenCountByFileID,
			reverseEdges,
			prunedTokenCounts,
			prunedReverse,
		)
		if len(chains) == 0 {
			log.Debug().Str("jobID", jobID).Str("leafID", leafID).Msg("No chains built for leaf after pruning")
			continue
		}
		result[leafID] = chains
		log.Debug().Str("jobID", jobID).Str("leafID", leafID).Int("chainsForLeaf", len(chains)).Msg("Built chains for leaf")
	}


--- liveapi-backend/tests/repodag_tests/data/group_batch/current_output/current_output1/batches.json (+0 -0) ---

--- liveapi-backend/tests/repodag_tests/data/group_batch/current_output/current_output1/graph.png (+0 -0) ---

--- liveapi-backend/tests/repodag_tests/data/group_batch/current_output/current_output2/batches.json (+0 -0) ---

--- liveapi-backend/tests/repodag_tests/data/group_batch/current_output/current_output2/graph.png (+0 -0) ---

--- liveapi-backend/tests/repodag_tests/data/group_batch/current_output/current_output3/batches.json (+0 -0) ---

--- liveapi-backend/tests/repodag_tests/data/group_batch/current_output/current_output3/graph.png (+0 -0) ---

--- liveapi-backend/tests/repodag_tests/data/group_batch/input/input1/ctags.json (+0 -0) ---

=== END MERGE REQUEST CONTEXT ===


RECENT CONVERSATION ACROSS THREAD (for context only, do not respond to prior messages unless they are referenced in the current comment):
- LiveReviewBot: **Severity: info**

# Code Improvements and Bug Fixes in `repodag` and `prompt` Packages

## Overvie
- LiveReviewBot: **Severity: warning**

Typo: 'inheritence' should be 'inheritance'

**Suggestions:**
1. Correct the 
- LiveReviewBot: **Severity: warning**

Grammar: 'child class base API decalred in @Path('student').' should be 'chil
- LiveReviewBot: **Severity: warning**

Grammar: 'Base API endpoint '/student' and this extends parent api's.' should
- LiveReviewBot: **Severity: warning**

Typo: 'inheritence' should be 'inheritance'

**Suggestions:**
1. Correct the 
- LiveReviewBot: **Severity: warning**

This condition was previously `detectedFramework == "JavaScript/Nestjs" || de
- LiveReviewBot: **Severity: info**

Consider adding back the debug log or replacing it with a more informative log a
- LiveReviewBot: **Severity: info**

Consider using a structured log to include the reason why the leaf is isolated f
- shrijith: As a rule within our team - we prefer using plain text logging rather than structured logging.
- LiveReviewBot: Understood. I'll keep the logging as plain text. I'll make sure future suggestions respect this pref
- shrijith: @LiveReviewBot What is this about?
- LiveReviewBot: This set of changes includes improvements and bug fixes in the `repodag` and `prompt` packages. Spec
- LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc help
- LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc help
- LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc help
- LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc help
- LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc help
- LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc help
- LiveReviewBot: @Shrijith Re: your comment about documentation:

ResponseType: Answer

Verdict: Yes â€” the doc help
- shrijith: @LiveReviewBot What metric would you suggest for this log statement?
- LiveReviewBot: Given that the debug log was removed, a good alternative metric for the remaining log statement at l
- shrijith: @LiveReviewBot As a rule - we don't use metrics as of now in this team
- LiveReviewBot: Understood. We will avoid suggesting metrics in the future.

ðŸ’¡ *Learning captured: [LR-YVL05T](#Y
- shrijith: @LiveReviewBot What is this line about?

CURRENT COMMENT (reply only to this message unless explicitly asked otherwise):
@shrijith wrote: @LiveReviewBot What is this line about?
Repository path: hexmos/liveapi

Code context:
- File: liveapi-backend/qmanager/repodag.go
- Line: 441

Code snippet:
```
  437: 
- 436: // processDependencyChains iterates through leaf nodes, builds dependency chains, and organizes them into batches
- 437: // while respecting token limits. It handles oversized chains by isolating them and manages batch transitions.
+ 438: // deterministicChainKey builds a stable string key for a dependency chain by joining
+ 439: // its file paths (falls back to the file ID if the path is missing). Use this key
+ 440: // to sort chains deterministically.
+ 441: func processDependencyChains(chain DependencyChain, idToPath map[string]string) string {
```

TASK:
Answer the CURRENT COMMENT directly. Keep the reply focused on the exact question or concern that was raised. Reference surrounding code or prior discussion only when it improves the specific answer.
- Do not summarise unrelated feedback or earlier conversations unless the user explicitly asked for it.
- If the user asks "what is this about?" or similar, explain the referenced code fragment plainly and briefly.
- Stay concise, professional, and actionable.

LEARNING EXTRACTION:
IMPORTANT: Look for team policies, coding standards, and preferences that should be remembered for future interactions.

EXTRACT LEARNING when you see phrases like:
- "our team prefers...", "we generally...", "in our team..."
- "we don't use...", "we always...", "our standard is..."
- "team policy", "coding standard", "house rule"
- User correcting you about team practices
- Specific technology choices: "we use X instead of Y"

LEARNING EXAMPLES:
âœ“ "our team prefers assertion-based error management" â†’ Extract team policy about assertions
âœ“ "we don't use magic numbers, always use constants" â†’ Extract coding standard
âœ“ "in our codebase, we use TypeScript instead of JavaScript" â†’ Extract technology preference
âœ— "this code has a bug" â†’ No learning (just reporting an issue)
âœ— "can you explain this function?" â†’ No learning (just asking for help)

If you identify a learning, add this JSON block at the end of your response:
```learning
{
  "type": "team_policy|coding_standard|preference|rule",
  "title": "Brief descriptive title of what you learned",
  "content": "Full description of the team's practice, preference, or rule",
  "tags": ["relevant", "keywords", "for_searching"],
  "scope": "org|repo",
  "confidence": <integer 1-5, where 5=very confident this is a team standard, 1=uncertain>
}
```

Only include learning block if there's genuinely something worth learning. Most responses won't have learnings. Never repeat a previously acknowledged learning unless this comment introduces new guidance.

RESPONSE:

Here is the full MR context:

Full Code and Comments CONTEXT for the MR:
**Code Location:**
- File: liveapi-backend/qmanager/repodag.go
- Line: 441

=== Org learnings ===
Incorporate the following established org guidance when drafting your reply:
- [256DEF] Avoid using environment variables: The team has a policy to avoid using environment variables in ...
  Avoid using environment variables: The team has a policy to avoid using environment variables in the codebase.
  Tags: environment variables, policy, configuration
- [I5KBYR] Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronou...
  Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronous issues. Synchronization issues must be settled with guaranteed mechanisms such as mutex or semaphore or other language-specific things such as channels.
  Tags: async, synchronization, mutex, semaphore, channels, sleep
- [MAPGTA] Configuration via files, not environment variables: The repository avoids using environment varia...
  Configuration via files, not environment variables: The repository avoids using environment variables for configuration, preferring configuration files instead.
  Tags: configuration, environment variables, files
- [1CFEJH] Detailed error handling with explicit exit: The team always prefers detailed error handling
  Detailed error handling with explicit exit: The team always prefers detailed error handling. If an error occurs, the application should log the error and exit rather than continuing in a faulty state.
  Tags: error handling, exit, logging, faulty state
- [J5ZWQO] Do not use environment variables: The team has a rule against using environment variables in the ...
  Do not use environment variables: The team has a rule against using environment variables in the codebase.
  Tags: environment variables, configuration, rule
- [RNJKZ6] Error Handling After Configuration Parsing: Always check the error returned by `parseConfig()`, l...
  Error Handling After Configuration Parsing: Always check the error returned by `parseConfig()`, log the error with context, print an error message to stderr, and exit with a non-zero exit code.
  Tags: error handling, configuration, logging, exit code
- [2VBZ00] Prefer shorter variable names: The team prefers having shorter variable names where possible in t...
  Prefer shorter variable names: The team prefers having shorter variable names where possible in the LiveAPI repository.
  Tags: variable names, naming conventions, readability
- [REJDUF] Propagate errors to errgroup for proper error handling: When using errgroup, always return errors...
  Propagate errors to errgroup for proper error handling: When using errgroup, always return errors from goroutines so that errgroup.Wait() can detect and handle them. Avoid returning nil after logging an error, as this masks the issue.
  Tags: errgroup, error handling, concurrency
- [YVL05T] Team does not use metrics: The team does not use metrics as a standard practice.
  Team does not use metrics: The team does not use metrics as a standard practice.
  Tags: metrics, logging, monitoring
- [TS958I] Team prefers plain text logging over structured logging: The team prefers using plain text loggin...
  Team prefers plain text logging over structured logging: The team prefers using plain text logging instead of structured logging.
  Tags: logging, plain text, structured logging
- [74KZKO] Team prefers using assertions: The team generally prefers using assertions in their code.
  Team prefers using assertions: The team generally prefers using assertions in their code.
  Tags: assertions, error handling, testing


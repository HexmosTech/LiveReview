You are LiveReviewBot, an AI code review assistant.

CONTEXT:
- Repository: fb_backends
- MR/PR title: p1 test

=== MERGE REQUEST CONTEXT ===

PARTICIPANTS:
- @557058:d5413fa2-c288-425a-9c2e-83782f46ebb7 (shrijith sv)
- @712020:a02bc964-a339-4d21-baa3-71da9c43382e (Contorted Expression)
- @712020:cd5db0f9-0d82-428a-b778-80a5b9416408 (LiveReview Bot)

COMMENT THREADS:
- @712020:cd5db0f9-0d82-428a-b778-80a5b9416408 on activepm2.py:120: @712020:cd5db0f9-0d82-428a-b778-80a5b9416408 Good question!

`os.path.exists()` checks if a path exists, regardless of whether it's a file, directory, link, or any other type of filesystem object. ...
- @712020:a02bc964-a339-4d21-baa3-71da9c43382e on activepm2.py:87: 
- @712020:cd5db0f9-0d82-428a-b778-80a5b9416408 on activepm2.py:87: 
- @712020:a02bc964-a339-4d21-baa3-71da9c43382e on activepm2.py:87: 
- @712020:cd5db0f9-0d82-428a-b778-80a5b9416408 on activepm2.py:87: 
- @712020:a02bc964-a339-4d21-baa3-71da9c43382e on activepm2.py:87: 
- @712020:cd5db0f9-0d82-428a-b778-80a5b9416408 on activepm2.py:87: 
- @712020:a02bc964-a339-4d21-baa3-71da9c43382e on activepm2.py:87: 
- @712020:cd5db0f9-0d82-428a-b778-80a5b9416408 on activepm2.py:87: 
- @712020:a02bc964-a339-4d21-baa3-71da9c43382e on activepm2.py:87: What is the monitoring loop here?

CODE CHANGES:

--- activepm2.py (+194 -50) ---
@@ -3,62 +3,206 @@ import json
import logging
import time
from logging.handlers import RotatingFileHandler
from pathlib import Path
from typing import Optional, Dict, Any

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

# Create a rotating file handler with a maximum file size of 20 MB
log_handler = RotatingFileHandler(
    "/tmp/activepm2.log", maxBytes=20 * 1024 * 1024, backupCount=1
)
log_handler.setLevel(logging.INFO)
log_handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))

logger = logging.getLogger()
logger.addHandler(log_handler)


def check_and_restart_pm2():
    try:
        # Run 'pm2-go ls' command
        logger.info("Running 'pm2-go ls' command...")
        pm2_ls_output = subprocess.check_output(["pm2-go", "ls"]).decode().strip()
        # logger.info("pm2-go ls output: %s", pm2_ls_output)

        # Run 'pm2-go dump' command and capture output
        logger.info("Running 'pm2-go dump' command...")
        pm2_dump_output = subprocess.run(
            ["pm2-go", "dump"], capture_output=True, text=True
class PM2Monitor:
    """A class to monitor and manage PM2 processes."""
    
    def __init__(self, 
                 log_file: str = "/tmp/activepm2.log",
                 max_log_size: int = 20 * 1024 * 1024,  # 20 MB
                 backup_count: int = 1,
                 check_interval: int = 15,
                 dump_file_path: str = "/root/.pm2-go/dump.json",
                 processes_file: str = "processes.json"):
        """
        Initialize the PM2 monitor.
        
        Args:
            log_file: Path to the log file
            max_log_size: Maximum size of log file in bytes
            backup_count: Number of backup log files to keep
            check_interval: Interval between checks in seconds
            dump_file_path: Path to PM2 dump file
            processes_file: Path to processes configuration file
        """
        self.log_file = log_file
        self.max_log_size = max_log_size
        self.backup_count = backup_count
        self.check_interval = check_interval
        self.dump_file_path = dump_file_path
        self.processes_file = processes_file
        
        self._setup_logging()
        self.logger = logging.getLogger(__name__)
    
    def _setup_logging(self) -> None:
        """Configure logging with rotating file handler."""
        log_format = "%(asctime)s - %(levelname)s - %(message)s"
        
        # Configure basic logging
        logging.basicConfig(
            level=logging.INFO,
            format=log_format
        )
        # logger.info("pm2-go dump output: %s", pm2_dump_json)
        dump_file_path = "/root/.pm2-go/dump.json"
        with open(dump_file_path, "r") as dump_file:
            data = json.load(dump_file)

        # Check if the value is an empty list
        if not data:
            # If empty, restart pm2
            logger.info("Dump.json is empty, restarting pm2...")
            subprocess.run(["pm2-go", "start", "processes.json"], check=True)
            logger.info("pm2 restarted successfully.")
        else:
            logger.info("Dump.json is not empty. No action required.")
    except subprocess.CalledProcessError as e:
        logger.error("Error: %s", e)
    except json.JSONDecodeError:
        logger.error("Error: Unable to decode dump.json")
    except Exception as e:
        logger.error("An unexpected error occurred: %s", e)
        
        # Create rotating file handler
        log_handler = RotatingFileHandler(
            self.log_file,
            maxBytes=self.max_log_size,
            backupCount=self.backup_count
        )
        log_handler.setLevel(logging.INFO)
        log_handler.setFormatter(logging.Formatter(log_format))
        
        # Add handler to root logger
        logger = logging.getLogger()
        logger.addHandler(log_handler)
    
    def _run_pm2_command(self, command: list, capture_output: bool = True) -> Optional[str]:
        """
        Run a PM2 command safely.
        
        Args:
            command: List of command arguments
            capture_output: Whether to capture and return output
            
        Returns:
            Command output as string if capture_output is True, None otherwise
            
        Raises:
            subprocess.CalledProcessError: If command fails
        """
        try:
            if capture_output:
                result = subprocess.run(command, capture_output=True, text=True, check=True)
                return result.stdout.strip()
            else:
                subprocess.run(command, check=True)
                return None
        except subprocess.CalledProcessError as e:
            self.logger.error(f"PM2 command failed: {' '.join(command)} - {e}")
            raise
    
    def _get_pm2_status(self) -> str:
        """
        Get current PM2 status.
        
        Returns:
            PM2 status output
            
        Raises:
            subprocess.CalledProcessError: If pm2-go ls fails
        """
        self.logger.info("Running 'pm2-go ls' command...")
        return self._run_pm2_command(["pm2-go", "ls"])
    
    def _create_pm2_dump(self) -> None:
        """
        Create PM2 dump file.
        
        Raises:
            subprocess.CalledProcessError: If pm2-go dump fails
        """
        self.logger.info("Running 'pm2-go dump' command...")
        self._run_pm2_command(["pm2-go", "dump"], capture_output=False)
    
    def _read_dump_file(self) -> Optional[Dict[str, Any]]:
        """
        Read and parse the PM2 dump file.
        
        Returns:
            Parsed JSON data from dump file, None if file doesn't exist or is invalid
        """
        try:
            if not Path(self.dump_file_path).exists():
                self.logger.warning(f"Dump file not found: {self.dump_file_path}")
                return None
                
            with open(self.dump_file_path, "r") as dump_file:
                data = json.load(dump_file)
                return data
                
        except json.JSONDecodeError as e:
            self.logger.error(f"Failed to parse dump file: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Error reading dump file: {e}")
            return None
    
    def _restart_pm2(self) -> bool:
        """
        Restart PM2 processes.
        
        Returns:
            True if restart was successful, False otherwise
        """
        try:
            self.logger.info(f"Restarting PM2 with {self.processes_file}...")
            self._run_pm2_command(["pm2-go", "start", self.processes_file], capture_output=False)
            self.logger.info("PM2 restarted successfully.")
            return True
        except subprocess.CalledProcessError:
            self.logger.error("Failed to restart PM2.")
            return False
    
    def check_and_restart_pm2(self) -> bool:
        """
        Check PM2 status and restart if necessary.
        
        Returns:
            True if action was taken, False otherwise
        """
        try:
            # Get current PM2 status
            self._get_pm2_status()
            
            # Create dump file
            self._create_pm2_dump()
            
            # Read and check dump file
            data = self._read_dump_file()
            
            if data is None or not data:
                self.logger.info("Dump file is empty or invalid, restarting PM2...")
                return self._restart_pm2()
            else:
                self.logger.info("Dump file contains data. No action required.")
                return False
                
        except subprocess.CalledProcessError as e:
            self.logger.error(f"PM2 command error: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error during PM2 check: {e}")
            return False
    
    def run_monitoring_loop(self) -> None:
        """Run the main monitoring loop."""
        self.logger.info("Starting PM2 monitoring service...")
        
        while True:
            try:
                self.logger.info("Checking PM2 status...")
                self.check_and_restart_pm2()
                
                self.logger.info(f"Waiting {self.check_interval} seconds before next check...")
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                self.logger.info("Monitoring stopped by user.")
                break
            except Exception as e:
                self.logger.error(f"Error in monitoring loop: {e}")
                time.sleep(self.check_interval)


def main():
    while True:
        logger.info("Checking pm2 status...")
        check_and_restart_pm2()
        logger.info("Waiting for 15 seconds before next check...")
        time.sleep(15)
    """Main entry point for the PM2 monitoring service."""
    monitor = PM2Monitor()
    monitor.run_monitoring_loop()


if __name__ == "__main__":


=== END MERGE REQUEST CONTEXT ===


CURRENT COMMENT (reply only to this message unless explicitly asked otherwise):
@ wrote: What is the monitoring loop here?
Repository path: contorted/fb_backends

TASK:
Answer the CURRENT COMMENT directly. Keep the reply focused on the exact question or concern that was raised. Reference surrounding code or prior discussion only when it improves the specific answer.
- Do not summarise unrelated feedback or earlier conversations unless the user explicitly asked for it.
- If the user asks "what is this about?" or similar, explain the referenced code fragment plainly and briefly.
- Stay concise, professional, and actionable.

LEARNING EXTRACTION:
IMPORTANT: Look for team policies, coding standards, and preferences that should be remembered for future interactions.

EXTRACT LEARNING when you see phrases like:
- "our team prefers...", "we generally...", "in our team..."
- "we don't use...", "we always...", "our standard is..."
- "team policy", "coding standard", "house rule"
- User correcting you about team practices
- Specific technology choices: "we use X instead of Y"

LEARNING EXAMPLES:
✓ "our team prefers assertion-based error management" → Extract team policy about assertions
✓ "we don't use magic numbers, always use constants" → Extract coding standard
✓ "in our codebase, we use TypeScript instead of JavaScript" → Extract technology preference
✗ "this code has a bug" → No learning (just reporting an issue)
✗ "can you explain this function?" → No learning (just asking for help)

If you identify a learning, add this JSON block at the end of your response:
```learning
{
  "type": "team_policy|coding_standard|preference|rule",
  "title": "Brief descriptive title of what you learned",
  "content": "Full description of the team's practice, preference, or rule",
  "tags": ["relevant", "keywords", "for_searching"],
  "scope": "org|repo",
  "confidence": 1-5
}
```

Only include learning block if there's genuinely something worth learning. Most responses won't have learnings. Never repeat a previously acknowledged learning unless this comment introduces new guidance.

RESPONSE:

Here is the full MR context:

Full Code and Comments CONTEXT for the MR:
**Code Location:**
- File: activepm2.py
- Line: 87
- Type: new

=== Org learnings ===
Incorporate the following established org guidance when drafting your reply:
- [REJDUF] Propagate errors to errgroup for proper error handling: When using errgroup, always return errors...
  Propagate errors to errgroup for proper error handling: When using errgroup, always return errors from goroutines so that errgroup.Wait() can detect and handle them. Avoid returning nil after logging an error, as this masks the issue.
  Tags: errgroup, error handling, concurrency
- [TS958I] Team prefers plain text logging over structured logging: The team prefers using plain text loggin...
  Team prefers plain text logging over structured logging: The team prefers using plain text logging instead of structured logging.
  Tags: logging, plain text, structured logging
- [SI4Q2K] Team prefers plain text logging over structured logging: The team prefers using plain text loggin...
  Team prefers plain text logging over structured logging: The team prefers using plain text logging instead of structured logging.
  Tags: logging, plain text, structured logging
- [RRE20S] Team prefers plain text logging over structured logging: The team prefers using plain text loggin...
  Team prefers plain text logging over structured logging: The team prefers using plain text logging instead of structured logging.
  Tags: logging, plain text, structured logging
- [24TPBQ] Team prefers plain text logging over structured logging: The team prefers using plain text loggin...
  Team prefers plain text logging over structured logging: The team prefers using plain text logging instead of structured logging.
  Tags: logging, plain text, structured logging
- [LAPB27] Team prefers plain text logging over structured logging: The team prefers using plain text loggin...
  Team prefers plain text logging over structured logging: The team prefers using plain text logging instead of structured logging.
  Tags: logging, plain text, structured logging
- [I5KBYR] Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronou...
  Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronous issues. Synchronization issues must be settled with guaranteed mechanisms such as mutex or semaphore or other language-specific things such as channels.
  Tags: async, synchronization, mutex, semaphore, channels, sleep
- [VB9W14] Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronou...
  Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronous issues. Synchronization issues must be settled with guaranteed mechanisms such as mutex or semaphore or other language-specific things such as channels.
  Tags: async, synchronization, mutex, semaphore, channels, sleep
- [00H01V] Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronou...
  Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronous issues. Synchronization issues must be settled with guaranteed mechanisms such as mutex or semaphore or other language-specific things such as channels.
  Tags: async, synchronization, mutex, semaphore, channels, sleep
- [1NVI5I] Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronou...
  Avoid using Sleep for async synchronization: The team avoids using Sleep to deal with asynchronous issues. Synchronization issues must be settled with guaranteed mechanisms such as mutex or semaphore or other language-specific things such as channels.
  Tags: async, synchronization, mutex, semaphore, channels, sleep
- [1CFEJH] Detailed error handling with explicit exit: The team always prefers detailed error handling
  Detailed error handling with explicit exit: The team always prefers detailed error handling. If an error occurs, the application should log the error and exit rather than continuing in a faulty state.
  Tags: error handling, exit, logging, faulty state
- [RNJKZ6] Error Handling After Configuration Parsing: Always check the error returned by `parseConfig()`, l...
  Error Handling After Configuration Parsing: Always check the error returned by `parseConfig()`, log the error with context, print an error message to stderr, and exit with a non-zero exit code.
  Tags: error handling, configuration, logging, exit code
- [2VBZ00] Prefer shorter variable names: The team prefers having shorter variable names where possible in t...
  Prefer shorter variable names: The team prefers having shorter variable names where possible in the LiveAPI repository.
  Tags: variable names, naming conventions, readability
- [MAPGTA] Configuration via files, not environment variables: The repository avoids using environment varia...
  Configuration via files, not environment variables: The repository avoids using environment variables for configuration, preferring configuration files instead.
  Tags: configuration, environment variables, files
- [J5ZWQO] Do not use environment variables: The team has a rule against using environment variables in the ...
  Do not use environment variables: The team has a rule against using environment variables in the codebase.
  Tags: environment variables, configuration, rule
- [256DEF] Avoid using environment variables: The team has a policy to avoid using environment variables in ...
  Avoid using environment variables: The team has a policy to avoid using environment variables in the codebase.
  Tags: environment variables, policy, configuration
- [74KZKO] Team prefers using assertions: The team generally prefers using assertions in their code.
  Team prefers using assertions: The team generally prefers using assertions in their code.
  Tags: assertions, error handling, testing

